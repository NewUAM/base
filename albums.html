<!DOCTYPE html> 
<html lang="ua">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NUAM Albums</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

  <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    @font-face {
  font-family: "CustomFont";
  src: url("https://static.wixstatic.com/ufonts/c77f36_8e332f6e48954416a7131ece2e2fab0f/woff2/file.woff2")
    format("woff2");
}

html,
body {
  font-family: "CustomFont", Arial, sans-serif;
  background-color: #282626;
  margin: 0;
  padding: 0;
}

h1 {
  margin-top: 20px;
  color: #f3f3f3;
}

h4 {
  text-align: center;
  margin-top: 20px;
  color: #f3f3f3;
}

body::-webkit-scrollbar {
  width: 10px;
}
body::-webkit-scrollbar-track {
  background: #282626;
}
body::-webkit-scrollbar-thumb {
  background-color: #383838;
  border-radius: 8px;
  border: 2px solid #282626;
}

body::-webkit-scrollbar-button {
  display: none;
}

body.no-scroll {
  position: fixed;
  width: 100%;
  overflow-y: scroll;
}

:root {
  --grain-bg: url('data:image/svg+xml;utf8,\
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">\
<filter id="grain">\
<feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" seed="2"/>\
<feColorMatrix type="saturate" values="0"/>\
</filter>\
<rect width="100%" height="100%" filter="url(%23grain)" opacity="0.15"/>\
</svg>');
}

.logo-wrapper {
  position: relative;
  display: inline-block;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 10px;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
  transition: border-radius 0.3s ease;
  z-index: 1000;
}

.logo-wrapper:hover {
  border-radius: 8px 8px 0 0;
}

.logo-dropdown {
  z-index: 1001;
}

.logo-row {
  display: flex;
  align-items: center;
  gap: 8px;
  line-height: 35px;
}
.logo-row img {
  height: 35px;
  width: auto;
  display: block;
}
.logo-row a {
  display: flex;
  font-size: 14px;
  align-items: center;
  gap: 8px;
  text-decoration: none;
  color: #f3f3f3;
}
.logo-row a:hover {
  text-decoration: none;
}

.vertical-sep {
  width: 1px;
  height: 31px;
  background: #555;
}

#app-logo {
  background-image: var(--nuam-logo-url);
  background-repeat: no-repeat;
  background-size: contain;
}

.logo-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  width: 100%;
  box-sizing: border-box;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 0 0 8px 8px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  overflow: hidden;
  max-height: 0;
  opacity: 0;
  transition:
    max-height 0.3s ease,
    opacity 0.3s ease,
    transform 0.3s ease;
  z-index: 100;
  padding: 0 10px 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

.logo-wrapper:hover .logo-dropdown {
  max-height: 200px;
  opacity: 1;
  transform: translateY(0);
}

.logo-row a {
  position: relative;
  overflow: hidden;
}

.logo-row a img {
  position: relative;
  z-index: 1;
  transition: opacity 0.3s ease;
}

.logo-row a::after {
  content: "";
  position: absolute;
  inset: 0;
  z-index: 2;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  background: linear-gradient(135deg, #84aafb, #90ee90);
  mask-size: contain;
  mask-repeat: no-repeat;
  mask-position: left center;
  -webkit-mask-size: contain;
  -webkit-mask-repeat: no-repeat;
  -webkit-mask-position: left center;
}

.logo-row a:hover::after {
  opacity: 1;
}

.logo-row:first-child a::after {
  mask-image: var(--mask-logo-main);
  -webkit-mask-image: var(--mask-logo-main);
  background: linear-gradient(1deg, #cdd28d, #89bfd0);
}

.logo-dropdown .logo-row:nth-child(1) a::after {
  mask-image: var(--mask-logo-1);
  -webkit-mask-image: var(--mask-logo-1);
  background: linear-gradient(1deg, #cdd28d, #89bfd0);
}

.logo-dropdown .logo-row:nth-child(2) a::after {
  mask-image: var(--mask-logo-2);
  -webkit-mask-image: var(--mask-logo-2);
  background: linear-gradient(1deg, #cdd28d, #89bfd0);
}

.logo-dropdown .logo-row:nth-child(3) a::after {
  mask-image: var(--mask-logo-3);
  -webkit-mask-image: var(--mask-logo-3);
  background: linear-gradient(1deg, #cdd28d, #89bfd0);
}

.logo-row a:hover img {
  opacity: 0;
}

#loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #282626;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  opacity: 1;
  transition: opacity 0.6s ease;
}

#loading-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

#loading-screen img {
  max-width: 50%;
  margin-bottom: 20px;
}

#csv-loading {
  margin-top: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: stretch;
  min-width: 260px;
  max-width: 520px;
  background: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
  border-radius: 8px;
  padding: 20px 20px;
  color: #f3f3f3;
}
#csv-loading-title {
  font-size: 14px;
}
#csv-loading-bar {
  height: 10px;
  border-radius: 4px;
  background: #282626;
  overflow: hidden;
}
#csv-loading-fill {
  width: 0%;
  height: 100%;
  background: rgba(132, 170, 251, 0.8);
  transition: width 0.1s linear;
}
#csv-loading-info {
  font-size: 12px;
  color: #bababa;
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

.loading-text {
  color: #f3f3f3;
  font-size: 18px;
  margin-top: 20px;
  font-family: "CustomFont", sans-serif;
}

#genre-checkboxes::-webkit-scrollbar {
  width: 8px;
}
#genre-checkboxes::-webkit-scrollbar-track {
  background: transparent;
}
#genre-checkboxes::-webkit-scrollbar-thumb {
  background-color: #282626;
  border-radius: 8px;
  border: 1px solid transparent;
}

input[type="checkbox"] {
  width: 20px;
  height: 20px;
  margin: 5px 5px 5px 5px;
  cursor: pointer;
  appearance: none;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 4px;
  background-color: transparent;
  display: inline-block;
  position: relative;
  vertical-align: middle;
  margin-right: 10px;
  transition: border-color 0.3s ease;
}
input[type="checkbox"]:hover {
  border-color: rgba(132, 170, 251, 1);
}
input[type="checkbox"]:checked {
  background: rgba(132, 170, 251, 0.2);
  border-color: #84aafb;
}
input[type="checkbox"]:checked::after {
  content: "\2713";
  color: #f3f3f3;
  font-size: 12px;
  font-weight: bold;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

#albums-container .separator {
  grid-column: 1 / -1;
  display: flex;
  align-items: center;
  margin: 20px 0 20px;
  box-sizing: border-box;
}

#albums-container .separator .line {
  flex: 1;
  height: 2px;
  background-color: #383636;
  border: none;
}

#albums-container .separator .sep-text {
  margin: 0 10px;
  color: #f3f3f3;
  white-space: nowrap;
}

#genre-checkboxes {
  overflow-y: auto;
  display: grid;
  grid-template-columns: repeat(2, 1fr);
}

.controls {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  width: 460px;
  min-width: 260px;
  min-width: 0;
  position: fixed;
  top: 10px;
  bottom: 10px;
  left: 5px;
  padding: 10px 10px 10px 10px;
  overflow-y: auto;
  background: #282626;
  border-radius: 8px;
  border: 1px solid rgba(53, 53, 60, 0.55);
  background-clip: padding-box;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  user-select: none !important;
}

.controls::-webkit-scrollbar {
  width: 10px;
}
.controls::-webkit-scrollbar-track {
  background: transparent;
  margin: 5px 0;
}
.controls::-webkit-scrollbar-thumb {
  background: #383838;
  border-radius: 8px;
  border: 2px solid #282626;
}

.bottom-controls {
  margin-top: auto;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

label[for="nuam-recommended-checkbox"] {
  font-size: 14px;
}

.filter-section {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
  margin-bottom: 20px;
}

.filter-group {
  display: flex;
  flex-direction: row;
  gap: 10px;
  width: 100%;
  align-items: stretch;
}
.filter-group .checkbox-container {
  flex: 1;
  min-width: 0;
}

.checkbox-container {
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  padding: 5px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  max-height: 200px;
  overflow: hidden;
  position: relative;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}
.checkbox-container label {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  color: #f3f3f3;
}
.checkbox-container .section-title {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #282626;
  font-size: 16px;
  text-align: left;
  color: #f3f3f3;
  border-radius: 8px;
}
.checkbox-grid {
  display: flex;
  flex-direction: column;
}

.genre-name,
.language-name,
.release-type-filter-item {
  font-size: 14px;
}
.genre-count,
.language-count {
  color: gray;
  font-size: 12px;
}

.sort-and-blacklist {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
}
.sort-section {
  display: flex;
  gap: 10px;
  align-items: center;
}
#sort-order {
  cursor: pointer;
}
.sort-section select {
  width: 100%;
}
.sort-section label {
  flex-shrink: 0;
  white-space: nowrap;
}

.sort-section .custom-select {
  flex-grow: 1;
}

.custom-select.upward .options-container {
  top: auto;
  bottom: 100%;
  border-radius: 8px 8px 0 0;
  width: calc(100% + 2px);
}
.custom-select.upward.open {
  border-radius: 0 0 8px 8px;
}

.hide-listened-section {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 5px 5px 5px;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  justify-content: flex-start;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

.hide-listened-section label {
  align-items: center;
  gap: 8px;
}

.album-count {
  color: #f3f3f3;
  padding-bottom: 20px;
}

.blacklist-row {
  display: flex;
  gap: 10px;
  align-items: center;
}

.blacklist-row .blacklist-section {
  flex: none;
}

.blacklist-row .hide-listened-section {
  flex: 1;
  height: 37px;
  background-color: #383838;
  display: flex;
  align-items: center;
  padding: 0 10px;
  border-radius: 8px;
  gap: 8px;
}

#show-listened-albums {
  cursor: pointer;
  text-decoration: underline;
}

.release-column {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.release-column .checkbox-container {
  flex: none;
}

.release-column .hide-listened-section {
  margin-top: auto;
  display: flex;
  align-items: center;
  padding: 5px 10px 5px 5px;
  border-radius: 8px;
  gap: 8px;
}

.blacklist-container {
  display: flex;
  gap: 20px;
}
.blacklist-artists,
.blacklist-labels {
  flex: 1;
  max-height: 300px;
  overflow: hidden;
  background-color: #282626;
  border-radius: 8px;
}

.blacklist-artists h4,
.blacklist-labels h4 {
  position: sticky;
  top: 0;
  background-color: #282626;
  padding: 10px;
  margin: 0;
  border-radius: 8px;
  z-index: 1;
}
.blacklist-artists ul,
.blacklist-labels ul {
  list-style-type: none;
  padding: 0;
  margin-top: 0px;
  margin-bottom: 0px;
  color: #f3f3f3;
}
.blacklist-artists li,
.blacklist-labels li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px;
}

.blacklist-section {
}

.blacklist-artists.checkbox-container,
.blacklist-labels.checkbox-container {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

.blacklist-artists.checkbox-container ul,
.blacklist-labels.checkbox-container ul {
  flex: 1;
  overflow-y: auto;
}

.favorite-button {
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 11;
  cursor: pointer;
  padding: 5px;
  border-radius: 8px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  opacity: 0;
  transition:
    opacity 0.3s ease,
    transform 0.1s ease,
    border-color 0.3s ease;
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}
.favorite-button:hover {
  border-color: rgba(132, 170, 251, 1);
}

.album:hover .favorite-button {
  opacity: 1;
  transform: none;
  pointer-events: auto;
}

.favorite-button.clicked .favorite-icon {
  transform: scale(1.15);
}

.favorite-checkmark {
  position: absolute;
  top: 55%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 14px;
  color: #282626;
  font-weight: bold;
  display: none;
  z-index: 12;
  pointer-events: none;
}

.favorite-button svg {
  width: 100%;
  height: 100%;
}

.search-wrapper {
  display: flex;
  flex-direction: column;
  gap: 10px;
  flex-grow: 1;
  min-width: 0;
}

.search-buttons-column {
  display: flex;
  flex-direction: column;
  gap: 9px;
  width: 100%;
}

.search-buttons-column button {
  width: 100%;
  height: 23px;
  color: #f3f3f3;
  border-radius: 8px;
  font-size: 14px;
  font-family: "CustomFont";
  cursor: pointer;
  transition: border-color 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  padding: 0;
}

.search-buttons-column button:hover {
  border-color: rgba(132, 170, 251, 1);
}

#search-container {
  display: none;
  align-items: center;
  gap: 5px;
  width: 100%;
  padding: 0px 0px 15px 0px;
}

#search-input,
#preset-name-input,
#edit-name-input {
  flex-grow: 1;
  padding: 10px 5px 10px 10px;
  border-radius: 8px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  width: 100%;
  font-family: "CustomFont";
  background: #282626;
  color: #f3f3f3;
  transition: border 0.3s ease;
}
#preset-name-input,
#edit-name-input {
  width: 200px;
}
#search-input:focus,
#preset-name-input:focus {
  outline: none;
  box-shadow: none;
}
#search-input:hover,
#preset-name-input:hover,
#edit-name-input:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

input:-webkit-autofill,
input:-webkit-autofill:hover,
input:-webkit-autofill:focus,
input:-webkit-autofill:active {
  font-family: "CustomFont" !important;
  -webkit-text-fill-color: #f3f3f3 !important;
  box-shadow: 0 0 0px 1000px #282626 inset !important;
  border: 1px solid #84aafb !important;
}

#search-close {
  padding: 5px;
  border: none;
  background: none;
  color: #bababa;
  font-size: 16px;
  cursor: pointer;
  flex-shrink: 0;
  transition: color 0.3s ease;
}
#search-close:hover {
  color: #f3f3f3;
}

.tri-toggle {
  display: flex;
  gap: 5px;
  align-items: center;
  flex-shrink: 0;
  padding: 6px 5px 6px 5px;
  border-radius: 8px;
  background: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
  box-sizing: border-box;
}
.tri-toggle button {
  height: 28px;
  width: 28px;
  padding: 0 10px;
  border-radius: 8px;
  background: transparent;
  color: #f3f3f3;
  cursor: pointer;
  border: 1px solid rgba(132, 170, 251, 0.5);
  font-family: "CustomFont", Arial, sans-serif;
  font-size: 12px;
  line-height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition:
    border-color 0.2s,
    background-color 0.2s;
  white-space: nowrap;
}
.tri-toggle button:hover {
  border-color: rgba(132, 170, 251, 1);
}
.tri-toggle button.active {
  border-color: rgba(132, 170, 251, 1);
  background-color: rgba(132, 170, 251, 0.2);
}

#filters-container {
  display: flex;
  align-items: center;
  gap: 10px;
  width: 100%;
  padding: 0 0 15px 0;
  box-sizing: border-box;
  position: relative;
  min-width: 0;
  overflow-x: hidden;
}

#filters-container::-webkit-scrollbar {
  height: 8px;
}
#filters-container::-webkit-scrollbar-thumb {
  background: #383838;
  border-radius: 8px;
  border: 2px solid #282626;
}

#filters-container::before {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  left: 100px;
  width: 50px;
  pointer-events: none;
  background: linear-gradient(
    to right,
    rgba(40, 38, 38, 1) 0%,
    rgba(40, 38, 38, 0) 100%
  );
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 10;
}

#filters-container::after {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  right: 28px;
  width: 50px;
  pointer-events: none;
  background: linear-gradient(
    to left,
    rgba(40, 38, 38, 1) 0%,
    rgba(40, 38, 38, 0) 100%
  );
  z-index: 10;
  opacity: 0;
  transition: opacity 0.2s ease;
}

#filters-container.scrolled-right::after {
  opacity: 1;
}

#filters-container.scrolled::before {
  opacity: 1;
}

.presets-wrapper {
  display: flex;
  gap: 10px;
  padding-right: 16px;
  white-space: nowrap;
  overflow-x: auto;
  flex: 1 1 0;
  max-width: 340px !important;
  min-width: 0;
  position: relative;
  scrollbar-width: none;
  -ms-overflow-style: none;
  scroll-behavior: smooth;
  overscroll-behavior: contain;
}

.presets-wrapper::-webkit-scrollbar {
  display: none;
}

.preset-item {
  flex: 0 0 auto;
}

#filters-container .preset-item {
  flex: 0 0 auto;
  height: 40px;
  padding: 0 15px;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  font-size: 14px;
  font-family: "CustomFont", Arial, sans-serif;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: border-color 0.3s ease;
  white-space: nowrap;
}
#filters-container .preset-item:hover {
  border-color: rgba(132, 170, 251, 1);
}
#filters-container .preset-item.preset-active {
  border-color: rgba(132, 170, 251, 1);
  background-color: rgba(132, 170, 251, 0.2);
}

#filters-container #add-preset {
  flex: none;
  width: 40px;
  height: 40px;
  font-size: 24px;
  font-weight: bold;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 50%;
  transition: border-color 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}
#filters-container #add-preset:hover {
  border-color: rgba(132, 170, 251, 1);
}

#filters-close {
  background: none;
  border: none;
  color: #bababa;
  font-size: 16px;
  cursor: pointer;
  transition: color 0.3s ease;
  flex-shrink: 0;
  margin-left: auto;
  margin-right: 5px;
  padding: 0;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
}
#filters-close:hover {
  color: #f3f3f3;
}

.listened-albums-container {
  max-height: 300px;
  overflow-y: auto;
  padding: 0px 10px 10px 0px;
  border-radius: 8px;
}
.listened-albums-container ul {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
  list-style-type: none;
  padding: 0;
  margin: 0;
  color: #f3f3f3;
}
.listened-albums-container li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 10px;
  border-radius: 8px;
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}
.listened-albums-container a {
  color: #f3f3f3;
  text-decoration: none;
}
.listened-albums-container a:hover {
  text-decoration: underline;
}
.listened-albums-container .blacklist-cross {
  cursor: pointer;
  color: #c0392b;
  font-size: 16px;
  transition: color 0.3s ease;
}
.listened-albums-container .blacklist-cross:hover {
  color: #e74c3c;
}
.listened-albums-container::-webkit-scrollbar {
  width: 8px;
}
.listened-albums-container::-webkit-scrollbar-track {
  background: #282626;
}
.listened-albums-container::-webkit-scrollbar-thumb {
  background: #383838;
  border-radius: 8px;
}

label,
select,
button {
  color: #f3f3f3;
}

.button-group {
  display: flex;
  gap: 10px;
  margin-top: 10px;
}
.button-group button {
  flex: 1;
}

.custom-select {
  position: relative;
  width: 100%;
  background-color: rgba(53, 53, 60, 0.55);
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  font-family: "CustomFont", Arial, sans-serif;
  user-select: none;
  transition: border-color 0.3s ease;
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
}
.custom-select:hover {
  border-color: rgba(132, 170, 251, 1);
}

.custom-select.open {
  border-radius: 8px 8px 0 0;
  border: 1px solid rgba(132, 170, 251, 1);
}

.custom-select,
.custom-select .options-container {
  box-sizing: border-box;
  width: 100%;
}

.custom-select .selected {
  padding: 5px 5px 5px 10px;
  cursor: pointer;
  color: #f3f3f3;
  font-size: 14px;
  transition: border-radius 0.2s ease;
  background-clip: padding-box;
  border-radius: 8px;
}

.custom-select .selected {
  position: relative;
  padding-right: 28px;
}

.custom-select .selected::after {
  content: "";
  position: absolute;
  top: 50%;
  right: 8px;
  width: 12px;
  height: 12px;
  transform: translateY(-50%);
  pointer-events: none;
  opacity: 0.8;
  background: no-repeat center / contain
    url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24"><path d="M7 9l5-5 5 5" fill="none" stroke="%2384aafb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M7 15l5 5 5-5" fill="none" stroke="%2384aafb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
}

.custom-select.open .selected::after {
  opacity: 0;
}

.custom-select.open:not(.upward) .selected {
  background-color: #282626;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.custom-select.upward.open .selected {
  background-color: #282626;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

.custom-select .options-container {
  position: absolute;
  top: 100%;
  left: -1px;
  width: calc(100% + 2px);
  border-top: none;
  border-left: 1px solid rgba(132, 170, 251, 1);
  border-right: 1px solid rgba(132, 170, 251, 1);
  border-bottom: 1px solid rgba(132, 170, 251, 1);
  border-radius: 0 0 8px 8px;
  font-size: 14px;
  display: none;
  flex-direction: column;
  z-index: 10;
  overflow: hidden;
}

.custom-select.upward .options-container {
  top: auto;
  bottom: 100%;
  border-top: 1px solid rgba(132, 170, 251, 1);
  border-bottom: none;
  border-left: 1px solid rgba(132, 170, 251, 1);
  border-right: 1px solid rgba(132, 170, 251, 1);
  border-radius: 8px 8px 0 0;
  width: calc(100% + 2px);
}

.custom-select .option {
  padding: 5px 5px 5px 10px;
  cursor: pointer;
  color: #f3f3f3;
}

.custom-select .option:hover {
  background-color: #282626;
}

button {
  padding: 10px 10px;
  background-color: rgba(132, 170, 251, 0.2);
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0);
  border-radius: 8px;
  cursor: pointer;
  transition: border 0.3s ease;
}
button:hover {
  border: 1px solid #84aafb;
}

#reset-filters-btn {
  background-color: rgba(53, 53, 60, 0.1);
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  width: 28px;
  height: 28px;
  font-size: 16px;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  margin-left: 6px;
  cursor: pointer;
  transition:
    border 0.3s ease,
    background-color 0.3s ease;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

#reset-filters-btn:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

.modal-content #preset-save,
.modal-content #edit-name-save,
.keep-btn,
.delete-btn {
  padding: 10px 20px;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  font-size: 14px;
  transition: border 0.3s ease;
}
.modal-content #preset-save,
.modal-content #edit-name-save {
  width: 100px;
}
.modal-content #preset-save:hover,
.modal-content #edit-name-save:hover,
.keep-btn:hover,
.delete-btn:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

.delete-btn {
  border: 1px solid rgba(192, 57, 43, 0.5);
}
.delete-btn:hover {
  border: 1px solid rgba(192, 57, 43, 1);
}

#preset-save-message.error {
  color: #e74c3c;
  font-size: 13px;
  margin-left: 10px;
}

#albums-container {
  position: relative;
  margin-left: 480px;
  padding: 20px 20px 80px 20px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
  gap: 20px;
  user-select: none !important;
  align-items: start;
}

.album {
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  overflow: visible;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  position: relative;
  display: flex;
  flex-direction: column;
  min-width: 400px;
  max-width: 500px;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

.album img {
  width: 100%;
  height: auto;
  cursor: pointer;
  border-radius: 8px 8px 0px 0px;
  transition:
    transform 0.3s ease,
    z-index 0.3s ease,
    border-radius 0.3s ease;
  backface-visibility: hidden;
  transform-style: preserve-3d;
  will-change: transform, border-radius;
}

.album img:hover {
  transform: scale(1.01);
  z-index: 10;
  border-radius: 8px;
}

.album-details {
  padding: 15px;
  flex-grow: 1;
}
.album-details h3 {
  margin: 0 0 10px 0;
  color: #f3f3f3;
}
.album-details p {
  margin: 5px 0;
  color: #f3f3f3;
}
.album-details a {
  color: #f3f3f3;
  text-decoration: none;
  font-weight: bold;
}
.album-details a:hover {
  text-decoration: underline;
}

.album .album-links {
  display: flex;
  gap: 6px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.album:hover .album-links {
  opacity: 1;
}

.album .album-links a {
  display: flex;
  width: 20px;
  height: 20px;
  position: relative;
}

.album .album-links .icon-default,
.album .album-links .icon-hover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.album .album-links .icon-hover {
  opacity: 0;
  transition: opacity 0.2s ease;
}

.album .album-links a:hover .icon-hover {
  opacity: 1;
}

.album .album-links a:hover .icon-default {
  opacity: 0;
}

.spotify-icon {
  flex-shrink: 0;
}

.album a .spotify-icon {
  display: flex;
  width: 20px;
  height: 20px;
  position: relative;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.album:hover a .spotify-icon {
  opacity: 1;
}

.album a .spotify-icon .icon-default,
.album a .spotify-icon .icon-hover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.album a .spotify-icon .icon-hover {
  opacity: 0;
  transition: opacity 0.2s ease;
}

.album a .spotify-icon:hover .icon-hover {
  opacity: 1;
}

.album a .spotify-icon:hover .icon-default {
  opacity: 0;
}

.favorite-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  transition: transform 0.15s ease;
}

.favorite-icon-wrapper {
  position: absolute;
  top: 10px;
  left: 10px;
  font-size: 24px;
  z-index: 11;
  display: none;
}

.album:hover .favorite-icon-wrapper {
  display: block;
}

.favorite-icon-wrapper svg {
  width: 24px;
  height: 24px;
  cursor: pointer;
}

.tracks {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: auto;
  padding: 0 15px 15px;
  align-items: flex-start;
}

.track-circle {
  width: 40px;
  height: 40px;
  color: #f3f3f3;
  background-color: transparent;
  border-radius: 50%;
  border: 1px solid rgba(132, 170, 251, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  text-decoration: none;
  transition:
    background-color 0.3s ease,
    border-color 0.3s ease;
  position: relative;
  overflow: hidden;
}

.track-circle:hover {
  background-color: #282626;
  border-color: rgba(132, 170, 251, 1);
}
.track-circle i {
  font-size: 20px;
  color: #bababa;
  z-index: 1;
}
.track-circle .progress-fill {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 0%;
  background: rgba(132, 170, 251, 0.5);
  pointer-events: none;
  transition: width 0.1s linear;
}

.lazy-loading {
  text-align: center;
  margin: 0px 0px 100px 100px;
  margin-left: 480px;
  width: calc(100% - 480px);
  color: #f3f3f3;
  user-select: none !important;
}

audio {
  display: none;
}

.album-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(40, 38, 38, 0.7);
  display: none;
  pointer-events: none;
  z-index: 1;
}
.album-listened .album-overlay {
  display: block;
}
.album-listened img:hover {
  background-color: rgba(40, 38, 38, 0.7);
  border-radius: 0px !important;
  transform: none !important;
  z-index: auto !important;
}

.mark-listened-btn {
  cursor: pointer;
  padding: 5px 10px;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  align-self: flex-start;
  transition: border 0.3s ease;
  z-index: 9;
  transition: border-color 0.3s ease;
}
.mark-listened-btn:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

.enlarged-img {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 640px;
  z-index: 1000;
  cursor: pointer;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  user-select: none !important;
  opacity: 0;
  transition: opacity 0.3s ease;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
}
.enlarged-img.shown {
  opacity: 1;
}

.modal {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(53, 53, 60, 0.55);
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
  z-index: 2000;
}

.modal.hidden {
  display: none;
}

.modal-content {
  background-color: #282626;
  margin: 200px auto 0 auto;
  padding: 20px;
  border-radius: 8px;
  width: 1064px;
  user-select: none !important;
}

#preset-modal .modal-content {
  width: 520px;
  font-size: 14px;
}
#preset-modal .modal-content > #preset-name-input,
#preset-modal .modal-content > #preset-save,
#preset-modal .modal-content > #preset-desc-input,
#edit-name-modal .modal-content > #edit-name-input,
#edit-name-modal .modal-content > #edit-name-save,
#edit-name-modal .modal-content > #edit-desc-input {
  display: inline-block;
  vertical-align: middle;
  margin: 0;
}

#preset-modal .modal-content > #preset-name-input {
  margin-right: 10px;
}

#preset-name-input {
  width: 200px;
  flex: 0 0 auto;
}

#preset-modal .modal-content,
#edit-name-modal .modal-content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  margin: 0;
}

#preset-name-input,
#preset-desc-input,
#edit-name-input,
#edit-desc-input {
  box-sizing: border-box;
}

.preset-actions-row {
  display: flex;
  align-items: center;
}

.preset-separator {
  border: none;
  border-top: 1px solid #555;
  margin: 20px 0;
}

.preset-restore-row {
  display: flex;
  justify-content: flex-start;
}

#preset-restore {
  height: 40px;
  padding: 10px 20px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  background: transparent;
  color: #f3f3f3;
  font-size: 14px;
  cursor: pointer;
  transition:
    border-color 0.3s ease,
    opacity 0.3s ease !important;
}

#preset-restore:hover {
  border-color: rgba(132, 170, 251, 1);
}

#preset-modal .preset-separator,
#preset-modal #preset-restore {
  display: none;
}

#preset-restore-msg {
  margin-left: 15px;
  margin-top: 10px;
  margin-bottom: -10px;
  color: #7dc77d;
  opacity: 0;
  transition: opacity 0.35s ease;
}

.preset-restore-row.show-msg #preset-restore-msg {
  opacity: 1;
}

.preset-restore-row.fade-out > * {
  opacity: 0;
  transition: opacity 0.35s ease;
}

#preset-modal .preset-separator.fade-out {
  opacity: 0;
  transition: opacity 0.35s ease;
}

.tabcontent {
  display: none;
}
.tabcontent.active {
  display: block;
}
.tablink {
  background-color: rgba(132, 170, 251, 0.2);
  color: #f3f3f3;
  padding: 10px 20px;
  border: 1px solid rgba(132, 170, 251, 0);
  cursor: pointer;
  transition:
    border-color 0.3s ease,
    background-color 0.3s ease;
  font-weight: bold;
  margin-bottom: 20px;
  margin-right: 10px;
}
.tablink.active {
  background-color: rgba(132, 170, 251, 0.2);
  border-color: rgba(132, 170, 251, 1);
  color: #f3f3f3;
}
.tablink.active:hover {
  border-color: rgba(132, 170, 251, 1);
}
.tablink:hover {
  background-color: rgba(132, 170, 251, 0.2);
  border-color: rgba(132, 170, 251, 1);
}

.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  transition: color 0.3s ease;
}
.close:hover,
.close:focus {
  color: #f3f3f3;
  text-decoration: none;
  cursor: pointer;
}

.album-details .blacklist-cross {
  display: none;
}
.album-details:hover .blacklist-cross {
  display: inline;
}
.blacklist-cross {
  cursor: pointer;
  color: #c0392b;
  font-size: 11px;
  font-weight: bold;
  transition: color 0.3s ease;
  padding-right: 2px;
}
.blacklist-cross:hover {
  color: #e74c3c;
}

.export-import-container {
  display: flex;
  gap: 20px;
  justify-content: space-between;
}
.export-section,
.import-section {
  flex: 1;
}

textarea {
  width: 500px;
  height: 200px;
  padding: 10px;
  background-color: #282626;
  border-radius: 8px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  resize: none;
  color: #f3f3f3;
  scrollbar-width: auto;
  scrollbar-color: auto;
  transition: border-color 0.3s ease;
}
textarea:hover {
  border-color: rgba(132, 170, 251, 1);
}
textarea::-webkit-scrollbar {
  width: 14px;
}
textarea::-webkit-scrollbar-track {
  background: transparent;
}
textarea::-webkit-scrollbar-thumb {
  background-color: #383838;
  border-radius: 8px;
  border: 3px solid #282626;
}
textarea:focus {
  outline: none;
}

#export-data,
#import-data {
  margin-top: 0;
  padding: 10px 20px;
  font-size: 14px;
  cursor: pointer;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  width: fit-content;
  vertical-align: middle;
  transition: border 0.3s;
}
#export-data:hover,
#import-data:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#export-message,
#import-message {
  font-size: 13px;
  display: flex;
  align-items: center;
}

#export-message.success,
#import-message.success {
  color: #7dc77d;
}

#export-message.error,
#import-message.error {
  color: #e74c3c;
}

#favorites-albums-list li {
  display: flex;
  align-items: center;
  gap: 8px;
}
#favorites-albums-list li img {
  width: 40px;
  height: 40px;
  object-fit: cover;
  border-radius: 4px;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
}

#favorites-albums-list a {
  text-decoration: none;
  transition: text-decoration 0.2s;
}

#favorites-albums-list a:hover {
  text-decoration: underline;
}

.button-line {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

.exclude-genre,
.exclude-language {
  cursor: pointer;
  color: #c0392b;
  margin-left: 5px;
  font-size: 12px;
  font-weight: bold;
  transition: color 0.3s ease;
}
.exclude-genre:hover,
.exclude-language:hover {
  color: #e74c3c;
}

.genre-filter-item .exclude-genre {
  visibility: hidden;
}
.genre-filter-item:hover .exclude-genre {
  visibility: visible;
}
.language-filter-item .exclude-language {
  display: none;
}
.language-filter-item:hover .exclude-language {
  display: inline;
}
.repeat-symbol,
.language-repeat-symbol {
  color: #7dc77d;
}
.repeat-symbol:hover,
.language-repeat-symbol:hover {
  color: #90ee90;
}

.star-box {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 40px;
  height: 40px;
  display: grid;
  place-items: center;
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  border: none;
  line-height: 0;
  z-index: 11;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
}

.star-box .star-icon {
  display: block;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-size: 24px;
  line-height: 1;
  vertical-align: middle;
  color: #e6c200;
}

.section-title {
  position: sticky;
  top: 0;
  z-index: 10;
  background-color: #282626;
  padding: 10px 10px;
  font-size: 16px;
  font-weight: bold;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.genre-header {
  padding: 10px 10px;
  background-color: #282626;
  font-size: 18px;
}
.genre-buttons {
  display: flex;
  gap: 5px;
}
.genre-buttons button {
  display: flex;
  height: 28px;
  align-items: center;
  justify-content: center;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 8px;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  cursor: pointer;
  transition:
    border-color 0.3s,
    background-color 0.3s;
}
.genre-buttons button:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

.genre-buttons button.active {
  border-color: rgba(132, 170, 251, 1);
  background-color: rgba(132, 170, 251, 0.2);
}

#mode-any,
#mode-all,
#mode-only {
  width: 28px;
}

.alb-head {
  display: flex;
  gap: 12px;
  margin-bottom: 6px;
}
.rls-icon {
  width: 45px;
  height: 45px;
  flex-shrink: 0;
}
.alb-head-txt h3 {
  margin: 0;
  color: #f3f3f3;
  font-size: 18px;
}
.alb-head-txt .alb-artist,
.alb-head-txt {
  margin: 2px 0 0;
  color: #f3f3f3;
  font-size: 14px;
}
.alb-genres {
  font-size: 12px;
  margin: 2px 0 0;
  color: #f3f3f3;
}
.alb-artist {
  font-weight: bold;
}
.alb-artist a:hover {
  text-decoration: underline !important;
}

.alb-sep {
  border: 0;
  border-top: 1px solid #555;
  margin: 10px 0;
}

.alb-meta,
.alb-listens {
  display: flex;
  flex-wrap: wrap;
  font-size: 14px;
  color: #f3f3f3;
}
.alb-listens {
  gap: 6px;
}
.alb-meta p {
  width: 50%;
  box-sizing: border-box;
  display: flex;
  gap: 6px;
}
.alb-meta p svg,
.alb-listens svg,
.alb-meta svg {
  flex-shrink: 0;
  display: block;
}

.alb-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 10px;
}

.album-cover-wrapper {
  width: 100%;
  aspect-ratio: 1 / 1;
  background-color: #333;
  border-radius: 8px;
  position: relative;
}

.album-cover-wrapper img.album-cover {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
}

.controls,
.modal-content,
.controls *,
.modal-content * {
  overscroll-behavior: none;
}

#label-select .options-container {
  max-height: 500px;
  display: none;
  flex-direction: column-reverse;
  border-left: 1px solid #84aafb;
  border-right: 1px solid #84aafb;
  border-top: 1px solid #84aafb;
  border-bottom: none;
  position: absolute;
  width: calc(100% + 2px);
  z-index: 99;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
}
.options-container {
  overflow: hidden;
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
}

#label-select .option-list {
  overflow-y: auto;
}

#label-select .option-fixed {
  flex-shrink: 0;
  padding-bottom: 9px;
  border-top: 1px solid #84aafb;
  display: flex;
  flex-direction: column;
}

#label-select .option-search {
  padding: 5px 5px 5px 10px;
  background: #282626;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  transition: border 0.3s ease;
  border-radius: 8px;
  justify-content: center;
  margin-left: 10px;
  margin-right: 10px;
  margin-top: 5px;
  margin-bottom: 5px;
}

#label-select .option-search:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#label-select .option-search:focus {
  outline: none;
  box-shadow: none;
}

#label-select .option-fixed{ position: relative; }
#label-select .option-search{ padding-right: 28px; }

#label-select .option-clear{
  position: absolute;
  right: 10px;
  width: 26px;
  height: 16px;
  padding: 0px 0px;
  display: none;
  align-items: center;
  justify-content: center;
  border: 0;
  background: none;
  color: #bababa;
  line-height: 1;
  cursor: pointer;
  transition: color .15s ease;
}
#label-select .option-clear.visible{ display: flex; }
#label-select .option-clear:hover{ color: #eaeaea; }
  
#label-select .option-list {
  overflow-y: auto;
  max-height: 460px;
}

#label-select .option-list .option:first-child {
  border-top-left-radius: 8px;
}

#label-select .option-list .option:last-child {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

#label-select .option-list::-webkit-scrollbar {
  width: 14px;
}

#label-select .option-list::-webkit-scrollbar-track {
  background: transparent;
}

#label-select .option-list::-webkit-scrollbar-thumb,
#label-select .option-list::-webkit-scrollbar-thumb:hover,
#label-select .option-list::-webkit-scrollbar-thumb:active {
  background: #282626 !important;
  border: 3px solid #383838 !important;
  border-radius: 8px !important;
  background-clip: content-box !important;
}

#label-select .option-list::-webkit-scrollbar-button {
  display: none;
  width: 0;
  height: 0;
}

    #label-select .no-results {
  padding: 20px;
  text-align: center;
  color: #bababa;
  font-size: 14px;
  display: none;
  justify-content: center;
  align-items: center;
  height: 100%;
}

#label-select .label-sortbar{
  position: sticky; top: 0; z-index: 1;
  display: flex; align-items: center; gap: 8px;
  padding: 6px 10px;
  background-color: rgba(53, 53, 60, 0.55);
    background-image: var(--grain-bg);
    background-size: 20px 20px;
    background-blend-mode: overlay;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  border-bottom: 1px solid #84aafb;
}
#label-select .label-sortbar-title{
  font-family: "CustomFont"; font-size: 13px; color: #f3f3f3; white-space: nowrap;
}
#label-select .label-sortbar button{
  width: 28px; height: 28px;
  display: inline-flex; align-items: center; justify-content: center;
  border: 1px solid rgba(132,170,251,.5);
  border-radius: 6px; background: transparent; color: #f3f3f3; cursor: pointer;
  transition: border-color .2s ease, background .2s ease, color .2s ease;
}
#label-select .label-sortbar button.active{
  border-color: rgba(132,170,251,1);
  background: rgba(132,170,251,.1);
}

#label-select .label-sortbar i{
  font-size: 14px; line-height: 1; display: inline-block;
}

.option-all-labels {
  margin-top: 5px;
}
  
.range-wrapper {
  --start: 0%;
  --end: 100%;
  position: relative;
  height: 30px;
  margin: 5px 10px;
}

.range-wrapper::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 0;
  width: 100%;
  height: 4px;
  background: rgba(132, 170, 251, 0.2);
  border-radius: 2px;
  transform: translateY(-50%);
  pointer-events: none;
}

.range-wrapper::after {
  content: "";
  position: absolute;
  top: 50%;
  left: var(--start);
  width: calc(var(--end) - var(--start));
  height: 4px;
  background: rgba(132, 170, 251, 0.5);
  border-radius: 2px;
  transform: translateY(-50%);
  pointer-events: none;
}

.range-wrapper input[type="range"] {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  background: transparent;
  pointer-events: none;
  -webkit-appearance: none;
}
.range-wrapper input[type="range"]::-webkit-slider-runnable-track {
  background: transparent;
  height: 4px;
}
.range-wrapper input[type="range"]::-webkit-slider-thumb {
  pointer-events: all;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #84aafb;
  cursor: pointer;
  margin-top: -6px;
  -webkit-appearance: none;
}

#toggle-edit-presets {
  width: 40px;
  height: 40px;
  font-size: 14px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 50px;
  background: transparent;
  color: #f3f3f3;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: border-color 0.3s;
}
#toggle-edit-presets:hover {
  border-color: rgba(132, 170, 251, 1);
}

#toggle-edit-presets.active {
  border: 1px solid rgba(132, 170, 251, 1);
}

.presets-wrapper .preset-item .drag-handle {
  display: none;
}
.presets-wrapper.editing .preset-item {
  position: relative;
}
.presets-wrapper.editing .preset-item .drag-handle {
  display: block;
  position: absolute;
  bottom: 6px;
  left: 50%;
  transform: translateX(-50%);
  width: 20px;
  height: 4px;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 2px;
  cursor: grab;
}

.presets-wrapper.editing .preset-item .drag-handle::before {
  content: "";
  position: absolute;
  top: -7px;
  bottom: -7px;
  left: -7px;
  right: -7px;
}

.sortable-ghost {
  opacity: 1 !important;
}

.sortable-chosen {
  opacity: 0.3 !important;
  background-color: black !important;
}

.presets-wrapper .preset-item .delete-handle {
  display: none;
}
.presets-wrapper.editing .preset-item .delete-handle {
  display: block;
  position: absolute;
  top: 0;
  right: 0;
  width: 18px;
  height: 18px;
  line-height: 19px;
  text-align: center;
  background: #c0392b;
  color: #fff;
  border-radius: 0 8px 0 8px;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.3s;
}

.presets-wrapper.editing .preset-item .delete-handle:hover {
  background: #e74c3c;
}

.presets-wrapper .preset-item .edit-name-handle {
  display: none;
}
.presets-wrapper.editing .preset-item .edit-name-handle {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  width: 18px;
  height: 18px;
  line-height: 19px;
  text-align: center;
  background: #596990;
  color: #fff;
  border-radius: 8px 0 8px 0;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.3s;
}

.presets-wrapper.editing .preset-item .edit-name-handle:hover {
  background: #84aafb;
}

.modal-content input:not([type="checkbox"]) {
  flex-grow: 1;
  padding: 10px 5px 10px 10px;
  border-radius: 8px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  width: 100%;
  font-family: "CustomFont";
  background: #282626;
  color: #f3f3f3;
  transition: border 0.3s ease;
}
.modal-content input:not([type="checkbox"]):focus {
  outline: none;
  box-shadow: none;
}
.modal-content input:not([type="checkbox"]):hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#blacklist-content .bl-temp-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 0 0 10px 0;
  color: #f3f3f3;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  padding: 5px 10px 5px 5px;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
}

#blacklist-content .bl-temp-toggle label {
  cursor: pointer;
  user-select: none;
  margin: 0 0 0 -5px;
}

.modal-content {
  position: relative;
}

.modal-content h3 {
  display: block;
  vertical-align: middle;
  margin: 0 0 20px;
  color: #f3f3f3;
}

.modal-content .close {
  float: none !important;
  position: absolute !important;
  top: 20px;
  right: 20px;
  line-height: 1;
  font-size: 28px;
  cursor: pointer;
}

#edit-name-modal .modal-content {
  width: 520px;
}

.preview-overlay {
  position: fixed;
  inset: 0;
  background: rgba(53, 53, 60, 0.55);
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
  z-index: 1000;
}
.preview-overlay.hidden {
  display: none;
}

#toggle-preview-button {
  position: fixed;
  height: 40px;
  width: 40px;
  bottom: 30px;
  margin-left: 30px;
  z-index: 999;
  background: rgba(53, 53, 60, 0.75);
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  transition: border 0.3s ease;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
}

#toggle-preview-button:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#toggle-preview-button:has(.fa-volume-up) {
  background: rgba(132, 170, 251, 0.2);
  border: 1px solid rgba(132, 170, 251, 1);
  background-image: var(--grain-bg);
  background-blend-mode: overlay;
}

#album-count-badge {
  position: fixed;
  bottom: 30px;
  z-index: 100;
  background: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  height: 40px;
  padding: 0 12px;
  box-sizing: border-box;
  color: #f3f3f3;
  font-size: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  white-space: nowrap;
  gap: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
  user-select: none;
  cursor: default;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
}

.actions-row {
  display: flex;
  gap: 10px;
  align-items: center;
}

#favorites-button,
#blacklist-button,
#stats-button {
  width: 145px;
}

.genre-buttons {
  display: flex;
  align-items: center;
  gap: 8px;
}

.genre-buttons label {
  display: inline-flex;
  align-items: center;
  font-weight: normal;
  gap: 0px;
  font-size: 12px;
  color: #f3f3f3;
  cursor: pointer;
}

.genre-buttons input[type="checkbox"] {
  width: 16px;
  height: 16px;
  margin-right: 8px;
}

.genre-switch-sep {
  display: inline-block;
  width: 1px;
  height: 24px;
  background-color: #555;
  user-select: none;
}

.blacklist-artists,
.blacklist-labels {
  overflow: hidden;
}

.blacklist-artists.checkbox-container ul,
.blacklist-labels.checkbox-container ul {
  flex: 1;
  overflow-y: auto;
}

.blacklist-artists.checkbox-container ul::-webkit-scrollbar,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar {
  width: 8px;
}

.blacklist-artists.checkbox-container ul::-webkit-scrollbar-track,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-track {
  background: transparent;
}

.blacklist-artists.checkbox-container ul::-webkit-scrollbar-thumb,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-thumb,
.blacklist-artists.checkbox-container ul::-webkit-scrollbar-thumb:hover,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-thumb:hover,
.blacklist-artists.checkbox-container ul::-webkit-scrollbar-thumb:active,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-thumb:active {
  background: #282626 !important;
  border: 1px solid #282626 !important;
  border-radius: 8px !important;
  background-clip: content-box !important;
}

.blacklist-artists.checkbox-container ul::-webkit-scrollbar-button,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-button {
  display: none;
  width: 0;
  height: 0;
}

#scrollTopButton:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#open-stats-btn {
  position: fixed;
  bottom: 30px;
  height: 40px;
  width: 40px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px 12px;
  background: #3b4050;
  color: #f3f3f3;
  border: 1px solid #3b4050;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  cursor: pointer;
  user-select: none;
  transition: border 0.3s ease;
  z-index: 999;
}

#stats-modal .modal-content {
  width: 1200px;
  height: calc(100vh - 120px);
  margin: 0 auto;
  overflow: hidden;
  max-width: none;
  max-height: none;
}

#stats-modal .stats-scroll {
  max-height: 100%;
  height: calc(100% - 60px);
  overflow-y: auto;
  padding-right: 8px;
  border-radius: 8px;
  -webkit-overflow-scrolling: touch;
}

#stats-modal .stats-scroll::-webkit-scrollbar {
  width: 8px;
}
#stats-modal .stats-scroll::-webkit-scrollbar-track {
  background: #282626;
}
#stats-modal .stats-scroll::-webkit-scrollbar-thumb {
  background: #383838;
  border-radius: 8px;
}

#stats-body {
  display: grid;
  gap: 10px;
  grid-template-columns: repeat(12, 1fr);
  grid-template-areas:
    "total   total   total   total   langs    langs    langs    langs    listens  listens  listens  listens"
    "genres  genres  genres  genres  genres   genres   genres   genres   genres   genres   genres   genres"
    "tracks  tracks  tracks  tracks  tracks   tracks   duration duration duration duration duration duration"
    "weekly  weekly  weekly  weekly  weekly   weekly   weekly   weekly   weekly   weekly   weekly   weekly";
  align-items: start;
}

.stats-card.area-total {
  grid-area: total;
}
.stats-card.area-langs {
  grid-area: langs;
}
.stats-card.area-listens {
  grid-area: listens;
}
.stats-card.area-genres {
  grid-area: genres;
}
.stats-card.area-tracks {
  grid-area: tracks;
}
.stats-card.area-duration {
  grid-area: duration;
}

.stats-card.area-weekly {
  grid-area: weekly;
}

#weekly-scroll {
  overflow-x: auto;
  padding: 0 6px;
}
#weekly-canvas {
  height: 360px;
  aspect-ratio: auto;
  display: block;
}

#weekly-scroll::-webkit-scrollbar {
  height: 8px;
}
#weekly-scroll::-webkit-scrollbar-track {
  background: transporent;
}
#weekly-scroll::-webkit-scrollbar-thumb {
  background: #282626;
  border-radius: 8px;
}

#stats-types-inline {
  display: flex;
  flex-wrap: wrap;
  gap: 6px 20px;
  font-size: 12px;
  color: #bababa;
  align-items: center;
  justify-content: center;
  padding-bottom: 5px;
}
#stats-types-inline .type-item {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 5px 5px;
}
#stats-types-inline .type-val {
  font-weight: 700;
  color: #bababa;
}

#genres-canvases {
  display: grid;
  grid-template-rows: auto auto;
  gap: 10px;
}

.stats-card {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 5px;
  border-radius: 8px;
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
  color: #f3f3f3;
  overflow: visible;
}

.stats-card > h3 {
  top: 0;
  z-index: 10;
  background: #282626;
  padding: 10px;
  margin: 0;
  font-size: 16px;
  font-weight: 700;
  color: #f3f3f3;
  border-radius: 8px;
}

.stats-total {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 48px;
  font-weight: 700;
  color: #f3f3f3;
  padding: 10px 0;
}

.stats-canvas {
  width: 100%;
  height: auto;
  aspect-ratio: 16/9;
  min-height: 160px;
  display: block;
}
#stats-body > .stats-card[style*="grid-column:1/-1"] .stats-canvas {
  min-height: 220px;
}

.stats-note {
  font-size: 12px;
  color: #a9b3c1;
  opacity: 0.8;
}

#favorites-modal .modal-content,
#favorites-modal .modal-content * {
  user-select: text !important;
}

.stats-title {
  margin: 0 0 20px;
}
.stats-title .stats-mode-wrap {
  display: inline-flex;
  vertical-align: middle;
  margin-left: 20px;
  position: static !important;
  padding: 5px 5px 5px 5px;
}
.stats-title .stats-mode-wrap button {
  line-height: 1;
  padding: 5px 5px 5px 5px;
}

    .ld-sep{
  display:block;
  height:1px;
  background:#555;
  border:0;
  margin-left:-10px;
  margin-right:-10px;
  width:calc(100% + 20px);
  box-sizing:content-box;
}
.ld-actions{
  display:flex;
  gap:10px;
  justify-content:center;
  align-items:center;
  padding:0;
  margin:0;
}

.ld-btn{
  display:flex !important;
  width:100%;
  height:30px;
  color:#f3f3f3;
  border-radius:8px;
  font-size:14px;
  font-family:"CustomFont";
  cursor:pointer;
  transition:border-color .3s ease;
  align-items:center;
  justify-content:center;
  box-sizing:border-box;
  padding:0;
  border: 1px solid rgba(132, 170, 251, 0);
  background-color: rgba(132, 170, 251, 0.2);
  text-decoration:none;
  line-height:1;
}

.ld-btn:hover{ border-color:rgba(132,170,251,1); text-decoration:none; }

.ld-btn__icon {
    width: 14px;
    height: 14px;
    flex: 0 0 14px;
    margin-left: 5px;
    display: block;
    align-self: center;
    transform: translateY(-2px);
}

.ld-btn__icon path{ fill:#f3f3f3; }
  
    #nuam-about-modal .modal-content,
#about-modal .modal-content {
  margin: 0;
  max-width: 100vh;
  overflow: auto;
}
    
    #nuam-about-modal .nuam-modal__body a,
#about-modal .modal-body a {
  color: #84aafb !important;
  font-weight: 700 !important;
  text-decoration: none !important;
}

#nuam-about-modal .nuam-modal__body a:hover,
#about-modal .modal-body a:hover {
  text-decoration: underline;
}

#nuam-about-modal .nuam-modal__body a:visited,
#about-modal .modal-body a:visited {
  color: #84aafb !important;
}
 
@media (max-width: 768px) {
  .controls {
    flex-direction: column;
    align-items: center;
  }
  .controls button,
  .controls select,
  .controls label {
    width: 100%;
    max-width: 300px;
  }
}

  </style>
</head>
<body>
  
  <div id="loading-screen">
  <img
    src="https://static.wixstatic.com/media/c77f36_f267062b41fa4c0a9d708971e3a36a18~mv2.png"
    alt="NUAM Albums Logo"
  />
  <div id="csv-loading">
    <div id="csv-loading-title">   NUAM</div>
    <div id="csv-loading-bar"><div id="csv-loading-fill"></div></div>
    <div id="csv-loading-info">
      <span id="csv-loaded">0 </span><span id="csv-total"></span>
    </div>
  </div>
</div>

<div class="controls">
  <div style="display: flex; align-items: stretch; gap: 10px; width: 100%;">
    <div class="logo-wrapper">
      <div class="logo-row">
        <a href="https://nuam.club/albums">
          <img
  id="app-logo"
  data-src="https://static.wixstatic.com/media/c77f36_f267062b41fa4c0a9d708971e3a36a18~mv2.png"
  alt="NUAM Albums Logo"
/>
          <span class="vertical-sep"></span>
          <span>  </span>
        </a>
      </div>

      <div class="logo-dropdown">
        <div class="logo-row">
          <a href="https://nuam.club/base">
            <img
  data-src="https://static.wixstatic.com/media/c77f36_266d45c9554a489da21c5f4fa4f9d79e~mv2.png"
  alt="NUAM Base Logo"
/>
            <span class="vertical-sep"></span>
            <span>  </span>
          </a>
        </div>
        <div class="logo-row">
          <a href="https://nuam.club/echo">
            <img
  data-src="https://static.wixstatic.com/media/c77f36_b0ac036b92b54f478d7e85548f99b6dd~mv2.png"
  alt="NUAM Echo Logo"
/>
            <span class="vertical-sep"></span>
            <span>  </span>
          </a>
        </div>
        <div class="logo-row">
          <a href="https://nuam.club">
            <img
              src="https://static.wixstatic.com/media/c77f36_09ede4c28e284822b304eab05c1f8d99~mv2.png"
              alt="NUAM Logo"
            />
            <span class="vertical-sep"></span>
            <span> </span>
          </a>
        </div>
        <div class="ld-sep" role="separator"></div>
<div class="ld-actions">
  <button id="ld-about-btn" type="button" class="ld-btn"> </button>

  <a class="ld-btn" href="https://send.monobank.ua/jar/2BLPSRWwYb" target="_blank" rel="noopener noreferrer">
    
    <svg class="ld-btn__icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      <path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3Zm-4 4v2H5v10h12v-5h2v7H3V7h7Z"/>
    </svg>
  </a>
</div>

      </div>
    </div>

    <div class="search-wrapper">
      <div class="search-buttons-column">
        <button id="search-button"></button>
        <button id="filters-button"></button>
      </div>
      <div
        id="search-container"
        style="display: none; align-items: center; gap: 5px;"
      >
        <div
          id="search-mode-toggle"
          class="tri-toggle"
          role="group"
          aria-label=" "
        >
          <button type="button" data-mode="artist"></button>
          <button type="button" data-mode="artist-album" class="active">
            +
          </button>
          <button type="button" data-mode="album"></button>
        </div>
        <input type="text" id="search-input" placeholder=" " />
        <button id="search-close"></button>
      </div>

      <div
        id="filters-container"
        style="display: none; align-items: center; gap: 10px; width: 100%; padding: 0 0 15px 0;"
      >
        <button id="add-preset" class="add-preset-btn">+</button>
        <button id="toggle-edit-presets">
          <i class="fas fa-pencil-alt"></i>
        </button>

        <div class="presets-wrapper">
          <button
            class="preset-item"
            data-preset-json='{"name":"","filters":{}}'
          >
            
          </button>
          <button
            class="preset-item"
            data-preset-json='{"name":"","filters":{}}'
          >
            
          </button>
          <button
            class="preset-item"
            data-preset-json='{"name":" ","filters":{}}'
          >
             
          </button>
          <button
            class="preset-item"
            data-preset-json='{"name":"","filters":{}}'
          >
            
          </button>
        </div>

        <button id="filters-close"></button>
      </div>
    </div>
  </div>

  <div id="preset-modal" class="modal hidden">
    <div class="modal-content">
      <span class="close" id="preset-close">&times;</span>
      <h3 style="color: #f3f3f3; margin-top: 0; margin-bottom: 20px;">
              
      </h3>
      <div class="preset-actions-row">
        <input
          id="preset-name-input"
          placeholder=" "
          style="margin-right:10px;"
        />
        <button id="preset-save" style="height:40px;"></button>
        <span id="preset-save-message"></span>
      </div>

      <input
        id="preset-desc-input"
        placeholder="  (')"
        maxlength="250"
        style="display:block; width:310px; margin-top:10px;"
      />

      <hr class="preset-separator" />

      <div class="preset-restore-row">
        <button id="preset-restore">  </button>
      </div>
    </div>
  </div>

  <div id="edit-name-modal" class="modal hidden">
    <div class="modal-content">
      <span class="close" id="edit-name-close">&times;</span>
      <h3>  </h3>
      <input
        id="edit-name-input"
        placeholder="  "
        style="margin-right:10px;"
      /><button id="edit-name-save" style="height:40px;"></button>
      <span id="edit-name-message"></span>
      <input
        id="edit-desc-input"
        placeholder="  (')"
        maxlength="250"
        style="width: 310px; display:block; margin:10px 0 0 0;"
      />
    </div>
  </div>

  <div class="filter-section">
    <div class="checkbox-container">
      <div class="section-title genre-header">
        <span></span>
        <div class="genre-buttons">
          <button class="mode-btn" id="mode-any">
            <i class="fas fa-layer-group"></i>
          </button>
          <button class="mode-btn" id="mode-all">
            <i class="fas fa-check-double"></i>
          </button>
          <button class="mode-btn" id="mode-only">
            <i class="fas fa-filter-circle-xmark"></i>
          </button>
          <span class="genre-switch-sep"></span>
          <button id="select-all-genres"> </button>
          <button id="deselect-all-genres"> </button>
        </div>
      </div>

      <div class="checkbox-grid" id="genre-checkboxes"></div>
    </div>
    <div class="filter-group">
      <div class="checkbox-container">
        <label class="section-title"></label>
        <div class="checkbox-grid" id="language-checkboxes"></div>
      </div>
      <div class="release-column">
        <div
          class="checkbox-container"
          style="max-height: none; overflow-y: visible;"
        >
          <label class="section-title"> </label>
          <div class="checkbox-grid" id="release-type-checkboxes"></div>
        </div>
        <div class="hide-listened-section">
          <label for="nuam-recommended-checkbox">
            <input
              type="checkbox"
              id="nuam-recommended-checkbox"
            /> NUAM
          </label>
        </div>
      </div>
    </div>
  </div>
  <div class="sort-and-blacklist">
    <div class="sort-section">
      <label for="sort-order">:</label>
      <div class="custom-select" id="sort-order">
        <div class="selected"> </div>
        <div class="options-container">
          <div class="option" data-value="desc"> </div>
          <div class="option" data-value="asc"> </div>
          <div class="option" data-value="listens-desc">
             
          </div>
          <div class="option" data-value="listens-asc">
             
          </div>
          <div class="option" data-value="duration-desc"> </div>
          <div class="option" data-value="duration-asc"> </div>
          <div class="option" data-value="tracks-desc">
              
          </div>
          <div class="option" data-value="tracks-asc">
              
          </div>
          <div class="option" data-value="popularity-growth">
              
          </div>
          <div class="option" data-value="random"> </div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="release-period-filter"> :</label>
      <div class="custom-select" id="release-period-filter">
        <div class="selected"> - </div>
        <div class="options-container">
          <div class="option" data-value=""> - </div>
          <div class="option" data-value="7">  </div>
          <div class="option" data-value="14">   </div>
          <div class="option" data-value="30">  </div>
          <div class="option" data-value="90">   </div>
          <div class="option" data-value="182">  </div>
          <div class="option" data-value="365">  </div>

          <div class="range-wrapper" id="release-period-range">
            <input
              type="range"
              id="release-period-start"
              min="0"
              max="0"
              step="1"
            />
            <input
              type="range"
              id="release-period-end"
              min="0"
              max="0"
              step="1"
            />
          </div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="listen-count-filter">:</label>
      <div class="custom-select" id="listen-count-filter">
        <div class="selected">- </div>
        <div class="options-container">
          <div class="option" data-value="">- </div>
          <div class="option" data-value="0-1000"> 1000</div>
          <div class="option" data-value="1000-2500"> 1000  2500</div>
          <div class="option" data-value="2500-5000"> 2500  5000</div>
          <div class="option" data-value="5000-10000"> 5000  10 000</div>
          <div class="option" data-value="10000-25000">
             10 000  25 000
          </div>
          <div class="option" data-value="25000-50000">
             25 000  50 000
          </div>
          <div class="option" data-value="50000-100000">
             50 000  100 000
          </div>
          <div class="option" data-value="100000-250000">
             100 000  250 000
          </div>
          <div class="option" data-value="250000-500000">
             250 000  500 000
          </div>
          <div class="option" data-value="500000-1000000">
             500 000  1 000 000
          </div>
          <div class="option" data-value="1000000-"> 1 000 000</div>

          <div class="range-wrapper" id="listen-count-range">
            <input
              type="range"
              id="listen-count-start"
              min="0"
              max="0"
              step="1"
            />
            <input
              type="range"
              id="listen-count-end"
              min="0"
              max="0"
              step="1"
            />
          </div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="duration-filter">:</label>
      <div class="custom-select" id="duration-filter">
        <div class="selected">- </div>
        <div class="options-container">
          <div class="option" data-value="">- </div>
          <div class="option" data-value="short"> 30 </div>
          <div class="option" data-value="medium">3060 </div>
          <div class="option" data-value="long">60120 </div>
          <div class="option" data-value="very-long"> 120 </div>

          <div class="range-wrapper" id="duration-range">
            <input type="range" id="duration-start" min="0" max="0" step="1" />
            <input type="range" id="duration-end" min="0" max="0" step="1" />
          </div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="track-count-filter"> :</label>
      <div class="custom-select" id="track-count-filter">
        <div class="selected">- </div>
        <div class="options-container">
          <div class="option" data-value="">- </div>
          <div class="option" data-value="5">5   </div>
          <div class="option" data-value="12">12   </div>

          <div class="range-wrapper" id="track-count-range">
            <input
              type="range"
              id="track-count-start"
              min="0"
              max="0"
              step="1"
            />
            <input type="range" id="track-count-end" min="0" max="0" step="1" />
          </div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="track-count-filter"> :</label>
      <div class="custom-select upward" id="label-select">
        <div class="selected"> </div>
        <div class="options-container">
          <div class="option" data-value=""> </div>
        </div>
      </div>
    </div>

    <div class="actions-row">
      <button id="favorites-button"> </button>
      <button id="blacklist-button"> </button>
      <button id="stats-button"></button>
    </div>
    <div class="bottom-controls">
      <div class="hide-listened-section">
        <label for="hide-listened">
          <input type="checkbox" id="hide-listened" />
          <span id="show-listened-albums"> </span>
        </label>
      </div>
      <div class="album-count">
           : <span id="album-count">0</span>
      </div>
    </div>
  </div>
</div>

<div id="albums-container"></div>
<div id="preview-overlay" class="preview-overlay hidden"></div>

<div class="lazy-loading" id="lazy-loading"> </div>

<div id="blacklist-modal" class="modal hidden">
  <div class="modal-content">
    <span class="close">&times;</span>

    <div class="tabs">
      <button
        class="tablink"
        id="favorites-tab"
        onclick="openTab(event, 'favorites-content')"
      >
         
      </button>
      <button
        class="tablink active"
        id="blacklist-tab"
        onclick="openTab(event, 'blacklist-content')"
      >
         
      </button>
      <button
        class="tablink"
        id="listened-albums-tab"
        onclick="openTab(event, 'listened-albums-content')"
      >
         
      </button>
      <button
        class="tablink"
        id="export-tab"
        onclick="openTab(event, 'export-content')"
      >
         
      </button>
    </div>

    <div id="favorites-content" class="tabcontent">
      <div class="listened-albums-container">
        <ul id="favorites-albums-list"></ul>
      </div>
    </div>

    <div id="blacklist-content" class="tabcontent active">
      <div class="bl-temp-toggle">
        <input type="checkbox" id="temp-disable-blacklist" />
        <label for="temp-disable-blacklist"
          >   </label
        >
      </div>

      <div class="blacklist-container">
        <div class="blacklist-artists checkbox-container">
          <h4></h4>
          <ul id="blacklisted-artists"></ul>
        </div>
        <div class="blacklist-labels checkbox-container">
          <h4></h4>
          <ul id="blacklisted-labels"></ul>
        </div>
      </div>
    </div>

    <div id="listened-albums-content" class="tabcontent">
      <div class="listened-albums-container">
        <ul id="listened-albums-list"></ul>
      </div>
    </div>

    <div id="export-content" class="tabcontent">
      <div class="export-import-container">
        <div
          class="export-section"
          style="display:flex; flex-direction:column; gap:10px;"
        >
          <label for="data-textarea">  :</label>
          <textarea id="data-textarea" readonly></textarea>
          <div class="button-line">
            <button id="export-data"> </button>
            <span id="export-message">&nbsp;</span>
          </div>
        </div>

        <div
          class="import-section"
          style="display:flex; flex-direction:column; gap:10px;"
        >
          <label for="import-textarea">    :</label>
          <textarea
            id="import-textarea"
            placeholder="  "
          ></textarea>
          <div class="button-line">
            <button id="import-data"> </button>
            <span id="import-message">&nbsp;</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="listened-albums-content" class="tabcontent">
  <div class="listened-albums-container">
    <ul id="listened-albums-list"></ul>
  </div>
</div>
<div id="export-content" class="tabcontent">
  <div class="export-import-container">
    <div
      class="export-section"
      style="display: flex; flex-direction: column; gap: 10px;"
    >
      <label for="data-textarea">  :</label>
      <textarea id="data-textarea" readonly></textarea>
      <div class="button-line">
        <button id="export-data"> </button>
        <span id="export-message"></span>
      </div>
    </div>
    <div
      class="import-section"
      style="display: flex; flex-direction: column; gap: 10px;"
    >
      <label for="import-textarea">    :</label>
      <textarea id="import-textarea" placeholder="  "></textarea>
      <div class="button-line">
        <button id="import-data"> </button>
        <span id="import-message"></span>
      </div>
    </div>
  </div>
</div>

<div class="modal-overlay"></div>

  <div id="nuam-about-modal" class="modal hidden" aria-hidden="true">
  <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="nuam-about-title">

    <div class="nuam-modal__header">
      <h3 id="nuam-about-title" class="nuam-modal__title"> </h3>
      <button id="nuam-about-close" class="nuam-modal__close" aria-label=""></button>
    </div>
    <div class="nuam-modal__body">
      <p><strong>NUAM Albums</strong>    <a href="https://nuam.club" target="_blank" rel="noopener noreferrer">NUAM</a>       :  , -  .</p>
      <p>       ,       .      ,  ,      ,   .</p>
        <p>        ,  !</p>
    </div>
  </div>
</div>
  
<div
  id="scrollTopButton"
  onmouseenter="this.style.borderColor='rgba(132,170,251,1)'"
  onmouseleave="this.style.borderColor='rgba(132, 170, 251, 0.5)'"
  style='
  position: fixed;
  bottom: 20px;
  right: 30px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 1px solid rgba(132, 170, 251, 0.5);
  display: none;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 1999;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  transition: opacity 0.3s, border-color 0.3s ease;
  user-select: none;
  background-color: rgba(53, 53, 60, 0.55);
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: url(&apos;data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><filter id="grain"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" seed="2"/><feColorMatrix type="saturate" values="0"/></filter><rect width="100%25" height="100%25" filter="url(%23grain)" opacity="0.15"/></svg>&apos;);
  background-size: 20px 20px;
  background-blend-mode: overlay;
'
>
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    fill="#f3f3f3"
    viewBox="0 0 24 24"
  >
    <path d="M12 4l-8 8h6v8h4v-8h6z" />
  </svg>
</div>

  <script>
    
const NUAM_CACHE_NAME='nuam-cache-v1';
const NUAM_KEYS={etag:'nuam.csv:etag',lm:'nuam.csv:lm',len:'nuam.csv:len',hash:'nuam.csv:sha256'};

const CSVLOG = {
  on: true,
  g: null,
  start(tag, url){ if(!this.on) return; this.g = console.groupCollapsed ? console.groupCollapsed(`[CSV] ${tag}: ${url}`) : null; },
  info(...a){ if(this.on) console.log('[CSV]', ...a); },
  end(){ if(this.on && console.groupEnd) console.groupEnd(); }
};

async function sha256Hex(t){
  const enc=new TextEncoder().encode(t);
  const buf=await crypto.subtle.digest('SHA-256',enc);
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function readFromCache(url){
  const c=await caches.open(NUAM_CACHE_NAME);
  const m=await c.match(url,{ignoreSearch:false,ignoreVary:false});
  return m ? await m.text() : null;
}
async function writeToCache(url,text){
  const c=await caches.open(NUAM_CACHE_NAME);
  await c.put(url,new Response(text,{headers:{'Content-Type':'text/csv; charset=utf-8'}}));
}
function normETag(s){ return (s||'').trim().replace(/^W\//i,'').replace(/^"+|"+$/g,''); }

async function loadNuamCsvText(url){
  const ttl = document.getElementById("csv-loading-title");

  const prevET = localStorage.getItem(NUAM_KEYS.etag) || '';
  const prevLM = localStorage.getItem(NUAM_KEYS.lm)   || '';
  const prevHS = localStorage.getItem(NUAM_KEYS.hash) || '';

  const cachedBody = await readFromCache(url);

  if (prevET || prevLM){
    const h = new Headers();
    if (prevET) h.set('If-None-Match', prevET);
    if (prevLM) h.set('If-Modified-Since', prevLM);

    const r = await fetch(url, { method:'GET', headers:h, cache:'no-cache' });

    if (r.status === 304 && cachedBody != null){
      if (ttl) ttl.textContent = "   ";
      return { text: cachedBody, source: 'cache-304' };
    }

    if (r.ok){
      if (ttl) ttl.textContent = "  NUAM";
      const text = await r.text();
      await writeToCache(url, text);
      const et = r.headers.get('ETag'); if (et) localStorage.setItem(NUAM_KEYS.etag, normETag(et));
      const lm = r.headers.get('Last-Modified'); if (lm) localStorage.setItem(NUAM_KEYS.lm, lm);
      try{ const hsh = await sha256Hex(text); localStorage.setItem(NUAM_KEYS.hash, hsh); }catch(_){}
      return { text, source: 'network-200' };
    }

    if (cachedBody != null){
      if (ttl) ttl.textContent = "   ";
      return { text: cachedBody, source: 'cache-fallback' };
    }

    throw new Error('CSV fetch failed: ' + r.status);
  }

  const r2 = await fetch(url, { method:'GET', cache:'no-cache' });
  if (!r2.ok) throw new Error('HTTP ' + r2.status);
  if (ttl) ttl.textContent = "  NUAM";
  const text2 = await r2.text();
  await writeToCache(url, text2);
  const et2 = r2.headers.get('ETag'); if (et2) localStorage.setItem(NUAM_KEYS.etag, normETag(et2));
  const lm2 = r2.headers.get('Last-Modified'); if (lm2) localStorage.setItem(NUAM_KEYS.lm, lm2);
  try{ const h2 = await sha256Hex(text2); localStorage.setItem(NUAM_KEYS.hash, h2); }catch(_){}
  return { text: text2, source: 'network-200' };
}
    
    function loadCsvWithRetry(
  url,
  options,
  retries = 3,
  delay = 1000,
  fallbackUrl = null,
){
  let attempts = 0;

  async function tryLoad(currentUrl){
    const ttl = document.getElementById("csv-loading-title");
    if (ttl) ttl.textContent = "   NUAM";

    try{
      const res = await loadNuamCsvText(currentUrl);

      if (res && res.source && String(res.source).startsWith('cache')) {
        const t = document.getElementById("csv-loading-title");
        if (t) t.textContent = "   ";
      }
      const opts = { ...(options||{}) };
      if ('download' in opts) delete opts.download;
      Papa.parse(res.text, opts);

    }catch(err){
      attempts++;
      if (attempts < retries){
        setTimeout(()=>{ tryLoad(currentUrl); }, delay);
        return;
      }
      if (fallbackUrl && currentUrl !== fallbackUrl){
        attempts = 0;
        tryLoad(fallbackUrl);
        return;
      }
      if (options && typeof options.error === 'function'){
        try { options.error(err instanceof Error ? err : new Error(String(err))); } catch(_){}
      }
    }
  }

  tryLoad(url);
}

    const WORKER_URL = "https://nuam-albums.hi-f50.workers.dev";
    
async function getAccessToken() {
  const r = await fetch(`${WORKER_URL}/spotify/token`, { method: "POST" });
  const j = await r.json();
  return j.access_token;
}

async function getAlbumTracks(albumId, _token_ignored) {
  let all = [];
  let url = `${WORKER_URL}/spotify/v1/albums/${albumId}/tracks?limit=50`;
  while (url) {
    const r = await fetch(url);
    const j = await r.json();
    all = all.concat((j && j.items) || []);
    if (j && j.next) {
      const u = new URL(j.next);
      url = `${WORKER_URL}/spotify${u.pathname}${u.search}`;
    } else {
      url = null;
    }
  }
  return all.map((t) => ({
    id: t.id,
    name: t.name,
    artists: t.artists.map((a) => a.name),
  }));
}

let autoPlayingAlbum = null;
let autoPlayIndex = 0;
let currentHighlightedCircle = null;

async function loadAlbumTracksWithRetry(album) {
  if (!window._spotifyToken) {
    window._spotifyToken = await getAccessToken();
  }
  try {
    const list = await getAlbumTracks(album.albumID, window._spotifyToken);
    album.tracksInfo = Object.fromEntries(list.map((t) => [t.id, t]));
  } catch (err) {
    console.warn("    (  )", err);

    window._spotifyToken = await getAccessToken();

    const list = await getAlbumTracks(album.albumID, window._spotifyToken);
    album.tracksInfo = Object.fromEntries(list.map((t) => [t.id, t]));
  }
}

let activePresetButton = null;
let isPresetLoading = false;

(function () {
  if (window.__csvBarInstalled) return;
  window.__csvBarInstalled = true;

  function human(n) {
    if (!n && n !== 0) return "";
    const u = ["", "", "", ""];
    let i = 0;
    while (n >= 1024 && i < u.length - 1) {
      n /= 1024;
      i++;
    }
    return n.toFixed(i ? 1 : 0) + " " + u[i];
  }
  function isCsv(input) {
    try {
      const url =
        typeof input === "string" ? input : input && input.url ? input.url : "";
      if (window.newSheetUrl && typeof newSheetUrl === "string")
        return url === newSheetUrl;
      return /\/nuam\.csv(\?|$)/.test(url);
    } catch (_) {
      return false;
    }
  }
  function ensureIDs() {
    return !!(
      document.getElementById("csv-loading") &&
      document.getElementById("csv-loading-fill") &&
      document.getElementById("csv-loaded") &&
      document.getElementById("csv-total") &&
      document.getElementById("csv-loading-title")
    );
  }

  (function () {
    const _open = XMLHttpRequest.prototype.open;
    const _send = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.open = function (m, u) {
      this.__csv = isCsv(u);
      return _open.apply(this, arguments);
    };
    XMLHttpRequest.prototype.send = function (b) {
      if (this.__csv && ensureIDs()) {
        const fill = () => document.getElementById("csv-loading-fill");
        const got = () => document.getElementById("csv-loaded");
        const tot = () => document.getElementById("csv-total");
        const ttl = () => document.getElementById("csv-loading-title");

        this.addEventListener("progress", (e) => {
          if (e.lengthComputable) {
            tot().textContent = human(e.total);
            got().textContent = human(e.loaded);
            fill().style.width =
              Math.min(100, Math.round((e.loaded * 100) / e.total)) + "%";
          } else {
            got().textContent = human(e.loaded || 0);
          }
        });
        this.addEventListener("loadstart", () => {
  try {
    const l = Number(this.getResponseHeader && this.getResponseHeader("content-length"));
    if (l) tot().textContent = human(l);
  } catch (_) {}
  ttl().textContent = "  NUAM";
});

        this.addEventListener("loadend", () => {
  fill().style.width = "100%";
});

        this.addEventListener("error", () => {
          ttl().textContent = " ";
        });
        this.addEventListener("abort", () => {
          ttl().textContent = "";
        });
      }
      return _send.apply(this, arguments);
    };
  })();

  (function () {
    const _fetch = window.fetch;
    window.fetch = async function (res, init) {
      const rsp = await _fetch(res, init);
      try {
        if (!rsp.body || !isCsv(res) || !ensureIDs()) return rsp;
        const fill = document.getElementById("csv-loading-fill");
        const got = document.getElementById("csv-loaded");
        const tot = document.getElementById("csv-total");
        const ttl = document.getElementById("csv-loading-title");

        const total = Number(rsp.headers.get("content-length")) || 0;
        if (total) tot.textContent = human(total);

        ttl.textContent = "  NUAM";
const [a, b] = rsp.body.tee();
(async () => {
  const r = b.getReader();
  let rec = 0;
  for (;;) {
    const { done, value } = await r.read();
    if (done) break;
    rec += value.byteLength;
    got.textContent = human(rec);
    if (total) {
      fill.style.width = Math.min(100, Math.round((rec * 100) / total)) + "%";
    }
  }
  if (!total) {
    tot.textContent = human(rec);
    fill.style.width = "100%";
  }
})();
return new Response(a, {
  status: rsp.status,
  statusText: rsp.statusText,
  headers: rsp.headers,
});

      } catch (_) {
        return rsp;
      }
    };
  })();
})();

const newSheetUrl = "https://nuam-albums.hi-f50.workers.dev/nuam.csv";
const fallbackSheetUrl =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vTRGgPDeRNQcSe5tV2h3zu-rtMr-i7ph-4hU6HKglhXKdaAB5UFXUrdWLZKb8hwGyWgDxL5LDfnmrqe/pub?gid=1559781011&single=true&output=csv";

let searchQuery = "";

const previewPlayer = new Audio();

function markUnavailableCircle(circle) {
  if (!circle) return;

  circle.dataset.unavail = "1";

  const icon = circle.querySelector("i.fas");
  if (icon) {
    icon.className = "fas fa-music";
    icon.style.color = "#c0392b94";
  }

  if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
  if (typeof removeTooltip === "function") removeTooltip(circle);

  circle.removeAttribute("title");
  if (circle.dataset && "tooltip" in circle.dataset)
    delete circle.dataset.tooltip;

  if (typeof attachTooltip === "function") {
    attachTooltip(circle, "    ");
  }
}

let playToken = 0;

previewPlayer.preload = "none";
previewPlayer.crossOrigin = "anonymous";
let previewActivated = false;
let previewProbe = null;

const scrollTopButton = document.getElementById("scrollTopButton");
const togglePreviewBtn = document.createElement("button");
togglePreviewBtn.id = "toggle-preview-button";

attachTooltip(
  togglePreviewBtn,
  "     ",
  "180px",
);

scrollTopButton.parentNode.insertBefore(togglePreviewBtn, scrollTopButton);

const iconOn = '<i class="fas fa-volume-up"></i>';
const iconOff = '<i class="fas fa-volume-xmark"></i>';
togglePreviewBtn.innerHTML = iconOff;

(function moveAlbumCount() {
  const el = document.querySelector(".album-count");
  if (!el) return;
  el.classList.remove("album-count");
  el.id = "album-count-badge";
  document.body.appendChild(el);

  const resetBtn = document.createElement("button");
  resetBtn.id = "reset-filters-btn";
  resetBtn.type = "button";
  resetBtn.textContent = "";
  el.appendChild(resetBtn);

  if (typeof attachTooltip === "function") {
    attachTooltip(resetBtn, "   ", "250px");
  }

  resetBtn.addEventListener("click", (e) => {
    e.preventDefault();
    window.resetFiltersToDefault();
  });
})();

function togglePreview(state) {
  previewActivated =
    state === true || state === false ? state : !previewActivated;
  if (!previewActivated) {
    previewPlayer.pause();
    previewPlayer.currentTime = 0;
    previewPlayer.removeAttribute("src");
    previewPlayer.load();
  }
  togglePreviewBtn.innerHTML = previewActivated ? iconOn : iconOff;

  removeTooltip(togglePreviewBtn);
  attachTooltip(
    togglePreviewBtn,
    previewActivated
      ? "     "
      : "     ",
    "180px",
  );
}

togglePreview(previewActivated);
togglePreviewBtn.addEventListener("click", () => {
  if (autoPlayingAlbum) {
    const prevAlbum = autoPlayingAlbum;
    autoPlayingAlbum = null;

    const prevBtn = document.querySelector(
      `.play-all-toggle[data-album-id="${prevAlbum}"]`,
    );
    if (prevBtn) {
      prevBtn.innerHTML = '<i class="fas fa-play"></i>';
      removeTooltip(prevBtn);
      attachTooltip(prevBtn, "   ", "180px");
    }

    if (currentHighlightedCircle) {
      currentHighlightedCircle.classList.remove("highlight");
      currentHighlightedCircle = null;
    }

    const prevTracksContainer = document.querySelector(
      `.album[data-album-id="${prevAlbum}"] .tracks`,
    );
    if (prevTracksContainer) {
      prevTracksContainer
        .querySelectorAll(".track-circle .progress-fill")
        .forEach((el) => (el.style.width = "0%"));
    }

    previewPlayer.pause();
    previewPlayer.currentTime = 0;
    previewPlayer.ontimeupdate = null;
  }

  togglePreview();
});

function fixPos() {
  const cont = document.getElementById("albums-container");
  const btn = document.getElementById("toggle-preview-button");
  const stats = document.getElementById("open-stats-btn");
  const badge = document.getElementById("album-count-badge");
  if (!cont || !btn) return;

  btn.style.left = cont.getBoundingClientRect().left + "px";

  let baseRect = btn.getBoundingClientRect();
  if (stats) {
    stats.style.left = baseRect.left + baseRect.width + 10 + "px";
    baseRect = stats.getBoundingClientRect();
  }

  if (badge) {
    badge.style.left = baseRect.left + baseRect.width + 10 + "px";
  }
}

window.addEventListener("scroll", fixPos);
window.addEventListener("resize", fixPos);
fixPos();

const loaderImg = document.querySelector("#loading-screen img");
if (loaderImg) {
  document.getElementById("app-logo").src = loaderImg.src;
}

const artistsSheetId = "1_PavIrMhHpUHXG7uDrT83yznb2nrJfSd-9G8Hnm9ywM";
const artistsGid = "0";
const allowedArtistIds = new Set();

function showRestoredMessage() {
  const btn = document.getElementById("preset-restore");
  if (!btn) return;

  const FADE_MS = 300;
  const HOLD_MS = 2000;

  const parent = btn.parentNode;

  let msg = document.getElementById("preset-restore-msg");
  if (!msg) {
    msg = document.createElement("span");
    msg.id = "preset-restore-msg";
    msg.textContent = "  ";
    msg.style.cssText = [
      "display:inline-block",
      "opacity:0",
      "color:#7dc77d",
      `transition:opacity ${FADE_MS}ms ease`,
      "white-space:nowrap",
    ].join(";");
    parent.insertBefore(msg, btn);
  }

  const cs = getComputedStyle(btn);
  msg.style.minWidth = cs.width;
  msg.style.lineHeight = cs.height;

  btn.style.transition = `opacity ${FADE_MS}ms ease`;
  void btn.offsetWidth;
  btn.style.opacity = "0";

  setTimeout(() => {
    btn.style.display = "none";
    msg.style.opacity = "1";
  }, FADE_MS);

  setTimeout(() => {
    msg.style.opacity = "0";
  }, FADE_MS + HOLD_MS);

  setTimeout(
    () => {
      msg.remove();
      btn.style.display = "";
      btn.style.opacity = "0";
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          btn.style.opacity = "1";
        });
      });
    },
    FADE_MS + HOLD_MS + FADE_MS,
  );
}

function restoreDefaultsAndNotify(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  if (typeof restoreDefaultPresets === "function") restoreDefaultPresets();
  if (typeof loadPresetsFromStorage === "function") loadPresetsFromStorage();
  if (typeof updateRestorePresetUI === "function") updateRestorePresetUI();
  showRestoredMessage();
}

function loadAllowedArtists() {
  return new Promise((resolve, reject) => {
    const q = encodeURIComponent("select F,K");
    const url = `https://docs.google.com/spreadsheets/d/${artistsSheetId}/gviz/tq?gid=${artistsGid}&tqx=out:csv&tq=${q}`;

    Papa.parse(url, {
      download: true,
      header: false,
      skipEmptyLines: true,
      complete: (results) => {
        results.data.forEach((row) => {
          row.forEach((cell) => {
            if (!cell) return;
            const m = cell.match(/artist\/([^?]+)/);
            if (m) allowedArtistIds.add(m[1]);
          });
        });

        resolve();
      },
      error: (err) => {
        console.error("     ", err);
        reject(err);
      },
    });
  });
}

let albumsData = [];
let currentIndex = 0;
let sortOrder = "desc";
let hideListened = false;
let audioActivated = false;
let filteredAlbums = [];
let isFiltering = false;
let blacklistedArtists = new Set(
  JSON.parse(localStorage.getItem("blacklistedArtists")) || [],
);
let blacklistedLabels = new Set(
  JSON.parse(localStorage.getItem("blacklistedLabels")) || [],
);
let labelFilter = "";

const LABEL_ALIASES = {
  "": [" Distribution"],
  "Dear Deer": ["Dear Deer Black"],
  "GM DIGITAL": ["Gm Digital", "Vg Star / Gm Digital"],
  "BEST MUSIC": ["LEVEL SOUND / Best Music"],
  "NoLeak": ["NoLeakLabel"],
  "Papa Music": ["Papa Music 2.0"],
  "ReidlMusic": ["ReidlMusic, LLC.", "REIDLMUSIC, LLC."],
  "Vista": ["Vista Distribution"],
  "VG STAR": ["Vg Star / Gm Digital", "VG STAR RN"]
};
const __LABEL_VARIANT_TO_CANON = (() => {
  const m = new Map();
  for (const [canon, vars] of Object.entries(LABEL_ALIASES)) {
    const k = canon.trim();
    m.set(k.toLowerCase(), k);
    m.set(k, k);
    (vars || []).forEach(v => {
      const vv = String(v).trim();
      if (vv) m.set(vv.toLowerCase(), k);
    });
  }
  return m;
})();
function canonLabel(lbl){
  if (!lbl) return "";
  const key = String(lbl).trim();
  return __LABEL_VARIANT_TO_CANON.get(key.toLowerCase()) || key;
}
    
function releaseIcon(t) {
  if (t === "compilation")
    return `<svg class="rls-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><rect x="5" y="5" width="190" height="190" rx="40" ry="40" fill="none" stroke="#f3f3f3" stroke-width="4"/><text x="50%" y="43%" text-anchor="middle" font-family="Arial Black, Arial, sans-serif" font-size="75" fill="#f3f3f3">CO</text><text x="50%" y="83%" text-anchor="middle" font-family="Arial Black, Arial, sans-serif" font-size="75" fill="#f3f3f3">MP</text></svg>`;
  if (t === "album")
    return `<svg class="rls-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><rect x="5" y="5" width="190" height="190" rx="40" ry="40" fill="none" stroke="#f3f3f3" stroke-width="4"/><text x="50%" y="54%" text-anchor="middle" dominant-baseline="middle" font-family="Arial Black, Arial, sans-serif" font-size="115" fill="#f3f3f3">LP</text></svg>`;
  return `<svg class="rls-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><rect x="5" y="5" width="190" height="190" rx="40" ry="40" fill="none" stroke="#f3f3f3" stroke-width="4"/><text x="50%" y="54%" text-anchor="middle" dominant-baseline="middle" font-family="Arial Black, Arial, sans-serif" font-size="115" fill="#f3f3f3">EP</text></svg>`;
}

const listenedAlbums = JSON.parse(localStorage.getItem("listenedAlbums")) || {};
const favoriteAlbums = JSON.parse(localStorage.getItem("favoriteAlbums")) || {};

const languageLabels = {
  ukr: "",
  eng: "",
  rus: "",
  "other lang": " ",
};

const REPLACE_LABELS = {
  "other lang": " ",
  "producing work for international": "intl prod",
  "like old trash": "estrade",
};

function mapName(s) {
  const k = String(s).trim().toLowerCase();
  return REPLACE_LABELS[k] || s;
}

const batchSize = 20;
let isEmptyResult = false;

const PRESETS_KEY = "albumPresets";

const DEFAULT_PRESET_NAMES = [
  "",
  " ",
  " ",
  " ",
];

function isAnyDefaultMissing() {
  const names = new Set(getStoredPresets().map((p) => p.name));
  for (const n of DEFAULT_PRESET_NAMES) if (!names.has(n)) return true;
  return false;
}

function hasUserPresets() {
  const std = new Set(DEFAULT_PRESET_NAMES);
  return getStoredPresets().some((p) => !std.has(p.name));
}

function updateRestorePresetUI() {
  const modal = document.getElementById("preset-modal");
  const btn = modal && modal.querySelector("#preset-restore");
  const sep = modal && modal.querySelector(".preset-separator");
  if (!btn || !sep) return;

  if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
  if (typeof removeTooltip === "function") removeTooltip(btn);

  const STD = new Set([
    "",
    " ",
    " ",
    " ",
  ]);
  const list = getStoredPresets();
  const names = new Set(list.map((p) => p.name));

  const missingDefaults = [...STD].some((n) => !names.has(n));
  const hasUser = list.some((p) => !STD.has(p.name));

  btn.style.display = missingDefaults ? "inline-block" : "none";
  sep.style.display = missingDefaults ? "block" : "none";

  btn.dataset.missingDefaults = missingDefaults ? "1" : "0";
  btn.dataset.hasUser = hasUser ? "1" : "0";
}

const DEFAULT_PRESETS = [
  {
    name: "",
    desc: "       ",
    filters: {
      selectedGenres: [],
      excludedGenres: ["phonk", "ai", "producing work for international", "like old trash"],
      selectedLanguages: [],
      excludedLanguages: ["rus"],
      selectedReleaseTypes: [],
      sortOrder: "popularity-growth",
      hideListened: false,
      nuamRecommended: false,

      period: "14",
      periodStart: "",
      periodEnd: "",

      duration: "",
      durationStart: 0,
      durationEnd: 999,
      trackCount: "range",
      trackStart: 3,
      trackEnd: 999,
      labelFilter: "",

      listenCount: "",
      listenStart: 0,
      listenEnd: 999999999,

      genreMode: "any",
      genreOnlySelected: false,
    },
  },
  {
    name: " ",
    desc: "     ",

    filters: {
      selectedGenres: [],
      excludedGenres: ["phonk", "ai", "producing work for international", "like old trash"],
      selectedLanguages: [],
      excludedLanguages: ["rus"],

      selectedReleaseTypes: ["album"],
      sortOrder: "listens-desc",
      hideListened: false,
      nuamRecommended: false,

      period: "90",
      periodStart: "",
      periodEnd: "",

      duration: "",
      durationStart: 0,
      durationEnd: 999,
      trackCount: "",
      trackStart: 0,
      trackEnd: 999,
      labelFilter: "",

      listenCount: "",
      listenStart: 0,
      listenEnd: 999999999,

      genreMode: "any",
      genreOnlySelected: false,
    },
  },
  {
    name: " ",
    desc: "     ",

    filters: {
      selectedGenres: [
        "pop/indie",
        "rock",
        "hip-hop",
        "metal",
        "post-punk",
        "folk",
      ],
      excludedGenres: ["phonk", "ai", "producing work for international", "like old trash"],
      selectedLanguages: [],
      excludedLanguages: ["rus"],

      selectedReleaseTypes: ["album"],
      sortOrder: "popularity-growth",
      hideListened: false,
      nuamRecommended: false,

      period: "90",
      periodStart: "",
      periodEnd: "",

      duration: "range",
      durationStart: 40,
      durationEnd: 999,

      trackCount: "",
      trackStart: 0,
      trackEnd: 999,
      labelFilter: "",

      listenCount: "",
      listenStart: 0,
      listenEnd: 999999999,

      genreMode: "any",
      genreOnlySelected: false,
    },
  },
  {
    name: " ",
    desc: "    ?     .",

    filters: {
      selectedGenres: [],
      excludedGenres: ["phonk", "ai", "producing work for international", "like old trash"],
      selectedLanguages: [],
      excludedLanguages: ["rus"],
      selectedReleaseTypes: [],
      sortOrder: "random",
      hideListened: false,
      nuamRecommended: false,

      period: "182",
      periodStart: "",
      periodEnd: "",

      duration: "range",
      durationStart: 10,
      durationEnd: 20,

      trackCount: "",
      trackStart: 0,
      trackEnd: 999,
      labelFilter: "",

      listenCount: "range",
      listenStart: 1001,
      listenEnd: 999999999,

      genreMode: "any",
      genreOnlySelected: false,
    },
  },
];

function ensureDefaultPresets() {
  const current = getStoredPresets();
  const byName = new Map(current.map((p) => [p.name, p]));
  let changed = false;

  DEFAULT_PRESETS.forEach((def) => {
    const cur = byName.get(def.name);
    if (!cur) {
      current.push(def);
      changed = true;
    } else if (def.desc && !cur.desc) {
      cur.desc = def.desc;
      changed = true;
    }
  });

  if (changed) savePresetsToStorage(current);
}

function getStoredPresets() {
  try {
    const raw = localStorage.getItem(PRESETS_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch {
    return [];
  }
}
function savePresetsToStorage(arr) {
  localStorage.setItem(PRESETS_KEY, JSON.stringify(arr));
}

function restoreDefaultPresets() {
  if (typeof DEFAULT_PRESETS === "undefined") return;

  const current = getStoredPresets();
  const names = new Set(current.map((p) => p.name));
  let changed = false;

  DEFAULT_PRESETS.forEach((def) => {
    if (!names.has(def.name)) {
      current.push(def);
      changed = true;
    }
  });

  if (changed) savePresetsToStorage(current);
  loadPresetsFromStorage();
  updateRestorePresetUI();
}

function loadPresetsFromStorage() {
  const wrapper = presetsWrapper;
  if (!wrapper) return;
  wrapper.innerHTML = "";
  getStoredPresets().forEach((preset) => {
    const btn = document.createElement("button");
    btn.className = "preset-item";
    btn.textContent = preset.name;
    btn.dataset.presetJson = JSON.stringify(preset);
    btn.addEventListener("click", () => applyPreset(preset));
    if (preset.desc) {
      if (typeof attachTooltip === "function") attachTooltip(btn, preset.desc);
      btn.removeAttribute("title");
      btn.setAttribute("aria-label", preset.desc);
    }

    wrapper.appendChild(btn);
  });

  if (presetsWrapper.classList.contains("editing")) {
    attachPresetControls();

    if (sortable) sortable.destroy();
    sortable = Sortable.create(presetsWrapper, {
      animation: 150,
      handle: ".drag-handle",
      onEnd: () => {
        const newArr = Array.from(presetsWrapper.children).map((b) =>
          JSON.parse(b.dataset.presetJson),
        );
        savePresetsToStorage(newArr);
      },
    });
  }
  updateRestorePresetUI();
}

function clearActivePreset() {
  if (activePresetButton) {
    activePresetButton.classList.remove("preset-active");
    activePresetButton = null;
  }
}

function applyPreset(preset) {
  if (!preset.filters) return;
  isPresetLoading = true;

  localStorage.setItem("albumFilters", JSON.stringify(preset.filters));

  loadFiltersAfterRender();
  smoothApplyFilters();
  clearActivePreset();

  document
    .querySelectorAll("button.preset-item")
    .forEach((b) => b.classList.remove("preset-active"));
  const btn = [...document.querySelectorAll("button.preset-item")].find(
    (b) => b.textContent === preset.name,
  );
  if (btn) {
    btn.classList.add("preset-active");
    activePresetButton = btn;
  }

  isPresetLoading = false;
}

window.applyDefaultFilters = function () {
  ["phonk", "ai", "producing work for international", "like old trash"].forEach((g) => {
    const cb = document.getElementById(`genre-${encodeURIComponent(g)}`);
    if (cb) {
      cb.disabled = true;
      const cross = cb.parentNode.querySelector(".exclude-genre");
      cross.textContent = "";
      cross.classList.add("repeat-symbol");
      const lbl = cb.nextElementSibling;
      lbl.style.textDecoration = "line-through";
      lbl.style.color = "gray";
    }
  });
  const cbL = document.getElementById("language-rus");
  if (cbL) {
    cbL.disabled = true;
    const crossL = cbL.parentNode.querySelector(".exclude-language");
    crossL.textContent = "";
    crossL.classList.add("language-repeat-symbol");
    const lblL = cbL.nextElementSibling;
    lblL.style.textDecoration = "line-through";
    lblL.style.color = "gray";
  }
  document.getElementById("hide-listened").checked = true;
  hideListened = true;
  preserveScroll(() => smoothApplyFilters());
  saveFiltersToCache();
};

window.resetFiltersToDefault = function () {
  if (typeof clearActivePreset === "function") clearActivePreset();
  localStorage.removeItem("albumFilters");
  isPresetLoading = true;

  document.querySelectorAll(".genre-checkbox").forEach(function (cb) {
    cb.checked = false;
    cb.disabled = false;

    var parent = cb.closest(".genre-item") || cb.parentNode;
    var lbl =
      cb.nextElementSibling || (parent ? parent.querySelector("label") : null);
    if (lbl) {
      lbl.style.textDecoration = "none";
      lbl.style.color = "#f3f3f3";
      ["excluded", "removed", "gray-out", "line-through"].forEach(function (c) {
        lbl.classList.remove(c);
      });
    }
    if (parent && parent.classList) {
      ["excluded", "removed", "gray-out"].forEach(function (c) {
        parent.classList.remove(c);
      });
      if (parent.dataset) {
        delete parent.dataset.excluded;
        delete parent.dataset.state;
      }
    }
    var cross = parent
      ? parent.querySelector(".exclude-genre")
      : cb.parentNode.querySelector(".exclude-genre");
    if (cross) {
      cross.textContent = "";
      cross.classList.remove("repeat-symbol", "active");
      cross.removeAttribute("data-excluded");
      cross.removeAttribute("aria-pressed");
    }
  });

  document.querySelectorAll(".language-checkbox").forEach(function (cb) {
    cb.checked = false;
    cb.disabled = false;

    var parent = cb.closest(".language-item") || cb.parentNode;
    var lbl =
      cb.nextElementSibling || (parent ? parent.querySelector("label") : null);
    if (lbl) {
      lbl.style.textDecoration = "none";
      lbl.style.color = "#f3f3f3";
      ["excluded", "removed", "gray-out", "line-through"].forEach(function (c) {
        lbl.classList.remove(c);
      });
    }
    if (parent && parent.classList) {
      ["excluded", "removed", "gray-out"].forEach(function (c) {
        parent.classList.remove(c);
      });
      if (parent.dataset) {
        delete parent.dataset.excluded;
        delete parent.dataset.state;
      }
    }
    var cross = parent
      ? parent.querySelector(".exclude-language")
      : cb.parentNode.querySelector(".exclude-language");
    if (cross) {
      cross.textContent = "";
      cross.classList.remove("language-repeat-symbol", "active");
      cross.removeAttribute("data-excluded");
      cross.removeAttribute("aria-pressed");
    }
    cb.removeAttribute("data-excluded");
  });
  [
    "excludedLanguages",
    "excludedLangs",
    "languageExcludes",
    "langExcludes",
  ].forEach(function (key) {
    var v = window[key];
    if (Array.isArray(v)) v.length = 0;
    else if (v && typeof v.clear === "function") v.clear();
  });
  ["excludedLanguages", "languageExcludes", "langExcludes"].forEach(
    function (k) {
      try {
        localStorage.removeItem(k);
      } catch (e) {}
    },
  );

  document.querySelectorAll(".release-type-checkbox").forEach(function (cb) {
    cb.checked = false;
  });

  (function () {
    const any = document.getElementById("mode-any");
    const all = document.getElementById("mode-all");
    const only = document.getElementById("mode-only");
    [any, all, only].forEach((b) => {
      if (b) {
        b.classList.remove("active");
        b.setAttribute("aria-pressed", "false");
      }
    });
    if (any) {
      any.classList.add("active");
      any.setAttribute("aria-pressed", "true");
    }

    try {
      localStorage.removeItem("genreMode");
      localStorage.removeItem("genreOnlySelected");
    } catch (e) {}
  })();

  var clickFirst = function (id) {
    var opt = document.querySelector(
      "#" + id + " .options-container .option:first-child",
    );
    if (opt) opt.click();
  };
  clickFirst("sort-order");
  clickFirst("release-period-filter");
  clickFirst("duration-filter");
  clickFirst("track-count-filter");
  clickFirst("listen-count-filter");
  clickFirst("label-select");

  const nuam = document.getElementById("nuam-recommended-checkbox");
  if (nuam) nuam.checked = false;

  labelFilter = "";
  const selectedLabelDiv = document.querySelector("#label-select .selected");
  if (selectedLabelDiv) {
    selectedLabelDiv.textContent = " ";
    selectedLabelDiv.dataset.value = "";
  }

  var hide = document.getElementById("hide-listened");

  if (hide) hide.checked = true;

  window.applyDefaultFilters();
  isPresetLoading = false;
  applyDefaultFilters();
};

window.addEventListener("DOMContentLoaded", init);

(function () {
  if (window.__stats_inited__) return;
  window.__stats_inited__ = true;

  function normStr(x) {
    return (x ?? "").toString().trim();
  }
  function toNum(x) {
    const n = Number((x ?? "").toString().replace(/[^\d.]/g, ""));
    return Number.isFinite(n) ? n : 0;
  }

  function parseHHMMSS(s) {
    s = normStr(s);
    if (!s) return 0;
    const p = s.split(":").map(Number);
    if (p.length === 3) return p[0] * 3600 + p[1] * 60 + p[2];
    if (p.length === 2) return p[0] * 60 + p[1];
    return toNum(s);
  }

  function splitMulti(v) {
    return normStr(v)
      .split(/[;,|/]/)
      .map((x) => x.trim())
      .filter(Boolean);
  }

  function bucketListens(n) {
    if (n < 1000) return "01 000";
    if (n < 5000) return "1 0005 000";
    if (n < 10000) return "5 00010 000";
    if (n < 25000) return "10 00025 000";
    if (n < 50000) return "25 00050 000";
    if (n < 100000) return "50 000100 000";
    if (n < 250000) return "100 000250 000";
    if (n < 500000) return "250 000500 000";
    if (n < 1000000) return "500 0001 000 000";
    return "1 000 000+";
  }

  function bucketDuration(sec) {
    if (sec < 300) return "15 ";
    if (sec < 600) return "510 ";
    if (sec < 1200) return "1020 ";
    if (sec < 1800) return "2030 ";
    if (sec < 3600) return "3060 ";
    if (sec < 5400) return "6090 ";
    if (sec < 7200) return "90120 ";
    return "120+ ";
  }

  function bucketTracks(n) {
    if (n <= 3) return "13";
    if (n <= 4) return "34";
    if (n <= 6) return "46";
    if (n <= 9) return "69";
    if (n <= 12) return "912";
    return "12+";
  }

  function collectCounts(arr) {
    const map = new Map();
    for (const k of arr) {
      map.set(k, (map.get(k) || 0) + 1);
    }
    return map;
  }

  function sortMapDesc(map) {
    return [...map.entries()].sort((a, b) => b[1] - a[1]);
  }

  window.computeAlbumStats = function (albums) {
    const total = albums.length;

    const typesArr = [];
    const langsArr = [];
    const genresArr = [];
    const listensArr = [];
    const durArr = [];
    const tracksArr = [];

    for (const a of albums) {
      const type = (a.type ?? a.Type ?? "").toString().trim();
      if (type) typesArr.push(type);

      const langs =
        Array.isArray(a.languages) && a.languages.length ? a.languages : [];
      for (const L0 of langs) {
        const L = (L0 ?? "").toString().trim().toLowerCase();
        if (!L) continue;
        if (L.includes(" ") || L.includes("no voice")) {
          langsArr.push(" ");
        } else if (/(ukr||)/.test(L)) {
          langsArr.push("");
        } else if (/(eng||english)/.test(L)) {
          langsArr.push("");
        } else if (/(rus|||russian)/.test(L)) {
          langsArr.push("");
        } else {
          const mapped = mapName(L0);
          const out =
            String(mapped).trim().toLowerCase() === " "
              ? " "
              : String(mapped)
                  .trim()
                  .replace(/^./, (c) => c.toUpperCase());
          langsArr.push(out);
        }
      }

      if (Array.isArray(a.genres)) {
        for (const g of a.genres) {
          const gg = (g ?? "").toString().trim();
          if (gg) genresArr.push(mapName(gg));
        }
      }

      const listensVal = Number(a.listens ?? 0);
      listensArr.push(
        bucketListens(Number.isFinite(listensVal) ? listensVal : 0),
      );

      const durSec = parseHHMMSS(a.duration ?? "");
      durArr.push(bucketDuration(durSec));

      const trCount = Array.isArray(a.tracksIDs) ? a.tracksIDs.length : 0;
      if (trCount > 0) tracksArr.push(bucketTracks(trCount));
    }

    const types = sortMapDesc(collectCounts(typesArr));
    const langs = sortMapDesc(collectCounts(langsArr));
    const listens = sortMapDesc(collectCounts(listensArr));
    const dur = sortMapDesc(collectCounts(durArr));
    const tracks = sortMapDesc(collectCounts(tracksArr));

    const gMap = collectCounts(genresArr.map((x) => x || "()"));
    const gSorted = sortMapDesc(gMap);
    const top20 = gSorted.slice(0, 20);

    return {
      total,
      types,
      langs,
      genresAll: gSorted,
      genresTop: top20,
      listens,
      dur,
      tracks,
    };
  };

  function clearCanvas(cnv) {
    const ctx = cnv.getContext("2d");
    ctx.clearRect(0, 0, cnv.width, cnv.height);
  }
  function autoDPR(cnv) {
    const dpr = window.devicePixelRatio || 1;
    const rect = cnv.getBoundingClientRect();
    cnv.width = Math.round(rect.width * dpr);
    cnv.height = Math.round(rect.height * dpr);
    const ctx = cnv.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return ctx;
  }

  window.drawBar = function (cnv, data, opts = {}) {
    const ctx = autoDPR(cnv);
    const W = cnv.clientWidth,
      H = cnv.clientHeight;
    clearCanvas(cnv);
    if (W < 20 || H < 20 || !data || !data.length) return;

    const labels = data.map((d) => String(d[0]));
    const values = data.map((d) => Number(d[1]) || 0);
    const max = Math.max(1, ...values);

    ctx.font = "12px CustomFont,Arial";
    const longest = labels.reduce(
      (m, s) => Math.max(m, ctx.measureText(s).width),
      0,
    );
    const labelPad = 14;
    const labelW = Math.min(160, Math.max(80, Math.ceil(longest) + labelPad));

    const pad = 12,
      gap = 8,
      rightPad = 20;
    const innerH = H - pad * 2;
    const n = values.length || 1;
    const rowH = Math.min(32, Math.max(10, (innerH - (n - 1) * gap) / n));
    const availW = Math.max(2, W - (labelW + rightPad + 4));
    let y = pad;

    const total = values.reduce((s, x) => s + (+x || 0), 0);
    let accumTenths = 0;

    for (let i = 0; i < n; i++) {
      const v = values[i];
      const w = Math.max(2, availW * (v / max));

      ctx.fillStyle = "#f3f3f3";
      ctx.textBaseline = "middle";
      ctx.textAlign = "left";
      ctx.fillText(labels[i], 8, y + rowH / 2);

      ctx.fillStyle = "#4a9eff";
      ctx.fillRect(labelW, y, w, rowH);

      ctx.fillStyle = "#e9eef5";
      ctx.textBaseline = "middle";
      ctx.textAlign = "left";
      let pct = total > 0 ? (v * 100) / total : 0;
      let tenths = Math.round(pct * 10);

      if (i === n - 1) tenths = Math.max(0, 1000 - accumTenths);
      accumTenths += tenths;

      const text = `${v} (${(tenths / 10).toFixed(1)}%)`;
      const tw = ctx.measureText(text).width;
      const preferredX = labelW + w + 6;
      const clampedX = Math.min(preferredX, W - 6 - tw);
      ctx.fillText(text, clampedX, y + rowH / 2);
      y += rowH + gap;
    }
  };

  window.drawBar2Cols = function (cnv, leftData, rightData) {
    const ctx = autoDPR(cnv);
    const W = cnv.clientWidth,
      H = cnv.clientHeight;
    clearCanvas(cnv);

    const L = Array.isArray(leftData) ? leftData : [];
    const R = Array.isArray(rightData) ? rightData : [];

    if (W < 20 || H < 20 || (!L.length && !R.length)) return;

    const pad = 12,
      colGap = 24,
      rightPad = 20,
      rowGap = 8;
    const innerH = H - pad * 2;
    const colW = Math.max(40, (W - pad * 2 - colGap) / 2);

    ctx.font = "12px CustomFont,Arial";

    function measureLabelW(arr) {
      if (!arr.length) return 80;
      var max = 0;
      for (var i = 0; i < arr.length; i++) {
        var w = ctx.measureText(String(arr[i][0])).width;
        if (w > max) max = w;
      }
      var labelPad = 14;
      var res = Math.ceil(max) + labelPad;
      if (res < 80) res = 80;
      if (res > 160) res = 160;
      return res;
    }

    function drawPanel(x0, data) {
      if (!data.length) return;
      var n = data.length;
      var values = new Array(n);
      var max = 1;
      for (var i = 0; i < n; i++) {
        var v = Number(data[i][1]) || 0;
        values[i] = v;
        if (v > max) max = v;
      }
      var total = values.reduce(function (s, x) {
        return s + (+x || 0);
      }, 0);
      var accumTenths = 0;

      var labelW = measureLabelW(data);
      if (labelW > colW - 30) labelW = colW - 30;
      var availW = colW - (labelW + rightPad + 4);
      if (availW < 2) availW = 2;

      var rowH = (innerH - (n - 1) * rowGap) / n;
      if (rowH > 32) rowH = 32;
      if (rowH < 10) rowH = 10;

      var y = pad;
      for (var i = 0; i < n; i++) {
        var v = values[i];
        var w = availW * (v / max);
        if (w < 2) w = 2;

        ctx.fillStyle = "#f3f3f3";
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        ctx.fillText(String(data[i][0]), x0 + 8, y + rowH / 2);

        ctx.fillStyle = "#4a9eff";
        ctx.fillRect(x0 + labelW, y, w, rowH);

        ctx.fillStyle = "#e9eef5";
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        var pct = total > 0 ? (v * 100) / total : 0;
        var tenths = Math.round(pct * 10);

        if (i === n - 1) tenths = Math.max(0, 1000 - accumTenths);
        accumTenths += tenths;

        var text = String(v) + " (" + (tenths / 10).toFixed(1) + "%)";
        var tw = ctx.measureText(text).width;
        var preferredX = x0 + labelW + w + 6;
        var rightEdge = x0 + colW - 6;
        var clampedX = Math.min(preferredX, rightEdge - tw);
        ctx.fillText(text, clampedX, y + rowH / 2);
        y += rowH + rowGap;
      }
    }

    drawPanel(pad, L);
    drawPanel(pad + colW + colGap, R);
  };

  window.drawDonut = function (cnv, data) {
    const ctx = autoDPR(cnv);
    const W = cnv.clientWidth,
      H = cnv.clientHeight;
    clearCanvas(cnv);

    if (W < 20 || H < 20 || !data || !data.length) return;

    const cx = W / 2,
      cy = H / 2;
    const baseR = Math.min(W, H) / 2 - 10;
    const R = Math.max(1, baseR);
    const r = Math.max(0.5, R * 0.55);

    const sum = data.reduce((s, [_k, v]) => s + v, 0) || 1;

    let ang = -Math.PI / 2;
    for (let i = 0; i < data.length; i++) {
      const val = data[i][1];
      if (!val) continue;
      const a2 = ang + 2 * Math.PI * (val / sum);
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, R, ang, a2);
      ctx.closePath();
      ctx.fillStyle = `hsl(${(i * 47) % 360} 70% 55%)`;
      ctx.fill();

      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";

      ang = a2;
    }
  };

  window.createStatsModal = function () {
    if (document.getElementById("stats-modal")) return;

    const overlay = document.createElement("div");
    overlay.id = "stats-modal";
    overlay.className = "modal hidden";

    overlay.innerHTML = `
    <div class="modal-content">
      <span class="close" id="stats-close">&times;</span>
      <h3 class="stats-title"> 
  <span id="stats-mode-toggle" class="tri-toggle stats-mode-wrap" role="group" aria-label=" ">
    <button type="button" data-mode="all" class="active">ALL</button>
    <button type="button" data-mode="lp">LP</button>
    <button type="button" data-mode="ep">EP</button>
  </span>
</h3>

      <div class="stats-scroll">
        <div id="stats-body">

  <div class="stats-card area-total" id="stats-total-card">
    <h3>  </h3>
    <div class="stats-total" id="stats-total">0</div>
    <div id="stats-types-inline"></div>
  </div>

  <div class="stats-card area-langs">
    <h3></h3>
    <canvas class="stats-canvas" id="cnv-langs"></canvas>
  </div>

  <div class="stats-card area-listens">
    <h3></h3>
    <canvas class="stats-canvas" id="cnv-listens"></canvas>
  </div>

  <div class="stats-card area-genres">
    <h3></h3>
    <canvas class="stats-canvas" id="cnv-genres"></canvas>
  </div>

  <div class="stats-card area-tracks">
    <h3> </h3>
    <canvas class="stats-canvas" id="cnv-tracks"></canvas>
  </div>

  <div class="stats-card area-duration">
    <h3></h3>
    <canvas class="stats-canvas" id="cnv-duration"></canvas>
  </div>
  <div class="stats-card area-weekly">
  <h3>  </h3>
  <div id="weekly-scroll">
    <canvas id="weekly-canvas" class="stats-canvas"></canvas>
  </div>
</div>
</div>
      </div>
    </div>
  `;

    document.body.appendChild(overlay);

    document
      .getElementById("stats-close")
      .addEventListener("click", closeStatsModal);
    overlay.addEventListener("click", (e) => {
      if (e.target.id === "stats-modal") closeStatsModal();
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeStatsModal();
    });

    (function () {
      const wrap = document.getElementById("stats-mode-toggle");
      if (!wrap) return;
      const btns = wrap.querySelectorAll("button[data-mode]");
      btns.forEach((btn) => {
        btn.addEventListener("click", () => {
          const m = btn.getAttribute("data-mode");
          window.__stats_mode = m;
          btns.forEach((b) => b.classList.toggle("active", b === btn));
          const s =
            typeof window.__getStatsByMode === "function"
              ? window.__getStatsByMode()
              : window.__album_stats_all || window.__album_stats;
          if (s && typeof renderAlbumStats === "function") renderAlbumStats(s);
        });
      });
    })();
  };

  openStatsModal = function () {
    const el = document.getElementById("stats-modal");
    if (!el) return;
    el.classList.remove("hidden");

    requestAnimationFrame(() => {
      const s =
        typeof window.__getStatsByMode === "function"
          ? window.__getStatsByMode()
          : window.__album_stats_all || window.__album_stats;
      if (s) renderAlbumStats(s);
    });

    if (!window.__stats_resize_handler__) {
      window.__stats_resize_handler__ = () => {
        if (!el.classList.contains("hidden")) {
          const s =
            typeof window.__getStatsByMode === "function"
              ? window.__getStatsByMode()
              : window.__album_stats_all || window.__album_stats;
          if (s) renderAlbumStats(s);
        }
      };
      window.addEventListener("resize", window.__stats_resize_handler__);
    }
  };

  window.closeStatsModal = function () {
    const el = document.getElementById("stats-modal");
    if (!el) return;
    el.classList.add("hidden");
    if (window.__stats_resize_handler__) {
      window.removeEventListener("resize", window.__stats_resize_handler__);
      window.__stats_resize_handler__ = null;
    }
  };

  window.renderAlbumStats = function (stats) {
    const $ = (id) => document.getElementById(id);
    const withRounded = (el, fn) => {
      const ctx = el.getContext("2d");
      const orig = ctx.fillRect;
      ctx.fillRect = function (x, y, w, h) {
        this.fillStyle = "#6f84b4";

        const width = Math.abs(w),
          height = Math.abs(h);
        const left = w < 0 ? x - width : x;
        const top = h < 0 ? y - height : y;
        const r = Math.min(8, width / 2, height / 2);
        if (r > 0) {
          this.beginPath();
          const right = left + width,
            bottom = top + height;
          this.moveTo(left + r, top);
          this.arcTo(right, top, right, top + r, r);
          this.arcTo(right, bottom, right - r, bottom, r);
          this.arcTo(left, bottom, left, bottom - r, r);
          this.arcTo(left, top, left + r, top, r);
          this.closePath();
          this.fill();
        } else {
          orig.call(this, x, y, w, h);
        }
      };
      try {
        fn();
      } finally {
        ctx.fillRect = orig;
      }
    };

    const drawIf = (el, data) => {
      if (el && data && data.length) withRounded(el, () => drawBar(el, data));
    };

    function buildWeeklyReleaseData() {
      const DAY = 24 * 60 * 60 * 1000,
        WEEK = 7 * DAY;

      const mode = String(window.__stats_mode || "all").toLowerCase();
      const src =
        mode === "lp"
          ? window.__albums_lp_for_stats || []
          : mode === "ep"
            ? window.__albums_ep_for_stats || []
            : window.__albums_all_for_stats || [];

      if (!Array.isArray(src) || !src.length) return [];

      const dates = src.map((a) => new Date(a.date));
      const minDate = new Date(Math.min.apply(null, dates));
      const maxAlbumTime = Math.max.apply(
        null,
        dates.map((d) => +d),
      );

      const startIdx = 0;
      const lastIdx = Math.floor((maxAlbumTime - +minDate) / WEEK);
      let endIdx = lastIdx;

      const buckets = [];
      for (let i = startIdx; i <= endIdx; i++) {
        const ws = new Date(+minDate + i * WEEK);
        const label = ws.toLocaleDateString("uk-UA", {
          day: "2-digit",
          month: "2-digit",
          year: "2-digit",
        });
        buckets.push([label, 0]);
      }

      for (const a of src) {
        const d = new Date(a.date);
        const idx = Math.floor((d - minDate) / WEEK);
        if (idx < startIdx || idx > endIdx) continue;
        buckets[idx - startIdx][1] += 1;
      }
      return buckets;
    }

    function drawWeeklyColumns(cnv, data) {
      const bar = 22,
        gap = 8,
        pad = 12,
        bottom = 57,
        top = 24;
      const n = Math.max(1, data.length);
      const cssWidth = pad + n * (bar + gap) - gap + pad;
      cnv.style.width = cssWidth + "px";

      const ctx = autoDPR(cnv);
      clearCanvas(cnv);

      const W = cnv.clientWidth,
        H = cnv.clientHeight;
      if (W < 30 || H < 30 || !data || !data.length) return;

      const max = Math.max(1, ...data.map((d) => +d[1] || 0));
      const innerH = Math.max(2, H - top - bottom);

      ctx.font = "12px CustomFont,Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      for (let i = 0; i < data.length; i++) {
        const j = data.length - 1 - i;
        const [label, v0] = data[j];
        const v = +v0 || 0;
        const h = Math.max(2, innerH * (v / max));
        const x = pad + i * (bar + gap);
        const y = top + (innerH - h);

        ctx.fillStyle = "#6f84b4";
        ctx.fillRect(x, y, bar, h);

        ctx.fillStyle = "#a9b3c1";
        ctx.save();
        ctx.translate(x + bar / 2, H - 28);
        ctx.rotate(-Math.PI / 3);
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }

      ctx.fillStyle = "#e9eef5";
      for (let i = 0; i < data.length; i++) {
        const j = data.length - 1 - i;
        const v = +data[j][1] || 0;
        const h = Math.max(2, innerH * (v / max));
        const x = pad + i * (bar + gap);
        const y = top + (innerH - h) - 6;
        ctx.textAlign = "center";
        ctx.textBaseline = "alphabetic";
        ctx.fillText(String(v), x + bar / 2, y);
      }
    }

    const total = (stats && stats.total) != null ? stats.total : 0;
    const totalEl = $("stats-total");
    if (totalEl) totalEl.textContent = total;

    drawIf($("cnv-langs"), stats?.langs || []);
    drawIf($("cnv-listens"), stats?.listens || []);
    drawIf($("cnv-duration"), stats?.dur || []);
    drawIf($("cnv-tracks"), stats?.tracks || []);

    {
      const weekly = buildWeeklyReleaseData();
      const wcnv = document.getElementById("weekly-canvas");
      if (wcnv && weekly && weekly.length) {
        withRounded(wcnv, () => drawWeeklyColumns(wcnv, weekly));
      }
    }

    {
      const wwrap = document.getElementById("weekly-scroll");
      if (wwrap && !wwrap.dataset.wheelified) {
        wwrap.addEventListener(
          "wheel",
          (e) => {
            if (e.ctrlKey) return;
            const dx =
              Math.abs(e.deltaY) >= Math.abs(e.deltaX) ? e.deltaY : e.deltaX;
            wwrap.scrollLeft += dx * 1.5;
            e.preventDefault();
          },
          { passive: false },
        );
        wwrap.dataset.wheelified = "1";
      }
    }

    const typesBox = $("stats-types-inline");
    if (typesBox) {
      const __mode = String(window.__stats_mode || "all").toLowerCase();
      typesBox.innerHTML = "";
      typesBox.style.display = __mode === "all" ? "" : "none";

      if (__mode === "all") {
        const types = stats?.types || null;
        if (Array.isArray(types) && types.length) {
          const base = total || types.reduce((s, [, v]) => s + (+v || 0), 0);
          types
            .filter(([, v]) => +v > 0)
            .sort((a, b) => b[1] - a[1])
            .forEach(([name, val]) => {
              const p = base ? Math.round((+val * 100) / base) : 0;
              const div = document.createElement("div");
              div.className = "type-item";
              div.innerHTML = `<span class="type-name">${name}</span><span class="type-val">${val} <small>(${p}%)</small></span>`;
              typesBox.appendChild(div);
            });
        }
      }
    }

    {
      const cnv = document.getElementById("cnv-genres");
      if (cnv) {
        const all = Array.isArray(stats?.genresAll)
          ? stats.genresAll
          : stats?.genresTop || stats?.genres || [];
        const entries = all.filter(function (item) {
          var k = item[0],
            v = item[1];
          return k && String(k).toLowerCase() !== "" && +v > 0;
        });
        const left = [],
          right = [];
        for (var i = 0; i < entries.length; i++) {
          (i % 2 === 0 ? left : right).push(entries[i]);
        }
        withRounded(cnv, () => drawBar2Cols(cnv, left, right));
      }
    }
  };

  window.__stats_mode = window.__stats_mode || "all";
  window.__getStatsByMode = function () {
    const m = window.__stats_mode || "all";
    if (m === "lp")
      return (
        window.__album_stats_lp ||
        window.__album_stats_all ||
        window.__album_stats ||
        null
      );
    if (m === "ep")
      return (
        window.__album_stats_ep ||
        window.__album_stats_all ||
        window.__album_stats ||
        null
      );
    return window.__album_stats_all || window.__album_stats || null;
  };

  window.setupStats = function (albums) {
    const old = document.getElementById("open-stats-btn");
    if (old) old.remove();
    if (typeof createStatsModal === "function") createStatsModal();

    const arr = Array.isArray(albums) ? albums : [];
    const getType = (a) => String(a.type ?? a.Type ?? "").toLowerCase();
    const isLP = (a) => /\b(album|lp)\b/.test(getType(a));
    const isEP = (a) => /\bep\b/.test(getType(a));

    window.__album_stats_all = computeAlbumStats(arr);
    window.__album_stats_lp = computeAlbumStats(arr.filter(isLP));
    window.__album_stats_ep = computeAlbumStats(arr.filter(isEP));

    window.__albums_all_for_stats = arr.slice();
    window.__albums_lp_for_stats = arr.filter(isLP);
    window.__albums_ep_for_stats = arr.filter(isEP);

    window.__stats_mode = window.__stats_mode || "all";

    if (typeof fixPos === "function") {
      fixPos();
      requestAnimationFrame(fixPos);
      setTimeout(fixPos, 0);
    }
  };
})();

async function init() {
  try {
    await loadAllowedArtists();
  } catch (e) {
    console.warn(
      "        ",
    );
  }

  loadCsvWithRetry(
    newSheetUrl,
    {
      download: true,
      header: true,
      complete: function (results) {
        const rawData = results.data;
        processAlbumData(rawData);
        const loading = document.getElementById("loading-screen");
        if (loading) {
          loading.classList.add("hidden");
          loading.addEventListener("transitionend", () => loading.remove(), {
            once: true,
          });
        }
        populateFilters();
        populateLabelOptions();
        if (typeof window.readGenreModes !== "function") {
          const anyBtn = document.getElementById("mode-any");
          const allBtn = document.getElementById("mode-all");
          const onlyBtn = document.getElementById("mode-only");
          if (
            anyBtn &&
            !anyBtn.classList.contains("active") &&
            allBtn &&
            !allBtn.classList.contains("active")
          ) {
            anyBtn.classList.add("active");
            anyBtn.setAttribute("aria-pressed", "true");
          }
        }
        initBasicCustomSelect(document.getElementById("sort-order"));
        const pgOpt = document.querySelector(
          '#sort-order .option[data-value="popularity-growth"]',
        );
        if (pgOpt)
          attachTooltip(
            pgOpt,
            "   ,      ",
            "180px",
          );
        const sortSel = document
          .getElementById("sort-order")
          .querySelector(".selected");
        if (!sortSel.dataset.value) sortSel.dataset.value = "desc";
        initBasicCustomSelect(document.getElementById("duration-filter"));
        initBasicCustomSelect(document.getElementById("track-count-filter"));
        initBasicCustomSelect(document.getElementById("release-period-filter"));
        (function initReleasePeriodSlider() {
          const start = document.getElementById("release-period-start");
          const end = document.getElementById("release-period-end");
          const wrapper = document.getElementById("release-period-range");
          const dates = albumsData.map((a) => new Date(a.date));
          const minDate = new Date(Math.min(...dates));
          const now = new Date();
          const maxW = Math.ceil((now - minDate) / (7 * 24 * 60 * 60 * 1000));

          const weekOptions = [];
          for (let i = 0; i <= maxW; i++) {
            const d = new Date(minDate.getTime() + i * 7 * 24 * 60 * 60 * 1000);
            weekOptions.push(d.toISOString().slice(0, 10));
          }
          localStorage.setItem(
            "release-week-options",
            JSON.stringify(weekOptions),
          );

          [start, end].forEach((el) => {
            el.min = 0;
            el.max = maxW;
            el.step = 1;
          });
          start.value = 0;
          end.value = maxW;

          let debounce;
          function updateRange(skipApply = false) {
            const s = +start.value;
            const e = +end.value;

            const d1 = new Date(
              minDate.getTime() + s * 7 * 24 * 60 * 60 * 1000,
            );
            const d2 = new Date(
              minDate.getTime() + e * 7 * 24 * 60 * 60 * 1000,
            );
            const sd = d1.toISOString().slice(0, 10);
            const td = d2.toISOString().slice(0, 10);

            const sel = document.querySelector(
              "#release-period-filter .selected",
            );
            if (sel) {
              if (s === 0 && e === maxW) {
                sel.textContent = " - ";
                delete sel.dataset.value;
              } else {
                sel.textContent = `${sd}  ${td}`;
                sel.dataset.value = "range";
              }
            }

            wrapper.style.setProperty("--start", (s / maxW) * 100 + "%");
            wrapper.style.setProperty("--end", (e / maxW) * 100 + "%");

            clearTimeout(debounce);
            if (!skipApply) {
              debounce = setTimeout(() => {
                saveFiltersToCache();
                smoothApplyFilters();
              }, 500);
            }
          }

          start.addEventListener("input", () => {
            if (+start.value > +end.value) start.value = end.value;
            updateRange(false);
          });

          end.addEventListener("input", () => {
            if (+end.value < +start.value) end.value = start.value;
            updateRange(false);
          });

          updateRange(true);
          window.updateReleaseRangeTip = updateRange;
        })();

        (function initDurationSlider() {
          const start = document.getElementById("duration-start");
          const end = document.getElementById("duration-end");
          const wrapper = document.getElementById("duration-range");
          const mins = albumsData.map((a) => {
            const [h, m] = (a.duration || "00:00:00").split(":").map((x) => +x);
            return h * 60 + m;
          });
          const minV = Math.min(...mins),
            maxV = Math.max(...mins);
          [start, end].forEach((el) => {
            el.min = minV;
            el.max = maxV;
            el.step = 1;
          });
          start.value = minV;
          end.value = maxV;
          let debounce;
          function upd(skipApply = false) {
            const s = +start.value,
              e = +end.value;
            const sel = document.querySelector("#duration-filter .selected");
            if (s === minV && e === maxV) {
              sel.textContent = "- ";
              sel.removeAttribute("data-value");
            } else if (s === minV) {
              sel.textContent = ` ${e} `;
              sel.dataset.value = `${minV}-${e}`;
            } else if (e === maxV) {
              sel.textContent = ` ${s} `;
              sel.dataset.value = `${s}-${maxV}`;
            } else {
              sel.textContent = `${s}${e} `;
              sel.dataset.value = "range";
            }

            wrapper.style.setProperty(
              "--start",
              ((s - minV) / (maxV - minV)) * 100 + "%",
            );
            wrapper.style.setProperty(
              "--end",
              ((e - minV) / (maxV - minV)) * 100 + "%",
            );
            clearTimeout(debounce);
            if (!skipApply) {
              debounce = setTimeout(() => {
                saveFiltersToCache();
                smoothApplyFilters();
              }, 300);
            }
          }
          start.addEventListener("input", () => {
            if (+start.value > +end.value) start.value = end.value;
            upd(false);
          });
          end.addEventListener("input", () => {
            if (+end.value < +start.value) end.value = start.value;
            upd(false);
          });
          upd(true);
        })();

        (function initTrackCountSlider() {
          const start = document.getElementById("track-count-start");
          const end = document.getElementById("track-count-end");
          const wrapper = document.getElementById("track-count-range");
          const cnts = albumsData.map((a) => a.tracksIDs.length);
          const minV = Math.min(...cnts),
            maxV = Math.max(...cnts);
          [start, end].forEach((el) => {
            el.min = minV;
            el.max = maxV;
            el.step = 1;
          });
          start.value = minV;
          end.value = maxV;
          let debounce;
          function upd(skipApply = false) {
            const s = +start.value,
              e = +end.value;
            const sel = document.querySelector("#track-count-filter .selected");
            if (s === minV && e === maxV) {
              sel.textContent = "- ";
              sel.removeAttribute("data-value");
            } else if (s === minV) {
              sel.textContent = ` ${e} `;
              sel.dataset.value = `${minV}-${e}`;
            } else if (e === maxV) {
              sel.textContent = ` ${s} `;
              sel.dataset.value = `${s}-${maxV}`;
            } else {
              sel.textContent = `${s}${e} `;
              sel.dataset.value = "range";
            }

            wrapper.style.setProperty(
              "--start",
              ((s - minV) / (maxV - minV)) * 100 + "%",
            );
            wrapper.style.setProperty(
              "--end",
              ((e - minV) / (maxV - minV)) * 100 + "%",
            );
            clearTimeout(debounce);
            if (!skipApply) {
              debounce = setTimeout(() => {
                saveFiltersToCache();
                smoothApplyFilters();
              }, 300);
            }
          }
          start.addEventListener("input", () => {
            if (+start.value > +end.value) start.value = end.value;
            upd(false);
          });
          end.addEventListener("input", () => {
            if (+end.value < +start.value) end.value = start.value;
            upd(false);
          });
          upd(true);
        })();

        (function initListenCountSlider() {
          const start = document.getElementById("listen-count-start");
          const end = document.getElementById("listen-count-end");
          const wrapper = document.getElementById("listen-count-range");

          const allListens = albumsData.map((a) => a.listens || 0);
          const posListens = allListens
            .filter((x) => x > 0)
            .sort((a, b) => a - b);
          if (posListens.length === 0) {
            posListens.push(1000);
          }

          const BINS = 100;
          const N = posListens.length;
          const steps = [0];
          for (let i = 1; i <= BINS; i++) {
            const idx = Math.floor(((i - 1) * (N - 1)) / (BINS - 1));
            steps.push(posListens[idx]);
          }

          [start, end].forEach((el) => {
            el.min = 0;
            el.max = steps.length - 1;
            el.step = 1;
          });
          start.value = 0;
          end.value = steps.length - 1;

          let debounce;

          function update(skipApply = false) {
            let i = +start.value;
            let j = +end.value;
            if (i > j) {
              i = j;
              start.value = i;
            }
            if (j < i) {
              j = i;
              end.value = j;
            }

            const sVal = steps[i];
            const eVal = steps[j];
            const sel = document.querySelector(
              "#listen-count-filter .selected",
            );

            if (i === 0 && j === steps.length - 1) {
              sel.textContent = "- ";
              sel.removeAttribute("data-value");
            } else if (i === 0) {
              sel.textContent = ` ${formatListens(eVal)}`;
              sel.dataset.value = `0-${eVal}`;
            } else if (j === steps.length - 1) {
              sel.textContent = ` ${formatListens(sVal)}`;
              sel.dataset.value = `${sVal}-`;
            } else {
              sel.textContent = `${formatListens(sVal)}${formatListens(eVal)}`;
              sel.dataset.value = `${sVal}-${eVal}`;
            }

            const L = steps.length - 1;
            wrapper.style.setProperty("--start", (i / L) * 100 + "%");
            wrapper.style.setProperty("--end", (j / L) * 100 + "%");

            clearTimeout(debounce);
            if (!skipApply) {
              debounce = setTimeout(() => {
                saveFiltersToCache();
                smoothApplyFilters();
              }, 200);
            }
          }

          start.addEventListener("input", () => update(false));
          end.addEventListener("input", () => update(false));

          update(true);
        })();
        initBasicCustomSelect(document.getElementById("listen-count-filter"));
        attachGlobalEventListeners();

        const toggleEditBtn = document.getElementById("toggle-edit-presets");
        attachTooltip(toggleEditBtn, "  ", "180px");
        const addPresetBtn = document.getElementById("add-preset");
        attachTooltip(addPresetBtn, " ", "160px");
        ensureDefaultPresets();
        loadPresetsFromStorage();

        const addBtn = document.getElementById("add-preset");
        const modal = document.getElementById("preset-modal");
        const closeX = document.getElementById("preset-close");
        const saveBtn = document.getElementById("preset-save");
        const inputName = document.getElementById("preset-name-input");
        const inputDesc = document.getElementById("preset-desc-input");

        const restoreBtn = document.getElementById("preset-restore");
        if (restoreBtn && !restoreBtn.dataset.bound) {
          restoreBtn.addEventListener("click", restoreDefaultsAndNotify);

          restoreBtn.addEventListener("mouseenter", (e) => {
            if (restoreBtn.style.display === "none") return;
            const hasUser = (function () {
              const STD = new Set([
                "",
                " ",
                " ",
                " ",
              ]);
              return getStoredPresets().some((p) => !STD.has(p.name));
            })();
            if (!hasUser) return;
            if (typeof removeTooltip === "function") removeTooltip(restoreBtn);
            if (typeof attachTooltip === "function")
              attachTooltip(restoreBtn, "   ");
            if (typeof moveSimpleTooltip === "function")
              moveSimpleTooltip(e.clientX, e.clientY);
          });

          restoreBtn.addEventListener("mousemove", (e) => {
            if (restoreBtn.style.display === "none") return;
            const hasUser = (function () {
              const STD = new Set([
                "",
                " ",
                " ",
                " ",
              ]);
              return getStoredPresets().some((p) => !STD.has(p.name));
            })();
            if (!hasUser) return;
            if (typeof moveSimpleTooltip === "function")
              moveSimpleTooltip(e.clientX, e.clientY);
          });

          restoreBtn.addEventListener("mouseleave", () => {
            if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
            if (typeof removeTooltip === "function") removeTooltip(restoreBtn);
          });

          restoreBtn.dataset.bound = "1";
        }

        addBtn.addEventListener("click", () => {
          inputName.value = "";
          modal.style.display = "block";
          document.body.style.overflow = "hidden";
          inputName.focus();
          if (inputDesc) inputDesc.value = "";

          updateRestorePresetUI();

          const oldBtn = document.getElementById("preset-restore");
          if (oldBtn) {
            const newBtn = oldBtn.cloneNode(true);
            oldBtn.parentNode.replaceChild(newBtn, oldBtn);

            newBtn.addEventListener("click", restoreDefaultsAndNotify);

            newBtn.addEventListener("mouseenter", (e) => {
              if (newBtn.style.display === "none") return;
              if (newBtn.dataset.missingDefaults !== "1") return;
              if (newBtn.dataset.hasUser !== "1") return;
              if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
              if (typeof showSimpleTooltip === "function") {
                showSimpleTooltip(
                  e.clientX,
                  e.clientY,
                  "   ",
                );
              } else if (typeof attachTooltip === "function") {
                attachTooltip(newBtn, "   ");
              }
            });

            newBtn.addEventListener("mousemove", (e) => {
              if (newBtn.style.display === "none") return;
              if (newBtn.dataset.missingDefaults !== "1") return;
              if (newBtn.dataset.hasUser !== "1") return;
              if (typeof moveSimpleTooltip === "function")
                moveSimpleTooltip(e.clientX, e.clientY);
            });

            newBtn.addEventListener("mouseleave", () => {
              if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
              if (typeof removeTooltip === "function") removeTooltip(newBtn);
            });
          }
        });

        closeX.addEventListener("click", () => {
          modal.style.display = "none";
          document.body.style.overflow = "auto";
        });

        modal.addEventListener("click", (e) => {
          if (e.target === modal) {
            modal.style.display = "none";
            document.body.style.overflow = "auto";
          }
        });

        const editNameModal = document.getElementById("edit-name-modal");
        const editNameClose = editNameModal.querySelector(".close");

        editNameClose.addEventListener("click", () => {
          editNameModal.style.display = "none";
          document.body.style.overflow = "auto";
        });

        editNameModal.addEventListener("click", (e) => {
          if (e.target === editNameModal) {
            editNameModal.style.display = "none";
            document.body.style.overflow = "auto";
          }
        });

        const saveMsg = document.getElementById("preset-save-message");
        saveBtn.addEventListener("click", () => {
          const name = inputName.value.trim();
          if (!name) {
            saveMsg.textContent = "  ";
            saveMsg.className = "error";
            setTimeout(() => {
              saveMsg.textContent = "";
              saveMsg.className = "";
            }, 2000);
            return;
          }
          saveMsg.textContent = "";
          saveMsg.className = "";

          saveFiltersToCache();
          const arr = getStoredPresets();
          const cf = JSON.parse(localStorage.getItem("albumFilters") || "{}");
          const desc = (inputDesc?.value || "").trim().slice(0, 250);
          const presetObj = { name, filters: cf, ...(desc ? { desc } : {}) };
          const idx = arr.findIndex((p) => p.name === name);
          if (idx >= 0) arr[idx] = presetObj;
          else arr.push(presetObj);

          savePresetsToStorage(arr);
          loadPresetsFromStorage();
          updateRestorePresetUI();
          modal.style.display = "none";
        });

        const wrap = document.querySelector(".presets-wrapper");
        const fc = document.getElementById("filters-container");
        const filtersButton = document.getElementById("filters-button");

        function updateFade() {
          const overflow = wrap.scrollWidth > wrap.clientWidth;
          const atLeft = wrap.scrollLeft > 0;
          const atRight = wrap.scrollLeft + wrap.clientWidth < wrap.scrollWidth;
          fc.classList.toggle("scrolled", atLeft);
          fc.classList.toggle("scrolled-right", overflow && atRight);
        }

        wrap.addEventListener("scroll", updateFade);
wrap.addEventListener(
  "wheel",
  (e) => {
    const el = wrap;

    if (el.scrollWidth <= el.clientWidth) return;

    const dx = e.deltaX || 0;
    const dy = e.deltaY || 0;
    const delta = Math.abs(dy) >= Math.abs(dx) ? dy : dx;
    if (!delta) return;

    const before = el.scrollLeft;
    el.scrollLeft += delta;

    if (el.scrollLeft !== before) e.preventDefault();

    requestAnimationFrame(updateFade);
  },
  { passive: false }
);

        filtersButton.addEventListener("click", () => {
          requestAnimationFrame(updateFade);
        });

        requestAnimationFrame(updateFade);
        window.addEventListener("resize", updateFade);
        setupStats(albumsData);

        const albumFilters =
          JSON.parse(localStorage.getItem("albumFilters")) || null;
        if (albumFilters) {
          loadFiltersAfterRender();
        } else {
          window.applyDefaultFilters();
        }
      },
      error: function (error) {
        console.error("    CSV:", error);
      },
    },
    3,
    1000,
    fallbackSheetUrl,
  );
}

function initBasicCustomSelect(select) {
  const selected = select.querySelector(".selected");
  const optionsContainer = select.querySelector(".options-container");

  selected.addEventListener("click", (e) => {
    e.stopPropagation();
    document.querySelectorAll(".custom-select").forEach((otherSelect) => {
      if (otherSelect !== select) {
        otherSelect.querySelector(".options-container").style.display = "none";
        otherSelect.classList.remove("open");
      }
    });

    (function(){
      const ls = document.querySelector('#label-select .option-search');
      const lc = document.querySelector('#label-select .options-container');
      if (ls && lc && lc.style.display !== "flex") {
        if (ls.value) { ls.value = ""; ls.dispatchEvent(new Event("input", { bubbles: true })); }
      }
    })();

    const isOpen = optionsContainer.style.display === "flex";
    if (!isOpen) {
      const r = select.getBoundingClientRect();
      optionsContainer.style.display = "flex";
      const h = optionsContainer.scrollHeight;
      optionsContainer.style.display = "none";
      if (r.bottom + h > window.innerHeight) select.classList.add("upward");
      else select.classList.remove("upward");
    }
    optionsContainer.style.display = isOpen ? "none" : "flex";
    select.classList.toggle("open", !isOpen);
  });

  optionsContainer.querySelectorAll(".option").forEach((option) => {
    option.addEventListener("click", () => {
      selected.textContent = option.textContent;
      selected.dataset.value = option.dataset.value;
      optionsContainer.style.display = "none";
      select.classList.remove("open");

      if (select.id === "release-period-filter") {
        const start = document.getElementById("release-period-start");
        const end = document.getElementById("release-period-end");
        const wrapper = document.getElementById("release-period-range");
        start.value = start.min;
        end.value = end.max;
        wrapper.style.setProperty("--start", "0%");
        wrapper.style.setProperty("--end", "100%");
      }
      if (select.id === "duration-filter") {
        document.getElementById("duration-start").value =
          document.getElementById("duration-start").min;
        document.getElementById("duration-end").value =
          document.getElementById("duration-end").max;
        document.getElementById("duration-range").style.setProperty("--start", "0%");
        document.getElementById("duration-range").style.setProperty("--end", "100%");
      }
      if (select.id === "track-count-filter") {
        document.getElementById("track-count-start").value =
          document.getElementById("track-count-start").min;
        document.getElementById("track-count-end").value =
          document.getElementById("track-count-end").max;
        document.getElementById("track-count-range").style.setProperty("--start", "0%");
        document.getElementById("track-count-range").style.setProperty("--end", "100%");
      }
      if (select.id === "listen-count-filter") {
        document.getElementById("listen-count-start").value =
          document.getElementById("listen-count-start").min;
        document.getElementById("listen-count-end").value =
          document.getElementById("listen-count-end").max;
        document.getElementById("listen-count-range").style.setProperty("--start", "0%");
        document.getElementById("listen-count-range").style.setProperty("--end", "100%");
      }

      if (select.id === "sort-order") sortOrder = option.dataset.value;

      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });
  });

  document.addEventListener("click", (e) => {
    if (!select.contains(e.target)) {
      optionsContainer.style.display = "none";
      select.classList.remove("open");

      if (select.id === "label-select") {
        const ls = select.querySelector(".option-search");
        if (ls && ls.value) { ls.value = ""; ls.dispatchEvent(new Event("input", { bubbles: true })); }
      }
    }
  });
}

function friendlyGenreLabel(g) {
  if (g === "producing work for international") return "intl prod";
  if (g === "ai") return "AI";
  if (g === "instrumental rock") return "alt. instrumental";
  if (g === "like old trash") return "estrade";
  return g;
}

function formatListens(num) {
  if (num >= 10000) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
  }
  return num;
}

function processAlbumData(rawData) {
  albumsData.length = 0;

  const seenAlbumIDs = new Set();

  rawData.forEach((item) => {
    if (!item.alName || !item.Type) return;
    if (item.excluded && item.excluded.trim() === "+") return;

    const type = item.Type.toLowerCase();

    const artistIDs = item.artID
      ? item.artID
          .split(",")
          .map((id) => id.trim())
          .filter((id) => id)
      : [];

    if (
      allowedArtistIds.size > 0 &&
      type !== "compilation" &&
      !artistIDs.some((id) => allowedArtistIds.has(id))
    ) {
      return;
    }

    const albumID = item.alURL;

    if (seenAlbumIDs.has(albumID)) return;
    seenAlbumIDs.add(albumID);

    const album = {
      nameAlbum: item.alName,
      albumID,
      date: item.Date,
      type,
      cover: item.Cover,
      genres: (() => {
        let base = item.Genres
          ? item.Genres.split(", ")
              .map((g) => g.trim())
              .filter((g) => g)
          : [];
        let extra = item.addGenre
          ? item.addGenre
              .split(",")
              .map((g) => g.trim())
              .filter((g) => g)
          : [];

        extra.forEach((g) => {
          if (g.startsWith("-")) {
            base = base.filter((bg) => bg !== g.slice(1).trim());
          }
        });
        extra.forEach((g) => {
          if (!g.startsWith("-") && !base.includes(g)) {
            base.push(g);
          }
        });
        if (base.includes("like old trash") && base.includes("pop/indie")) {
          base = base.filter((g) => g !== "pop/indie");
        }
        return base;
      })(),
      languages: (() => {
        let base = item.Lang
          ? item.Lang.split(", ")
              .map((l) => {
                const t =
                  l.trim().toLowerCase() === "no voice"
                    ? " "
                    : l.trim();
                return t;
              })
              .filter((l) => l)
          : [];
        let extra = item.addLang
          ? item.addLang
              .split(",")
              .map((l) => {
                const t =
                  l.trim().toLowerCase() === "no voice"
                    ? " "
                    : l.trim();
                return t;
              })
              .filter((l) => l)
          : [];

        extra.forEach((l) => {
          if (l.startsWith("-")) {
            base = base.filter((bl) => bl !== l.slice(1).trim());
          }
        });
        extra.forEach((l) => {
          if (!l.startsWith("-") && !base.includes(l)) {
            base.push(l);
          }
        });
        return base;
      })(),
      listens: parseInt(item.Listens, 10) || 0,
      label: item.Label || "",
      duration: item.Duration || "",
      tracksIDs: item.Tracks
        ? item.Tracks.split(",")
            .map((t) => t.trim())
            .filter((t) => t)
        : [],
      tracksMP3: item.MP3
        ? item.MP3.split(",")
            .map((m) => m.trim())
            .filter((m) => m)
        : [],
      good: item.Good && item.Good.trim() === "+",
      artistNames: item.artName
        ? item.artName
            .split(",,")
            .map((a) => a.trim())
            .filter((a) => a)
        : [],
      artistIDs,
      listened: !!listenedAlbums[item.alURL],
      growthScore: -Infinity,
    };

    if (item.Listens) {
      const history = item.Listens.split(",")
        .map((x) => parseInt(x.trim(), 10))
        .filter((n) => !isNaN(n));
      if (history.length >= 2) {
        const recent = history.slice(0, 8);
        const deltas = [];
        for (let i = 0; i < recent.length - 1; i++) {
          deltas.push(recent[i] - recent[i + 1]);
        }
        album.growthScore = deltas.reduce((a, b) => a + b, 0) / deltas.length;
      }
    }

    album.popularity = ((p) => (Number.isFinite(p) ? p : -Infinity))(
      parseInt(item.Popularity, 10),
    );
    albumsData.push(album);
  });
}

function populateFilters() {
  const genreContainer = document.getElementById("genre-checkboxes");
  const languageContainer = document.getElementById("language-checkboxes");
  const releaseTypeContainer = document.getElementById(
    "release-type-checkboxes",
  );

  const genresCountMap = new Map();
  const languagesCountMap = new Map();
  const releaseTypesSet = new Set();

  albumsData.forEach((album) => {
    album.genres.forEach((genre) => {
      genresCountMap.set(genre, (genresCountMap.get(genre) || 0) + 1);
    });
    if (album.languages.length === 0) {
      languagesCountMap.set(
        " ",
        (languagesCountMap.get(" ") || 0) + 1,
      );
    } else {
      album.languages.forEach((lang) => {
        const mappedLang =
          lang.trim().toLowerCase() === "no voice" ? " " : lang;
        languagesCountMap.set(
          mappedLang,
          (languagesCountMap.get(mappedLang) || 0) + 1,
        );
      });
    }
    releaseTypesSet.add(album.type);
  });

  const desiredGenreOrder = [
    "pop/indie",
    "rock",
    "hip-hop",
    "electronic",
    "metal",
    "post-punk",
    "trap",
    "phonk",
    "folk",
    "jazz",
    "worship",
    "instrumental",
    "instrumental rock",
    "piano",
    "synthwave",
    "cinematic",
    "hyperpop",
    "vocal guitar",
    "vocal piano",
    "cover",
    "remix",
    "live",
    "phonk beats",
    "beats rap",
    "beats lo-fi",
    "chillout",
    "drone",
    "exp. electronic",
    "exp. instrumental",
    "like old trash",
    "opera",
    "a cappella",
    "background",
    "jersey club",
    "ai",
    "producing work for international",
    "christmas",
  ];

  const sortedGenres = [
    ...desiredGenreOrder
      .filter((genre) => genresCountMap.has(genre))
      .map((genre) => [genre, genresCountMap.get(genre)]),
    ...[...genresCountMap.entries()]
      .filter(([genre]) => !desiredGenreOrder.includes(genre))
      .sort((a, b) => a[0].localeCompare(b[0])),
  ];

  genreContainer.innerHTML = "";
  const genreFrag = document.createDocumentFragment();
  sortedGenres.forEach(([genre, count]) => {
    const div = document.createElement("div");
    div.classList.add("genre-filter-item");

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.value = genre;
    checkbox.id = `genre-${encodeURIComponent(genre)}`;
    checkbox.classList.add("genre-checkbox");

    const label = document.createElement("label");
    label.htmlFor = checkbox.id;

    const genreName = document.createElement("span");
    genreName.classList.add("genre-name");
    genreName.textContent = friendlyGenreLabel(genre);

    if (genre === "producing work for international") {
      attachTooltip(
        genreName,
        "     ",
        "180px",
      );
    }

    const genreCount = document.createElement("span");
    genreCount.classList.add("genre-count");
    genreCount.textContent = ` (${count})`;

    const genreCross = document.createElement("span");
    genreCross.textContent = "";
    genreCross.classList.add("exclude-genre");
    genreCross.style.cursor = "pointer";
    genreCross.setAttribute("data-genre", genre);

    label.appendChild(genreName);
    label.appendChild(genreCount);

    div.appendChild(checkbox);
    div.appendChild(label);
    div.appendChild(genreCross);
    genreFrag.appendChild(div);
  });

  genreContainer.appendChild(genreFrag);

  const defaultLangOrder = ["ukr", "eng", "rus", "other lang", " "];
  languageContainer.innerHTML = "";
  const languageFrag = document.createDocumentFragment();
  defaultLangOrder.forEach((langKey) => {
    const count = languagesCountMap.get(langKey) || 0;
    if (count > 0 || langKey === " ") {
      const div = document.createElement("div");
      div.classList.add("language-filter-item");

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = langKey;
      checkbox.id = `language-${encodeURIComponent(langKey)}`;
      checkbox.classList.add("language-checkbox");

      const label = document.createElement("label");
      label.htmlFor = checkbox.id;

      const languageName = document.createElement("span");
      languageName.classList.add("language-name");
      languageName.textContent = languageLabels[langKey] || langKey;

      const languageCount = document.createElement("span");
      languageCount.classList.add("language-count");
      languageCount.textContent = ` (${count})`;

      const languageCross = document.createElement("span");
      languageCross.textContent = "";
      languageCross.classList.add("exclude-language");
      languageCross.style.cursor = "pointer";
      languageCross.setAttribute("data-language", langKey);

      label.appendChild(languageName);
      label.appendChild(languageCount);

      div.appendChild(checkbox);
      div.appendChild(label);
      div.appendChild(languageCross);
      languageFrag.appendChild(div);
    }
  });

  languageContainer.appendChild(languageFrag);

  releaseTypeContainer.innerHTML = "";
  const releaseTypeLabels = {
    album: "LP",
    ep: "EP",
    compilation: "",
  };
  const releaseTypeCounts = {};
  albumsData.forEach((album) => {
    releaseTypeCounts[album.type] = (releaseTypeCounts[album.type] || 0) + 1;
  });

  releaseTypesSet.forEach((rType) => {
    const div = document.createElement("div");
    div.classList.add("release-type-filter-item");

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.value = rType;
    checkbox.id = `release-type-${rType}`;
    checkbox.classList.add("release-type-checkbox");

    const label = document.createElement("label");
    label.htmlFor = checkbox.id;
    label.innerHTML = `${releaseTypeLabels[rType] || rType} <span class="genre-count">(${releaseTypeCounts[rType] || 0})</span>`;

    div.appendChild(checkbox);
    div.appendChild(label);
    releaseTypeContainer.appendChild(div);
  });
}

function populateLabelOptions() {

  const map = new Map();

  albumsData.forEach((al) => {
    if (!al.label || al.artistNames.length === 0) return;
    const artist = al.artistNames[0];
    const canon  = canonLabel(al.label);
    if (artist === al.label || artist === canon) return;

    if (!map.has(canon)) {
      map.set(canon, { artists: new Set(), releases: 0, listens: 0 });
    }

    const st = map.get(canon);
    st.artists.add(artist);
    st.releases += 1;

    const ls = parseInt(al.listens, 10) || 0;
    st.listens += ls;
  });

  const FORCE_INCLUDE = new Set(["VG STAR"]);

  const labels = Array.from(map.entries())
    .filter(([canon, st]) => st.artists.size >= 3 || (FORCE_INCLUDE.has(canon) && st.artists.size > 0))
    .map(([canon, st]) => ({
      name: canon,
      releases: st.releases,
      artists: st.artists.size,
      listens: st.listens
        }))
    .sort((a, b) => (b.listens - a.listens) || a.name.localeCompare(b.name, "uk"));

  const select = document.getElementById("label-select");
  const optsContainer = select.querySelector(".options-container");
  optsContainer.innerHTML = `
  <div class="option-fixed">
    <div class="option option-all-labels" data-value=""> </div>
    <input type="text" class="option-search" placeholder=" ">
  </div>
  <div class="option-list"></div>
`;

  const listContainer = optsContainer.querySelector(".option-list");
  labels.forEach((lbl) => {
    const o = document.createElement("div");
    o.className = "option";
    o.dataset.value    = lbl.name;
    o.dataset.releases = String(lbl.releases);
    o.dataset.artists  = String(lbl.artists);
    o.dataset.listens  = String(lbl.listens);
    o.textContent  = lbl.name;
    listContainer.appendChild(o);
  });

  initCustomSelect(select);
}

function initCustomSelect(select) {
  const selected = select.querySelector(".selected");
  const optionsContainer = select.querySelector(".options-container");
  const listContainer = optionsContainer.querySelector(".option-list");
  const fixedContainer = optionsContainer.querySelector(".option-fixed");
  const searchInput = fixedContainer.querySelector(".option-search");

  const clearLabelSearch = () => {
    if (select.id === 'label-select' && searchInput && searchInput.value) {
      searchInput.value = '';
      searchInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
  };

    let labelSortMode = 'listens';
let sortbar;
if (select.id === 'label-select') {
  sortbar = document.createElement('div');
  sortbar.className = 'label-sortbar';
  sortbar.innerHTML = `
    <span class="label-sortbar-title"> :</span>

        <button type="button" data-mode="name" aria-label=" ">
      <i class="fas fa-solid fa-sort-alpha-down fa-fw"></i>
    </button>

    <button type="button" data-mode="releases" aria-label="  ">
      <i class="fas fa-solid fa-layer-group fa-fw"></i>
    </button>

    <button type="button" data-mode="artists" aria-label="  ">
      <i class="fas fa-solid fa-users fa-fw"></i>
    </button>

    <button type="button" data-mode="listens" class="active" aria-label="  ">
      <i class="fas fa-solid fa-headphones fa-fw"></i>
    </button>
  `;
  fixedContainer.insertBefore(sortbar, fixedContainer.firstChild);

  try {
    const buttons = sortbar.querySelectorAll('button[data-mode]');
    buttons.forEach((btn) => {
      btn.removeAttribute('title');
      const text = btn.getAttribute('aria-label') || '';

      attachTooltip(btn, text);
    });
  } catch (_) {}
  
    sortbar.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const mode = btn.getAttribute('data-mode');
      if (!mode) return;
      labelSortMode = mode;
      sortbar.querySelectorAll('button').forEach(b => b.classList.toggle('active', b === btn));
      applySortAndFilter();
    });
  }

  let noResults = listContainer.querySelector('.no-results');
  if (!noResults) {
    noResults = document.createElement('div');
    noResults.className = 'no-results';
    noResults.textContent = '   ';
    listContainer.appendChild(noResults);
  }

  const clearBtn = document.createElement('button');
  clearBtn.type = 'button';
  clearBtn.className = 'option-clear';
  clearBtn.setAttribute('aria-label','');
  clearBtn.textContent = '';
  fixedContainer.appendChild(clearBtn);

  const toggleClear = () => { clearBtn.classList.toggle('visible', !!searchInput.value); };
  toggleClear();
  searchInput.addEventListener('input', toggleClear);

  function placeClear(){
    const ip = searchInput;
    const p  = fixedContainer;
    const h  = 16;
    const ipTop = ip.offsetTop;
    const ipH   = ip.offsetHeight || 32;
    clearBtn.style.top = (ipTop + (ipH - h)/2) + 'px';
  }
  placeClear();

  try { new ResizeObserver(placeClear).observe(searchInput); } catch(e){}
  window.addEventListener('resize', placeClear, { passive: true });
  fixedContainer.addEventListener('transitionend', placeClear, true);

  clearBtn.addEventListener('mousedown', e => e.preventDefault());
  clearBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    searchInput.value = '';
    searchInput.dispatchEvent(new Event('input', { bubbles: true }));
    searchInput.focus();
    placeClear();
    applySortAndFilter();
  });

  function applySortAndFilter() {
    if (select.id !== 'label-select') return;

    const q = (searchInput?.value || '').trim().toLowerCase();
    const items = Array.from(listContainer.querySelectorAll('.option'));

    let visible = items.filter(opt => opt.textContent.toLowerCase().includes(q));

    if (labelSortMode === 'name') {
      visible.sort((a,b) => a.textContent.localeCompare(b.textContent, 'uk'));
    } else if (labelSortMode === 'releases') {
      visible.sort((a,b) => (parseInt(b.dataset.releases,10)||0) - (parseInt(a.dataset.releases,10)||0)
                     || a.textContent.localeCompare(b.textContent,'uk'));
    } else if (labelSortMode === 'artists') {
      visible.sort((a,b) => (parseInt(b.dataset.artists,10)||0) - (parseInt(a.dataset.artists,10)||0)
                     || a.textContent.localeCompare(b.textContent,'uk'));
    } else if (labelSortMode === 'listens') {
      visible.sort((a,b) => (parseInt(b.dataset.listens,10)||0) - (parseInt(a.dataset.listens,10)||0)
                     || a.textContent.localeCompare(b.textContent,'uk'));
    }

    items.forEach(el => el.style.display = 'none');
    visible.forEach(el => { el.style.display = ''; listContainer.appendChild(el); });

    noResults.style.display = visible.length ? 'none' : 'flex';
  }

  selected.addEventListener("click", (e) => {
    e.stopPropagation();

    document.querySelectorAll(".custom-select").forEach((otherSelect) => {
      if (otherSelect !== select) {
        const oc = otherSelect.querySelector(".options-container");
        if (oc && oc.style.display === "flex") {
          oc.style.display = "none";
          otherSelect.classList.remove("open");
          if (otherSelect.id === 'label-select') {
            const si = otherSelect.querySelector('.option-search');
            if (si && si.value) { si.value=''; si.dispatchEvent(new Event('input',{bubbles:true})); }
          }
        }
      }
    });

    const isOpen = optionsContainer.style.display === "flex";
    if (!isOpen) {
      const r = select.getBoundingClientRect();
      optionsContainer.style.display = "flex";
      const h = optionsContainer.scrollHeight;
      optionsContainer.style.display = "none";
      if (r.bottom + h > window.innerHeight) select.classList.add("upward");
      else select.classList.remove("upward");
    }
    optionsContainer.style.display = isOpen ? "none" : "flex";
    if (isOpen) clearLabelSearch();
    select.classList.toggle("open", !isOpen);

    if (!isOpen && select.id === 'label-select') applySortAndFilter();
  });

  optionsContainer.querySelectorAll(".option").forEach((option) => {
    option.addEventListener("click", () => {
      selected.textContent = option.textContent;
      selected.dataset.value = option.dataset.value;
      optionsContainer.style.display = "none";
      clearLabelSearch();
      select.classList.remove("open");

      if (select.id === "label-select") {
        labelFilter = option.dataset.value;
      } else if (select.id === "sort-order") {
        sortOrder = option.dataset.value;
      }

      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });
  });

  document.addEventListener("click", (e) => {
    if (!select.contains(e.target)) {
      optionsContainer.style.display = "none";
      clearLabelSearch();
      select.classList.remove("open");
    }
  });

  searchInput.addEventListener("input", () => {
    if (select.id === 'label-select') applySortAndFilter();
    else {
      const q = searchInput.value.trim().toLowerCase();
      listContainer.querySelectorAll(".option").forEach((opt) => {
        opt.style.display = opt.textContent.toLowerCase().includes(q) ? "" : "none";
      });
    }
  });
}

function loadFiltersAfterRender() {
  const filterData = JSON.parse(localStorage.getItem("albumFilters"));
  if (!filterData) return;

  document.querySelectorAll(".genre-checkbox").forEach((ch) => {
    ch.checked = false;
    ch.disabled = false;
    const lb = ch.nextElementSibling;
    lb.style.textDecoration = "none";
    lb.style.color = "#f3f3f3";
  });
  if (Array.isArray(filterData.selectedGenres)) {
    filterData.selectedGenres.forEach((g) => {
      const cb = document.getElementById(`genre-${encodeURIComponent(g)}`);
      if (cb) cb.checked = true;
    });
  }
  if (Array.isArray(filterData.excludedGenres)) {
    filterData.excludedGenres.forEach((g) => {
      const cb = document.getElementById(`genre-${encodeURIComponent(g)}`);
      if (cb) {
        cb.disabled = true;
        const cross = cb.parentNode.querySelector(".exclude-genre");
        cross.textContent = "";
        cross.classList.add("repeat-symbol");
        const lb = cb.nextElementSibling;
        lb.style.textDecoration = "line-through";
        lb.style.color = "gray";
      }
    });
  }

  document.querySelectorAll(".language-checkbox").forEach((ch) => {
    ch.checked = false;
    ch.disabled = false;
    const lb = ch.nextElementSibling;
    lb.style.textDecoration = "none";
    lb.style.color = "#f3f3f3";
  });
  if (Array.isArray(filterData.selectedLanguages)) {
    filterData.selectedLanguages.forEach((l) => {
      const cb = document.getElementById(`language-${encodeURIComponent(l)}`);
      if (cb) cb.checked = true;
    });
  }
  if (Array.isArray(filterData.excludedLanguages)) {
    filterData.excludedLanguages.forEach((l) => {
      const cb = document.getElementById(`language-${encodeURIComponent(l)}`);
      if (cb) {
        cb.disabled = true;
        const cross = cb.parentNode.querySelector(".exclude-language");
        cross.textContent = "";
        cross.classList.add("language-repeat-symbol");
        const lb = cb.nextElementSibling;
        lb.style.textDecoration = "line-through";
        lb.style.color = "gray";
      }
    });
  }

  document.querySelectorAll(".release-type-checkbox").forEach((ch) => {
    ch.checked = false;
  });
  if (Array.isArray(filterData.selectedReleaseTypes)) {
    filterData.selectedReleaseTypes.forEach((rt) => {
      const cb = document.getElementById(`release-type-${rt}`);
      if (cb) cb.checked = true;
    });
  }

  if (filterData.sortOrder) {
    const select = document.getElementById("sort-order");
    const selected = select.querySelector(".selected");
    const options = select.querySelectorAll(".option");

    const foundOption = Array.from(options).find(
      (opt) => opt.dataset.value === filterData.sortOrder,
    );
    if (foundOption) {
      selected.textContent = foundOption.textContent;
      selected.dataset.value = foundOption.dataset.value;
      sortOrder = filterData.sortOrder;
    }
  }

  if (typeof filterData.hideListened === "boolean") {
    document.getElementById("hide-listened").checked = filterData.hideListened;
    hideListened = filterData.hideListened;

    if (typeof filterData.nuamRecommended === "boolean") {
      document.getElementById("nuam-recommended-checkbox").checked =
        filterData.nuamRecommended;
    }

    const durationSelect = document.getElementById("duration-filter");
    const selDuration = durationSelect.querySelector(".selected");
    const valueDur = filterData.duration || "";
    const optDuration = durationSelect.querySelector(
      `.option[data-value="${valueDur}"]`,
    );

    if (optDuration) {
      selDuration.textContent = optDuration.textContent;
      selDuration.dataset.value = optDuration.dataset.value;

      const durStart = document.getElementById("duration-start");
      const durEnd = document.getElementById("duration-end");
      const durWrapper = document.getElementById("duration-range");
      durStart.value = durStart.min;
      durEnd.value = durEnd.max;
      durWrapper.style.setProperty("--start", "0%");
      durWrapper.style.setProperty("--end", "100%");
    } else if (valueDur === "range") {
  const start = document.getElementById("duration-start");
  const end = document.getElementById("duration-end");

  const minVal = +start.min;
  const maxVal = +end.max;

  let s = +filterData.durationStart;
  let e = +filterData.durationEnd;
  if (Number.isNaN(s)) s = minVal;
  if (Number.isNaN(e)) e = maxVal;
  if (s < minVal) s = minVal;
  if (e > maxVal) e = maxVal;

  start.value = s;
  end.value = e;

  let text;
  if (s === minVal && e !== maxVal) text = ` ${e} `;
  else if (s !== minVal && e === maxVal) text = ` ${s} `;
  else text = `${s}${e} `;

  selDuration.textContent = text;
  selDuration.dataset.value = "range";

  const wrapper = document.getElementById("duration-range");
  wrapper.style.setProperty("--start", ((s - minVal) / (maxVal - minVal)) * 100 + "%");
  wrapper.style.setProperty("--end", ((e - minVal) / (maxVal - minVal)) * 100 + "%");
}
 else if (valueDur) {
      const [ds, de] = valueDur.split("-").map(Number);
      const start = document.getElementById("duration-start");
      const end = document.getElementById("duration-end");
      start.value = ds;
      end.value = de;

      const minVal = +start.min,
        maxVal = +start.max;
      let text;
      if (ds === minVal && de !== maxVal) text = ` ${de} `;
      else if (ds !== minVal && de === maxVal) text = ` ${ds} `;
      else text = `${ds}${de} `;

      selDuration.textContent = text;
      selDuration.dataset.value = valueDur;

      const wrapper = document.getElementById("duration-range");
      wrapper.style.setProperty(
        "--start",
        ((ds - minVal) / (maxVal - minVal)) * 100 + "%",
      );
      wrapper.style.setProperty(
        "--end",
        ((de - minVal) / (maxVal - minVal)) * 100 + "%",
      );
    } else {
      const defOpt = durationSelect.querySelector(`.option[data-value=""]`);
      selDuration.textContent = defOpt.textContent;
      selDuration.dataset.value = "";
    }

    const trackSelect = document.getElementById("track-count-filter");
    const selTrack = trackSelect.querySelector(".selected");
    const valueTrack = filterData.trackCount || "";
    const optTrack = trackSelect.querySelector(
      `.option[data-value="${valueTrack}"]`,
    );

    if (optTrack) {
      selTrack.textContent = optTrack.textContent;
      selTrack.dataset.value = optTrack.dataset.value;

      const tcStart = document.getElementById("track-count-start");
      const tcEnd = document.getElementById("track-count-end");
      const tcWrapper = document.getElementById("track-count-range");
      tcStart.value = tcStart.min;
      tcEnd.value = tcEnd.max;
      tcWrapper.style.setProperty("--start", "0%");
      tcWrapper.style.setProperty("--end", "100%");
    } else if (valueTrack === "range") {
  const startEl = document.getElementById("track-count-start");
  const endEl = document.getElementById("track-count-end");
  const wrapper = document.getElementById("track-count-range");

  const minT = +startEl.min;
  const maxT = +startEl.max;

  let s = +filterData.trackStart;
  let e = +filterData.trackEnd;
  if (Number.isNaN(s)) s = minT;
  if (Number.isNaN(e)) e = maxT;
  if (s < minT) s = minT;
  if (e > maxT) e = maxT;

  startEl.value = s;
  endEl.value = e;

  let txt;
  if (s === minT && e !== maxT) txt = ` ${e} `;
  else if (s !== minT && e === maxT) txt = ` ${s} `;
  else txt = `${s}${e} `;

  selTrack.textContent = txt;
  selTrack.dataset.value = "range";

  wrapper.style.setProperty("--start", ((s - minT) / (maxT - minT)) * 100 + "%");
  wrapper.style.setProperty("--end", ((e - minT) / (maxT - minT)) * 100 + "%");
}
 else if (valueTrack) {
      const [ds, de] = valueTrack.split("-").map(Number);
      document.getElementById("track-count-start").value = ds;
      document.getElementById("track-count-end").value = de;

      let txt;
      const minT = +document.getElementById("track-count-start").min;
      const maxT = +document.getElementById("track-count-start").max;
      if (ds === minT && de !== maxT) txt = ` ${de} `;
      else if (ds !== minT && de === maxT) txt = ` ${ds} `;
      else txt = `${ds}${de} `;

      selTrack.textContent = txt;
      selTrack.dataset.value = valueTrack;

      const wrapper = document.getElementById("track-count-range");
      wrapper.style.setProperty(
        "--start",
        ((ds - minT) / (maxT - minT)) * 100 + "%",
      );
      wrapper.style.setProperty(
        "--end",
        ((de - minT) / (maxT - minT)) * 100 + "%",
      );
    } else {
      const defOpt = trackSelect.querySelector(`.option[data-value=""]`);
      selTrack.textContent = defOpt.textContent;
      selTrack.dataset.value = "";
    }

    const periodSelect = document.getElementById("release-period-filter");
    const pSel = periodSelect.querySelector(".selected");
    const startSlider = document.getElementById("release-period-start");
    const endSlider = document.getElementById("release-period-end");
    const wrapper = document.getElementById("release-period-range");

    if (filterData.period === "range") {
      const dates = albumsData.map((a) => new Date(a.date));
      const minD = new Date(Math.min(...dates));
      const sDate = new Date(filterData.periodStart);
      const eDate = new Date(filterData.periodEnd);
      const maxW = parseInt(startSlider.max, 10);
      const ws = Math.min(
        Math.max(Math.round((sDate - minD) / (7 * 24 * 60 * 60 * 1000)), 0),
        maxW,
      );
      const we = Math.min(
        Math.max(Math.round((eDate - minD) / (7 * 24 * 60 * 60 * 1000)), 0),
        maxW,
      );
      startSlider.value = ws;
      endSlider.value = we;

      if (typeof updateReleaseRangeTip === "function") {
        updateReleaseRangeTip(true);
      } else {
        const dates = albumsData.map((a) => new Date(a.date));
        const minDate = new Date(Math.min(...dates));
        const maxW = +startSlider.max;
        const s = +startSlider.value,
          e = +endSlider.value;
        const d1 = new Date(minDate.getTime() + s * 7 * 24 * 60 * 60 * 1000);
        const d2 = new Date(minDate.getTime() + e * 7 * 24 * 60 * 60 * 1000);

        pSel.textContent = `${filterData.periodStart}  ${filterData.periodEnd}`;
        pSel.dataset.value = "range";
      }
    } else {
      const opt = periodSelect.querySelector(
        `.option[data-value="${filterData.period || ""}"]`,
      );
      if (opt) {
        pSel.textContent = opt.textContent;
        pSel.dataset.value = opt.dataset.value;
      }

      startSlider.value = startSlider.min;
      endSlider.value = endSlider.max;

      wrapper.style.setProperty("--start", "0%");
      wrapper.style.setProperty("--end", "100%");
    }

    const allListens = albumsData.map((a) => a.listens || 0);
    const posListens = allListens.filter((x) => x > 0).sort((a, b) => a - b);
    const BINS = 100,
      N = posListens.length;
    const steps = [0];
    for (let i = 1; i <= BINS; i++) {
      const idx = Math.floor(((i - 1) * (N - 1)) / (BINS - 1));
      steps.push(posListens[idx]);
    }

    const listenSelect = document.getElementById("listen-count-filter");
    const selListen = listenSelect.querySelector(".selected");
    const optListen = listenSelect.querySelector(
      `.option[data-value="${filterData.listenCount}"]`,
    );

    if (!filterData.listenCount) {
      selListen.textContent = "- ";
      selListen.removeAttribute("data-value");

      const lsInput = document.getElementById("listen-count-start");
      const leInput = document.getElementById("listen-count-end");
      const lsWrapper = document.getElementById("listen-count-range");

      lsInput.value = lsInput.min;
      leInput.value = leInput.max;
      lsWrapper.style.setProperty("--start", "0%");
      lsWrapper.style.setProperty("--end", "100%");
    } else if (optListen) {
      selListen.textContent = optListen.textContent;
      selListen.dataset.value = optListen.dataset.value;
    } else {
      const lsVal = filterData.listenStart;
      const leVal = filterData.listenEnd;

      let lsIdx = steps.findIndex((s) => s >= lsVal);
      if (lsIdx === -1) lsIdx = steps.length - 1;
      let leIdx = steps.findIndex((s) => s >= leVal);
      if (leIdx === -1) leIdx = steps.length - 1;

      document.getElementById("listen-count-start").value = lsIdx;
      document.getElementById("listen-count-end").value = leIdx;

      let text;
      if (lsIdx === 0 && leIdx === steps.length - 1) {
        text = "- ";
      } else if (lsIdx === 0) {
        text = ` ${formatListens(leVal)}`;
      } else if (leIdx === steps.length - 1) {
        text = ` ${formatListens(lsVal)}`;
      } else {
        text = `${formatListens(lsVal)}${formatListens(leVal)}`;
      }
      selListen.textContent = text;
      selListen.dataset.value = "range";

      const maxI = steps.length - 1;
      const wrapper = document.getElementById("listen-count-range");
      wrapper.style.setProperty("--start", (lsIdx / maxI) * 100 + "%");
      wrapper.style.setProperty("--end", (leIdx / maxI) * 100 + "%");
    }

    if (filterData.labelFilter !== undefined) {
      const selectLabel = document.getElementById("label-select");
      const selectedLabelDiv = selectLabel.querySelector(".selected");
      const optionsContainer = selectLabel.querySelector(".options-container");
      const opt = optionsContainer.querySelector(
        `.option[data-value="${filterData.labelFilter}"]`,
      );
      if (opt) {
        selectedLabelDiv.textContent = opt.textContent;
        selectedLabelDiv.dataset.value = opt.dataset.value;
        labelFilter = filterData.labelFilter;
      } else {
        selectedLabelDiv.textContent = " ";
        selectedLabelDiv.dataset.value = "";
        labelFilter = "";
      }
    }
  }

  ["mode-any", "mode-all", "mode-only"].forEach((id) => {
    const b = document.getElementById(id);
    if (b) {
      b.classList.remove("active");
      b.setAttribute("aria-pressed", "false");
    }
  });

  const mode =
    filterData.genreMode || (filterData.matchAllGenres ? "all" : "any");
  const only = !!filterData.genreOnlySelected;

  const anyBtn = document.getElementById("mode-any");
  const allBtn = document.getElementById("mode-all");
  const onlyBtn = document.getElementById("mode-only");

  if (mode === "all") {
    allBtn.classList.add("active");
    allBtn.setAttribute("aria-pressed", "true");
  } else {
    anyBtn.classList.add("active");
    anyBtn.setAttribute("aria-pressed", "true");
  }

  if (only) {
    onlyBtn.classList.add("active");
    onlyBtn.setAttribute("aria-pressed", "true");
  }

  if (!isPresetLoading) {
    applyFilters();
  }
}

function saveFiltersToCache() {
  const selectedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:checked"),
  ).map((cb) => cb.value);
  const excludedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:disabled"),
  ).map((cb) => cb.value);
  const selectedLanguages = Array.from(
    document.querySelectorAll(".language-checkbox:checked"),
  ).map((cb) => cb.value);
  const excludedLanguages = Array.from(
    document.querySelectorAll(".language-checkbox:disabled"),
  ).map((cb) => cb.value);
  const selectedReleaseTypes = Array.from(
    document.querySelectorAll(".release-type-checkbox:checked"),
  ).map((cb) => cb.value);

  let sortOrder = document
    .getElementById("sort-order")
    .querySelector(".selected").dataset.value;
  if (!sortOrder) sortOrder = "desc";

  const hideListened = document.getElementById("hide-listened").checked;
  const nuamRecommended = document.getElementById(
    "nuam-recommended-checkbox",
  ).checked;

  const genreMode = document
    .getElementById("mode-all")
    .classList.contains("active")
    ? "all"
    : "any";
  const genreOnlySelected = document
    .getElementById("mode-only")
    .classList.contains("active");

  const rawDuration =
    document.getElementById("duration-filter").querySelector(".selected")
      .dataset.value || "";
  const rawTrackCount =
    document.getElementById("track-count-filter").querySelector(".selected")
      .dataset.value || "";
  const rawListenCount =
    document.getElementById("listen-count-filter").querySelector(".selected")
      .dataset.value || "";
  const labelFilter =
    document.getElementById("label-select").querySelector(".selected").dataset
      .value || "";

  const duration =
    rawDuration === "range"
      ? `${+document.getElementById("duration-start").value}-${+document.getElementById("duration-end").value}`
      : rawDuration;

  const trackCount =
    rawTrackCount === "range"
      ? `${+document.getElementById("track-count-start").value}-${+document.getElementById("track-count-end").value}`
      : rawTrackCount;

  const sel = document.querySelector("#release-period-filter .selected");
  let period = "",
    periodStart = "",
    periodEnd = "";
  if (sel.dataset.value === "range") {
    period = "range";
    const weekOptions = JSON.parse(
      localStorage.getItem("release-week-options") || "[]",
    );
    periodStart =
      weekOptions[+document.getElementById("release-period-start").value] || "";
    periodEnd =
      weekOptions[+document.getElementById("release-period-end").value] || "";
  } else {
    period = sel.dataset.value || "";
  }

  const durationStart = +document.getElementById("duration-start").value;
  const durationEnd = +document.getElementById("duration-end").value;
  const trackStart = +document.getElementById("track-count-start").value;
  const trackEnd = +document.getElementById("track-count-end").value;

  const allListens = albumsData.map((a) => a.listens || 0);
  const posListens = allListens.filter((x) => x > 0).sort((a, b) => a - b);

  if (posListens.length === 0) posListens.push(0);

  const BINS = 100;
  const N = posListens.length;
  const steps = [0];
  for (let i = 1; i <= BINS; i++) {
    const idx = Math.floor(((i - 1) * (N - 1)) / (BINS - 1));
    steps.push(posListens[idx]);
  }

  const lsIdx = +document.getElementById("listen-count-start").value;
  const leIdx = +document.getElementById("listen-count-end").value;
  const listenStart = Math.round(steps[lsIdx]);
  const listenEnd = Math.round(steps[leIdx]);

  const listenCount =
    rawListenCount === "range" ? `${listenStart}-${listenEnd}` : rawListenCount;

  const filterData = {
    selectedGenres,
    excludedGenres,
    selectedLanguages,
    excludedLanguages,
    selectedReleaseTypes,
    sortOrder,
    hideListened,
    nuamRecommended,
    duration,
    durationStart,
    durationEnd,
    trackCount,
    trackStart,
    trackEnd,
    period,
    periodStart,
    periodEnd,
    listenCount,
    listenStart,
    listenEnd,
    labelFilter,
    genreMode,
    genreOnlySelected,
  };

  localStorage.setItem("albumFilters", JSON.stringify(filterData));
}

function attachGlobalEventListeners() {
  document
    .getElementById("genre-checkboxes")
    .addEventListener("change", (e) => {
      if (e.target.classList.contains("genre-checkbox")) {
        clearActivePreset();
        if (!isPresetLoading) {
          preserveScroll(() => smoothApplyFilters());
          saveFiltersToCache();
        }
      }
    });

  document.getElementById("genre-checkboxes").addEventListener("click", (e) => {
    if (e.target.classList.contains("exclude-genre")) {
      clearActivePreset();
      const genre = e.target.getAttribute("data-genre");
      const cb = document.getElementById(`genre-${encodeURIComponent(genre)}`);
      const lb = cb.nextElementSibling;
      toggleExcludeGenre(genre, cb, lb, e.target);
      saveFiltersToCache();
    }
  });

  (function () {
    const anyBtn = document.getElementById("mode-any");
    const allBtn = document.getElementById("mode-all");
    const onlyBtn = document.getElementById("mode-only");

    if (anyBtn) attachTooltip(anyBtn, "-  ");
    if (allBtn) attachTooltip(allBtn, " ");
    if (onlyBtn) attachTooltip(onlyBtn, " ");
  })();

  const modeAnyBtn = document.getElementById("mode-any");
  const modeAllBtn = document.getElementById("mode-all");
  const modeOnlyBtn = document.getElementById("mode-only");

  function setModeActive(btn, active) {
    btn.classList.toggle("active", active);
    btn.setAttribute("aria-pressed", active ? "true" : "false");
  }
  function ensureBaseMode() {
    const anyOn = modeAnyBtn.classList.contains("active");
    const allOn = modeAllBtn.classList.contains("active");
    if (!anyOn && !allOn) setModeActive(modeAnyBtn, true);
  }
  window.readGenreModes = function () {
    return {
      any: modeAnyBtn.classList.contains("active"),
      all: modeAllBtn.classList.contains("active"),
      only: modeOnlyBtn.classList.contains("active"),
    };
  };

  modeAnyBtn.addEventListener("click", () => {
    setModeActive(modeAnyBtn, !modeAnyBtn.classList.contains("active"));
    setModeActive(modeAllBtn, false);
    ensureBaseMode();
    preserveScroll(() => smoothApplyFilters());
    saveFiltersToCache();
  });
  modeAllBtn.addEventListener("click", () => {
    setModeActive(modeAllBtn, !modeAllBtn.classList.contains("active"));
    setModeActive(modeAnyBtn, false);
    ensureBaseMode();
    preserveScroll(() => smoothApplyFilters());
    saveFiltersToCache();
  });
  modeOnlyBtn.addEventListener("click", () => {
    setModeActive(modeOnlyBtn, !modeOnlyBtn.classList.contains("active"));
    preserveScroll(() => smoothApplyFilters());
    saveFiltersToCache();
  });

  document
    .getElementById("language-checkboxes")
    .addEventListener("change", (e) => {
      if (e.target.classList.contains("language-checkbox")) {
        clearActivePreset();
        if (!isPresetLoading) {
          preserveScroll(() => smoothApplyFilters());
          saveFiltersToCache();
        }
      }
    });

  document
    .getElementById("language-checkboxes")
    .addEventListener("click", (e) => {
      if (e.target.classList.contains("exclude-language")) {
        clearActivePreset();
        const lang = e.target.getAttribute("data-language");
        const cb = document.getElementById(
          `language-${encodeURIComponent(lang)}`,
        );
        const lb = cb.nextElementSibling;
        toggleExcludeLanguage(lang, cb, lb, e.target);
        saveFiltersToCache();
      }
    });

  document
    .getElementById("release-type-checkboxes")
    .addEventListener("change", (e) => {
      if (e.target.classList.contains("release-type-checkbox")) {
        clearActivePreset();
        if (!isPresetLoading) {
          preserveScroll(() => smoothApplyFilters());
          saveFiltersToCache();
        }
      }
    });

  document
    .getElementById("nuam-recommended-checkbox")
    .addEventListener("change", () => {
      clearActivePreset();
      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });

  document
    .getElementById("release-period-filter")
    .addEventListener("change", () => {
      const sel = document.querySelector("#release-period-filter .selected");

      if (sel.dataset.value === "range") return;

      clearActivePreset();
      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });

  document.getElementById("hide-listened").addEventListener("change", (e) => {
    clearActivePreset();
    hideListened = e.target.checked;
    if (!isPresetLoading) {
      preserveScroll(() => smoothApplyFilters());
      saveFiltersToCache();
    }
  });

  document.getElementById("select-all-genres").addEventListener("click", () => {
    document.querySelectorAll(".genre-checkbox").forEach((cb) => {
      if (!cb.disabled) cb.checked = true;
    });
    if (!isPresetLoading) {
      preserveScroll(() => smoothApplyFilters());
      saveFiltersToCache();
    }
  });

  document
    .getElementById("deselect-all-genres")
    .addEventListener("click", () => {
      document.querySelectorAll(".genre-checkbox").forEach((cb) => {
        if (!cb.disabled) cb.checked = false;
      });
      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });

  document
    .getElementById("blacklist-button")
    .addEventListener("click", function () {
      showBlacklist(true);
    });

  document
    .getElementById("show-listened-albums")
    .addEventListener("click", function (event) {
      event.preventDefault();
      showBlacklist(false);
    });

  window.addEventListener("scroll", throttle(handleScroll, 200));

  document.getElementById("import-data").addEventListener("click", () => {
    const importTextarea = document.getElementById("import-textarea");
    const msg = document.getElementById("import-message");
    const importDataString = importTextarea.value.trim();
    if (!importDataString) {
      msg.textContent = "   ";
      msg.className = "error";
      setTimeout(() => {
        msg.textContent = "";
        msg.className = "";
      }, 4000);
      return;
    }
    try {
      const importData = JSON.parse(importDataString);

      if (importData.blacklistArtists) {
        localStorage.setItem(
          "blacklistedArtists",
          JSON.stringify(importData.blacklistArtists),
        );
      }
      if (importData.blacklistLabels) {
        localStorage.setItem(
          "blacklistedLabels",
          JSON.stringify(importData.blacklistLabels),
        );
      }
      if (importData.listenedAlbums) {
        localStorage.setItem(
          "listenedAlbums",
          JSON.stringify(importData.listenedAlbums),
        );
      }
      if (importData.albumFilters) {
        localStorage.setItem(
          "albumFilters",
          JSON.stringify(importData.albumFilters),
        );
      }
      if (importData.favoriteAlbums) {
        localStorage.setItem(
          "favoriteAlbums",
          JSON.stringify(importData.favoriteAlbums),
        );
      }
      if (Array.isArray(importData.presets)) {
        savePresetsToStorage(importData.presets);
        if (typeof loadPresetsFromStorage === "function") {
          loadPresetsFromStorage();
        }
      }

      msg.textContent = " .  .";
      msg.className = "success";
      setTimeout(() => {
        msg.textContent = "";
        msg.className = "";
      }, 5000);
    } catch (error) {
      msg.textContent = "  .  JSON .";
      msg.className = "error";
      setTimeout(() => {
        msg.textContent = "";
        msg.className = "";
      }, 4000);
    }
  });

  window.addEventListener("scroll", () => {
    const scrollTopButton = document.getElementById("scrollTopButton");
    if (window.scrollY > 200) {
      scrollTopButton.style.display = "flex";
      scrollTopButton.style.opacity = "1";
    } else {
      scrollTopButton.style.opacity = "0";
      setTimeout(() => {
        if (window.scrollY <= 200) {
          scrollTopButton.style.display = "none";
        }
      }, 300);
    }
  });

  document.getElementById("favorites-button").addEventListener("click", () => {
    const modal = document.getElementById("blacklist-modal");
    modal.style.display = "block";
    document.getElementById("favorites-tab").click();
  });

  document
    .querySelector("#blacklist-modal .close")
    .addEventListener("click", () => {
      document.getElementById("blacklist-modal").style.display = "none";
    });

  (function () {
  const SAFE_INPUTS = '.option-search, #preset-name-input, #preset-desc-input, #edit-name-input, #edit-desc-input';
  let suppressNextClick = false;

  document.addEventListener('mousedown', function (e) {
    const t = e.target;
    suppressNextClick = !!(t && t.closest && t.closest(SAFE_INPUTS));
  }, true);

  document.addEventListener('click', function (e) {
    if (suppressNextClick) {
      suppressNextClick = false;
      e.stopPropagation();
      if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
    }
  }, true);
})();
  
  window.addEventListener("click", (event) => {
    const modal = document.getElementById("blacklist-modal");
    if (event.target === modal) {
      modal.style.display = "none";
    }
  });
 document.getElementById("scrollTopButton").addEventListener("click", () => {
    window.scrollTo({
      top: 0,
      behavior: "smooth",
    });
  });

  const logoWrapper = document.querySelector(".logo-wrapper");
  const filtersButton = document.getElementById("filters-button");
  const searchButton = document.getElementById("search-button");
  const searchContainer = document.getElementById("search-container");
  const searchInput = document.getElementById("search-input");
  const searchClose = document.getElementById("search-close");
  
(function initLogosNoDup(){
  const root = document.documentElement;

  const GROUPS = [
    { sel: '#app-logo',                                 cssVar: '--mask-logo-main' },
    { sel: '.logo-dropdown .logo-row:nth-child(1) img', cssVar: '--mask-logo-1'   },
    { sel: '.logo-dropdown .logo-row:nth-child(2) img', cssVar: '--mask-logo-2'   },
    { sel: '.logo-dropdown .logo-row:nth-child(3) img', cssVar: '--mask-logo-3'   },
  ];

  const urlToTargets = new Map();
  GROUPS.forEach(({ sel, cssVar }) => {
    document.querySelectorAll(sel).forEach((img) => {
      const url = img.getAttribute('data-src') || img.getAttribute('src');
      if (!url) return;
      if (!urlToTargets.has(url)) urlToTargets.set(url, { cssVars: new Set(), imgs: new Set() });
      urlToTargets.get(url).imgs.add(img);
      urlToTargets.get(url).cssVars.add(cssVar);
    });
  });

  function preload(url, cb){
    const im = new Image();
    im.decoding = 'async';
    im.onload = () => cb(url);
    im.onerror = () => cb(url);
    im.src = url;
  }

  function applyFor(url){
    const t = urlToTargets.get(url);
    if (!t) return;

    t.imgs.forEach((img) => {
      if (!img.getAttribute('src')) img.setAttribute('src', url);
      else                          img.src = url;
    });

    t.cssVars.forEach((v) => root.style.setProperty(v, `url("${url}")`));
  }

  function start(){
    if (urlToTargets.size === 0){
      document.querySelectorAll('.logo-wrapper').forEach(w => w.classList.add('logos-ready'));
      return;
    }
    let pending = urlToTargets.size;
    urlToTargets.forEach((_, url) => {
      preload(url, (readyUrl) => {
        applyFor(readyUrl);
        pending -= 1;
        if (pending === 0){
          document.querySelectorAll('.logo-wrapper').forEach(w => w.classList.add('logos-ready'));
        }
      });
    });
  }

  if (document.readyState === 'complete') start();
  else window.addEventListener('load', start, { once: true });
})();

{
  const TIP = '   ,     ';
  filtersButton.setAttribute('aria-label', TIP);
  filtersButton.removeAttribute('data-tooltip');
  filtersButton.removeAttribute('title');
  if (typeof attachTooltip === 'function') {
    attachTooltip(filtersButton, TIP, '230px');
  }
}
  
  window.albumSearchMode =
    localStorage.getItem("albumSearchMode") || "artist-album";

  (function initAlbumSearchModeToggle() {
    const wrap = document.getElementById("search-mode-toggle");
    if (!wrap) return;

    const buttons = Array.from(wrap.querySelectorAll("button"));
    const setActive = (mode) => {
      if (mode === "artist-album") {
        buttons.forEach((b) => b.classList.add("active"));
      } else {
        buttons.forEach((b) =>
          b.classList.toggle("active", b.dataset.mode === mode),
        );
      }
    };

    setActive(window.albumSearchMode);

    wrap.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-mode]");
      if (!btn) return;
      const mode = btn.dataset.mode;
      window.albumSearchMode = mode;
      localStorage.setItem("albumSearchMode", mode);
      setActive(mode);

      const inp = document.getElementById("search-input");
      const qLocal = (inp && typeof inp.value === "string") ? inp.value.trim() : "";
      const qState = (typeof searchQuery === "string") ? searchQuery.trim() : "";
      const hasQuery = (qLocal !== "") || (qState !== "");

      if (hasQuery && typeof smoothApplyFilters === "function") smoothApplyFilters();
    });
  })();

  (function replaceSearchModeButtonTextWithIcons() {
    const wrap = document.getElementById("search-mode-toggle");
    if (!wrap) return;

    const MAP = {
      artist: {
        html: '<i class="fa-solid fa-user"></i>',
        tip: "   ",
      },
      "artist-album": {
        html: '<i class="fa-solid fa-arrows-left-right"></i>',
        tip: "    ",
      },
      album: {
        html: '<i class="fa-solid fa-compact-disc"></i>',
        tip: "   ",
      },
    };

    Object.entries(MAP).forEach(([mode, cfg]) => {
      const btn = wrap.querySelector(`button[data-mode="${mode}"]`);
      if (!btn) return;

      const textBlock =
        btn.querySelector(".label, .btn-text, .text, span, div") ||
        btn.firstElementChild ||
        null;

      if (textBlock) {
        textBlock.innerHTML = cfg.html;
      } else {
        btn.innerHTML = cfg.html;
      }

      btn.setAttribute("data-tooltip", cfg.tip);
      btn.setAttribute("aria-label", cfg.tip);
      btn.title = "";
    });
  })();

  (function initSearchModeTooltips() {
    const wrap = document.getElementById("search-mode-toggle");
    if (!wrap || typeof attachTooltip !== "function") return;

    const btnArtist = wrap.querySelector('button[data-mode="artist"]');
    const btnBoth = wrap.querySelector('button[data-mode="artist-album"]');
    const btnAlbum = wrap.querySelector('button[data-mode="album"]');

    attachTooltip(btnArtist, "   ");
    attachTooltip(btnBoth, "    ", "300px");
    attachTooltip(btnAlbum, "   ");
  })();

  const filtersContainer = document.getElementById("filters-container");
  const filtersClose = document.getElementById("filters-close");

  searchButton.addEventListener("click", () => {
    logoWrapper.style.display = "none";
    searchButton.style.display = "none";
    filtersButton.style.display = "none";
    searchContainer.style.display = "flex";
    searchInput.focus();
  });

  searchClose.addEventListener("click", () => {
  const hadQuery =
    (searchInput.value && searchInput.value.trim() !== "") ||
    (typeof searchQuery === "string" && searchQuery.trim() !== "");

  logoWrapper.style.display = "inline-block";
  searchButton.style.display = "inline-block";
  filtersButton.style.display = "inline-block";
  searchContainer.style.display = "none";

  searchInput.value = "";
  searchQuery = "";

  if (hadQuery && typeof smoothApplyFilters === "function") {
    smoothApplyFilters();
  }
});

  filtersButton.addEventListener("click", () => {
    logoWrapper.style.display = "none";
    searchButton.style.display = "none";
    filtersButton.style.display = "none";
    filtersContainer.style.display = "flex";
  });

  filtersClose.addEventListener("click", () => {
    logoWrapper.style.display = "inline-block";
    searchButton.style.display = "inline-block";
    filtersButton.style.display = "inline-block";
    filtersContainer.style.display = "none";
  });

  document.getElementById("search-input").addEventListener("input", (e) => {
    searchQuery = e.target.value.trim().toLowerCase();
    smoothApplyFilters();
  });
}

function toggleExcludeGenre(genre, checkbox, label, genreCross) {
  if (checkbox.disabled) {
    checkbox.disabled = false;
    genreCross.textContent = "";
    genreCross.classList.remove("repeat-symbol");
    label.style.textDecoration = "none";
    label.style.color = "#f3f3f3";
  } else {
    checkbox.checked = false;
    checkbox.disabled = true;
    genreCross.textContent = "";
    genreCross.classList.add("repeat-symbol");
    label.style.textDecoration = "line-through";
    label.style.color = "gray";
  }
  preserveScroll(() => smoothApplyFilters());
}

function toggleExcludeLanguage(language, checkbox, label, langCross) {
  if (checkbox.disabled) {
    checkbox.disabled = false;
    langCross.textContent = "";
    langCross.classList.remove("language-repeat-symbol", "repeat-symbol");
    label.style.textDecoration = "none";
    label.style.color = "#f3f3f3";
  } else {
    checkbox.checked = false;
    checkbox.disabled = true;
    langCross.textContent = "";
    langCross.classList.add("language-repeat-symbol");
    label.style.textDecoration = "line-through";
    label.style.color = "gray";
  }
  preserveScroll(() => smoothApplyFilters());
}

function getFilteredAlbums() {
  const selectedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:checked"),
  ).map((cb) => cb.value);
  const excludedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:disabled"),
  ).map((cb) => cb.value);
  const selectedLangs = Array.from(
    document.querySelectorAll(".language-checkbox:checked"),
  ).map((cb) => cb.value);
  const excludedLangs = Array.from(
    document.querySelectorAll(".language-checkbox:disabled"),
  ).map((cb) => cb.value);
  const selectedReleaseTypes = Array.from(
    document.querySelectorAll(".release-type-checkbox:checked"),
  ).map((cb) => cb.value);

  return albumsData.filter((al) => {
    if (hideListened && al.listened) return false;

    const {
      any: modeAny,
      all: modeAll,
      only: modeOnly,
    } = window.readGenreModes
      ? window.readGenreModes()
      : { any: true, all: false, only: false };
    const hasAny =
      selectedGenres.length === 0 ||
      al.genres.some((g) => selectedGenres.includes(g));
    const hasAll =
      selectedGenres.length === 0 ||
      selectedGenres.every((g) => al.genres.includes(g));
    const onlyOk =
      !modeOnly ||
      selectedGenres.length === 0 ||
      al.genres.every((g) => selectedGenres.includes(g));
    const base = selectedGenres.length === 0 ? true : modeAll ? hasAll : hasAny;
    const matchGenres = base && onlyOk;

    const notExcludedGenres =
      excludedGenres.length === 0 ||
      !al.genres.some((g) => excludedGenres.includes(g));

    const matchLangs =
      selectedLangs.length === 0 ||
      (al.languages.length === 0
        ? selectedLangs.includes(" ")
        : al.languages.some((l) => selectedLangs.includes(l)));
    const notExcludedLangs =
      excludedLangs.length === 0 ||
      (al.languages.length === 0
        ? !excludedLangs.includes(" ")
        : !al.languages.some((l) => excludedLangs.includes(l)));

    const matchRelease =
      selectedReleaseTypes.length === 0 ||
      selectedReleaseTypes.includes(al.type);
    const notBlacklistedArtist =
      window.tempIgnoreBlacklist ||
      !al.artistIDs.some((id) => blacklistedArtists.has(id));
    const notBlacklistedLabel =
      window.tempIgnoreBlacklist || !blacklistedLabels.has(al.label);

    return (
      matchGenres &&
      notExcludedGenres &&
      matchLangs &&
      notExcludedLangs &&
      matchRelease &&
      notBlacklistedArtist &&
      notBlacklistedLabel
    );
  });
}

function applyFilters(renderImmediately = false) {
  filteredAlbums = [...albumsData];

  const selectedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:checked"),
  ).map((cb) => cb.value);
  const {
    any: modeAny,
    all: modeAll,
    only: modeOnly,
  } = window.readGenreModes
    ? window.readGenreModes()
    : { any: true, all: false, only: false };

  if (selectedGenres.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) => {
      const hasAny = al.genres.some((g) => selectedGenres.includes(g));
      const hasAll = selectedGenres.every((g) => al.genres.includes(g));
      const onlyOk =
        !modeOnly || al.genres.every((g) => selectedGenres.includes(g));
      const base = modeAll ? hasAll : hasAny;
      return base && onlyOk;
    });
  }

  const excludedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:disabled"),
  ).map((cb) => cb.value);
  if (excludedGenres.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) => {
      return !al.genres.some((g) => excludedGenres.includes(g));
    });
  }

  const selectedLangs = Array.from(
    document.querySelectorAll(".language-checkbox:checked"),
  ).map((cb) => cb.value);
  if (selectedLangs.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) => {
      if (al.languages.length === 0) {
        return selectedLangs.includes(" ");
      } else {
        return al.languages.some((l) => selectedLangs.includes(l));
      }
    });
  }

  const excludedLangs = Array.from(
    document.querySelectorAll(".language-checkbox:disabled"),
  ).map((cb) => cb.value);
  if (excludedLangs.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) => {
      if (al.languages.length === 0) {
        return !excludedLangs.includes(" ");
      } else {
        return !al.languages.some((l) => excludedLangs.includes(l));
      }
    });
  }

  const selectedReleaseTypes = Array.from(
    document.querySelectorAll(".release-type-checkbox:checked"),
  ).map((cb) => cb.value);
  if (selectedReleaseTypes.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) =>
      selectedReleaseTypes.includes(al.type),
    );
  }

  const onlyRecommended = document.getElementById(
    "nuam-recommended-checkbox",
  ).checked;
  if (onlyRecommended) {
    filteredAlbums = filteredAlbums.filter((al) => al.good);
  }

  if (!window.tempIgnoreBlacklist) {
    filteredAlbums = filteredAlbums.filter(
      (al) => !al.artistIDs.some((id) => blacklistedArtists.has(id)),
    );
    filteredAlbums = filteredAlbums.filter(
      (al) => !blacklistedLabels.has(al.label),
    );
  }

  if (hideListened) {
    filteredAlbums = filteredAlbums.filter((al) => !al.listened);
  }

  if (sortOrder === "listens-desc") {
    filteredAlbums.sort((a, b) => b.listens - a.listens);
  } else if (sortOrder === "listens-asc") {
    filteredAlbums.sort((a, b) => a.listens - b.listens);
  } else if (sortOrder === "popularity-growth") {
    filteredAlbums = filteredAlbums.filter(
      (al) => (al.listens || 0) > 0 && (al.popularity || 0) > 0,
    );
    filteredAlbums.sort((a, b) => {
      const pa = a.popularity ?? -Infinity;
      const pb = b.popularity ?? -Infinity;
      if (pb !== pa) return pb - pa;
      const da = new Date(a.date),
        db = new Date(b.date);
      if (db - da !== 0) return db - da;
      if (b.listens !== a.listens) return b.listens - a.listens;
      return String(a.nameAlbum).localeCompare(String(b.nameAlbum));
    });
  } else if (sortOrder === "random") {
    for (let i = filteredAlbums.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [filteredAlbums[i], filteredAlbums[j]] = [
        filteredAlbums[j],
        filteredAlbums[i],
      ];
    }
  } else if (sortOrder === "duration-desc") {
    filteredAlbums.sort((a, b) => {
      const [hA, mA] = (a.duration || "00:00:00").split(":").map(Number);
      const [hB, mB] = (b.duration || "00:00:00").split(":").map(Number);
      return hB * 60 + mB - (hA * 60 + mA);
    });
  } else if (sortOrder === "duration-asc") {
    filteredAlbums.sort((a, b) => {
      const [hA, mA] = (a.duration || "00:00:00").split(":").map(Number);
      const [hB, mB] = (b.duration || "00:00:00").split(":").map(Number);
      return hA * 60 + mA - (hB * 60 + mB);
    });
  } else if (sortOrder === "tracks-desc") {
    filteredAlbums.sort((a, b) => b.tracksIDs.length - a.tracksIDs.length);
  } else if (sortOrder === "tracks-asc") {
    filteredAlbums.sort((a, b) => a.tracksIDs.length - b.tracksIDs.length);
  } else {
    filteredAlbums.sort((a, b) => {
      const da = new Date(a.date),
        db = new Date(b.date);
      return sortOrder === "asc" ? da - db : db - da;
    });
  }

  const selectedDuration =
    document.getElementById("duration-filter").querySelector(".selected")
      .dataset.value || "";

  if (selectedDuration === "range") {
    const s = +document.getElementById("duration-start").value;
    const e = +document.getElementById("duration-end").value;
    filteredAlbums = filteredAlbums.filter((al) => {
      const [h, m] = (al.duration || "00:00:00")
        .split(":")
        .map((x) => parseInt(x, 10) || 0);
      const total = h * 60 + m;
      return total >= Math.min(s, e) && total <= Math.max(s, e);
    });
  } else if (
    /^\d+-\d+$/.test(selectedDuration) ||
    /^\d+-$/.test(selectedDuration) ||
    /^-\d+$/.test(selectedDuration)
  ) {
    const [minStr, maxStr] = selectedDuration.split("-");
    const min = minStr ? parseInt(minStr, 10) : 0;
    const max = maxStr ? parseInt(maxStr, 10) : Infinity;
    filteredAlbums = filteredAlbums.filter((al) => {
      const [h, m] = (al.duration || "00:00:00")
        .split(":")
        .map((x) => parseInt(x, 10) || 0);
      const total = h * 60 + m;
      return total >= min && total <= max;
    });
  } else if (selectedDuration) {
    filteredAlbums = filteredAlbums.filter((al) => {
      const [h, m] = (al.duration || "00:00:00")
        .split(":")
        .map((x) => parseInt(x, 10) || 0);
      const total = h * 60 + m;
      if (selectedDuration === "short") return total < 30;
      if (selectedDuration === "medium") return total >= 30 && total < 60;
      if (selectedDuration === "long") return total >= 60 && total < 120;
      if (selectedDuration === "very-long") return total >= 120;
      return true;
    });
  }

  const selectedTrackCount =
    document.getElementById("track-count-filter").querySelector(".selected")
      .dataset.value || "";

  if (selectedTrackCount === "range") {
    const s = +document.getElementById("track-count-start").value;
    const e = +document.getElementById("track-count-end").value;
    filteredAlbums = filteredAlbums.filter((al) => {
      const t = al.tracksIDs.length;
      return t >= Math.min(s, e) && t <= Math.max(s, e);
    });
  } else if (
    /^\d+-\d+$/.test(selectedTrackCount) ||
    /^\d+-$/.test(selectedTrackCount) ||
    /^-\d+$/.test(selectedTrackCount)
  ) {
    const [minStr, maxStr] = selectedTrackCount.split("-");
    const min = minStr ? parseInt(minStr, 10) : 0;
    const max = maxStr ? parseInt(maxStr, 10) : Infinity;
    filteredAlbums = filteredAlbums.filter((al) => {
      const t = al.tracksIDs.length;
      return t >= min && t <= max;
    });
  } else if (selectedTrackCount) {
    const minTracks = parseInt(selectedTrackCount, 10);
    filteredAlbums = filteredAlbums.filter(
      (al) => al.tracksIDs.length >= minTracks,
    );
  }

  const selEl = document.querySelector("#release-period-filter .selected");
  if (selEl.dataset.value !== "range") {
    const selectedPeriod = selEl.dataset.value;
    if (selectedPeriod) {
      const days = parseInt(selectedPeriod, 10);
      const now = new Date();
      const threshold = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
      filteredAlbums = filteredAlbums.filter(
        (al) => new Date(al.date) >= threshold,
      );
    }
  }

  {
    const ws = +document.getElementById("release-period-start").value;
    const we = +document.getElementById("release-period-end").value;
    const dates = albumsData.map((a) => new Date(a.date));
    const minDate = new Date(Math.min(...dates));
    const d1 = new Date(minDate.getTime() + ws * 7 * 24 * 60 * 60 * 1000);
    const d2 = new Date(minDate.getTime() + we * 7 * 24 * 60 * 60 * 1000);
    const startDate = d1 < d2 ? d1 : d2;
    const endDate = d1 < d2 ? d2 : d1;
    filteredAlbums = filteredAlbums.filter((al) => {
      const d = new Date(al.date);
      return d >= startDate && d <= endDate;
    });
  }

  const selListen =
    document.getElementById("listen-count-filter").querySelector(".selected")
      .dataset.value || "";

  if (selListen === "range") {
    const i1 = +document.getElementById("listen-count-start").value;
    const i2 = +document.getElementById("listen-count-end").value;

    const allListens = albumsData.map((a) => a.listens || 0);
    const posListens = allListens.filter((x) => x > 0).sort((a, b) => a - b);
    if (posListens.length === 0) posListens.push(0);

    const BINS = 100;
    const N = posListens.length;
    const steps = [0];
    for (let k = 1; k <= BINS; k++) {
      const idx = Math.floor(((k - 1) * (N - 1)) / (BINS - 1));
      steps.push(posListens[idx]);
    }

    const startIdx = Math.min(i1, i2);
    const endIdx = Math.max(i1, i2);
    const sVal = Math.round(steps[startIdx]);
    const eVal = Math.round(steps[endIdx]);

    filteredAlbums = filteredAlbums.filter(
      (al) => al.listens >= sVal && al.listens <= eVal,
    );
  } else if (selListen) {
    const [minStr, maxStr] = selListen.split("-");
    const min = minStr ? parseInt(minStr, 10) : 0;
    const max = maxStr ? parseInt(maxStr, 10) : Infinity;
    filteredAlbums = filteredAlbums.filter(
      (al) => al.listens >= min && al.listens <= max,
    );
  }

  const preSearch = filteredAlbums.slice();

  if (searchQuery) {
    const mode = window.albumSearchMode || "artist-album";
    const searchMatches = albumsData.filter((al) => {
      const albumHit = String(al.nameAlbum || "")
        .toLowerCase()
        .includes(searchQuery);
      const artistHit =
        Array.isArray(al.artistNames) &&
        al.artistNames.some((n) =>
          String(n || "")
            .toLowerCase()
            .includes(searchQuery),
        );
      if (mode === "artist") return artistHit;
      if (mode === "album") return albumHit;
      return albumHit || artistHit;
    });

    const primary = filteredAlbums.filter((al) => searchMatches.includes(al));
    const hiddenByFilters = searchMatches.filter((al) => !primary.includes(al));
    if (hiddenByFilters.length) {
      primary.push({ __separatorType: "search" });
      primary.push(...hiddenByFilters);
    }

    filteredAlbums = primary;
  }

  if (labelFilter) {
  filteredAlbums = filteredAlbums.filter((al) => canonLabel(al.label) === labelFilter);
}

  if (labelFilter) {
  const totalByLabel = albumsData.filter((a) => canonLabel(a.label) === labelFilter);
  const hiddenByLabel = totalByLabel.filter(
    (a) => !filteredAlbums.includes(a),
  );

    if (sortOrder === "listens-desc") {
      hiddenByLabel.sort((a, b) => b.listens - a.listens);
    } else if (sortOrder === "popularity-growth") {
      for (let i = hiddenByLabel.length - 1; i >= 0; i--) {
        const al = hiddenByLabel[i];
        if (!((al.listens || 0) > 0 && (al.popularity || 0) > 0)) {
          hiddenByLabel.splice(i, 1);
        }
      }
      hiddenByLabel.sort((a, b) => {
        const pa = a.popularity ?? -Infinity;
        const pb = b.popularity ?? -Infinity;
        if (pb !== pa) return pb - pa;
        const da = new Date(a.date),
          db = new Date(b.date);
        if (db - da !== 0) return db - da;
        if (b.listens !== a.listens) return b.listens - a.listens;
        return String(a.nameAlbum).localeCompare(String(b.nameAlbum));
      });
    } else {
      hiddenByLabel.sort((a, b) => {
        const da = new Date(a.date),
          db = new Date(b.date);
        return sortOrder === "asc" ? da - db : db - da;
      });
    }

    if (hiddenByLabel.length) {
      filteredAlbums.push({ __separatorType: "label" });

      filteredAlbums.push(...hiddenByLabel);
    }
  }

  const forceAll = Boolean(labelFilter) || renderImmediately;
  currentIndex = 0;

  renderAlbums(filteredAlbums, true, forceAll);

updateAlbumCount();

const lazyMsg = document.getElementById("lazy-loading");
isEmptyResult = filteredAlbums.length === 0;
lazyMsg.textContent = isEmptyResult
  ? "     "
  : "";
  
}

function updateRenderedAlbums(filteredAlbums) {
  const container = document.getElementById("albums-container");
  const filteredIDs = new Set(filteredAlbums.map((a) => a.albumID));

  document.querySelectorAll(".album").forEach((albumDiv) => {
    const id = albumDiv.dataset.albumId;
    if (!filteredIDs.has(id)) {
      albumDiv.style.transition = "opacity 0.3s";
      albumDiv.style.opacity = "0";
      setTimeout(() => albumDiv.remove(), 300);
    }
  });

  currentIndex = [...container.querySelectorAll(".album")].length;
}

function handleScroll() {
  if (isFiltering) return;

  const atBottom = window.innerHeight + window.scrollY >= document.body.offsetHeight - 100;
  const lazyEl = document.getElementById("lazy-loading");

  if (atBottom && currentIndex < filteredAlbums.length) {
    renderAlbums(filteredAlbums);
  } else if (atBottom && currentIndex >= filteredAlbums.length && !isEmptyResult) {
    if (lazyEl) lazyEl.textContent = "    ";
  }
}



function forceLazyLoadCheck() {
  const container = document.getElementById("albums-container");

  const containerBottom = container.getBoundingClientRect().bottom;
  const viewportHeight = window.innerHeight;

  if (
    containerBottom <= viewportHeight + 100 &&
    currentIndex < filteredAlbums.length
  ) {
    renderAlbums(filteredAlbums);
  } else if (currentIndex >= filteredAlbums.length) {
  const el = document.getElementById("lazy-loading");
  el.textContent = isEmptyResult
    ? "     "
    : "";
}


}

function throttle(func, limit) {
  let lastFunc;
  let lastRan;
  return function () {
    const context = this,
      args = arguments;
    if (!lastRan) {
      func.apply(context, args);
      lastRan = Date.now();
    } else {
      clearTimeout(lastFunc);
      lastFunc = setTimeout(
        function () {
          if (Date.now() - lastRan >= limit) {
            func.apply(context, args);
            lastRan = Date.now();
          }
        },
        limit - (Date.now() - lastRan),
      );
    }
  };
}

function renderAlbums(data, reset = false, forceAll = false) {
  const container = document.getElementById("albums-container");
  if (reset) container.innerHTML = "";

  const endIndex = forceAll
    ? data.length
    : Math.min(currentIndex + batchSize, data.length);

  for (let i = currentIndex; i < endIndex; i++) {
    const album = data[i];

    if (album.__separatorType) {
      const sepText =
        album.__separatorType === "label"
          ? " ,      "
          : " ,      ";
      const sep = document.createElement("div");
      sep.classList.add("separator");

      const line1 = document.createElement("div");
      line1.classList.add("line");

      const text = document.createElement("div");
      text.classList.add("sep-text");
      text.textContent = sepText;

      const line2 = document.createElement("div");
      line2.classList.add("line");

      sep.append(line1, text, line2);
      container.appendChild(sep);
      continue;
    }

    const albumDiv = document.createElement("div");
    albumDiv.classList.add("album");
    albumDiv.dataset.albumId = album.albumID;
    if (album.listened) albumDiv.classList.add("album-listened");

    const coverUrl = `https://i.scdn.co/image/ab67616d0000b273${album.cover}`;
    const albumLink = `https://open.spotify.com/album/${album.albumID}`;
    const langText =
      album.languages.length === 0
        ? " "
        : album.languages.map((l) => languageLabels[l] || l).join(", ");
    const joinedGenres = album.genres.length
      ? album.genres.map((g) => friendlyGenreLabel(g)).join(", ")
      : " ";

    albumDiv.innerHTML = `
      <div class="album-overlay"></div>
      <div class="album-cover-wrapper">
        <img src="${coverUrl}" alt="${album.nameAlbum}" class="album-cover">
      </div>

      <div class="album-details">
        <div class="alb-head">
          ${releaseIcon(album.type)}
          <div class="alb-head-txt">
            <h3 style="display: flex; align-items: center; gap: 6px;">
  <a href="${albumLink}" target="_blank" style="display: flex; align-items: center; gap: 6px;">
    ${album.nameAlbum}
    <span class="spotify-icon">
      <span class="icon-default">
        <svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" fill="none">
          <circle cx="24" cy="24" r="21.5" stroke="#f3f3f3" stroke-width="2"/>
          <path d="M33.86 33.51c-.39.63-1.21.83-1.84.44-5.05-3.08-11.4-3.78-18.89-2.07-.72.16-1.44-.29-1.6-1.01-.17-.72.29-1.44 1.01-1.6 8.19-1.87 15.21-1.07 20.88 2.4.63.39.83 1.21.44 1.84Zm2.63-5.85c-.49.79-1.52 1.04-2.31.55-5.78-3.55-14.59-4.58-21.42-2.51-.89.27-1.82-.23-2.09-1.12-.27-.89.23-1.82 1.12-2.09 7.81-2.37 17.52-1.22 24.15 2.86.79.49 1.04 1.52.55 2.3Zm.23-6.1c-6.93-4.12-18.36-4.49-24.98-2.49-1.06.32-2.19-.28-2.51-1.34-.32-1.06.28-2.19 1.34-2.51 7.59-2.31 20.22-1.86 28.2 2.88.96.57 1.27 1.8.7 2.76-.56.96-1.8 1.27-2.75.7Z" fill="#f3f3f3"/>
        </svg>
      </span>
      <span class="icon-hover">
        <svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
        <path fill="#00DA5A" fill-opacity="0.7" d="M238.16,481.36 C230.48,476.8 217.64,476.32 210.32,478.6 C209.12,478.96 207.92,478.24 207.56,477.16 C207.2,475.96 207.92,474.76 209,474.4 C217.52,471.88 231.56,472.36 240.44,477.64 C241.52,478.24 241.88,479.68 241.28,480.76 C240.68,481.6 239.24,481.96 238.16,481.36 M237.92,488.08 C237.32,488.92 236.24,489.28 235.4,488.68 C228.92,484.72 219.08,483.52 211.52,485.92 C210.56,486.16 209.48,485.68 209.24,484.72 C209,483.76 209.48,482.68 210.44,482.44 C219.2,479.8 230,481.12 237.44,485.68 C238.16,486.04 238.52,487.24 237.92,488.08 M235.04,494.68 C234.56,495.4 233.72,495.64 233,495.16 C227.36,491.68 220.28,490.96 211.88,492.88 C211.04,493.12 210.32,492.52 210.08,491.8 C209.84,490.96 210.44,490.24 211.16,490 C220.28,487.96 228.2,488.8 234.44,492.64 C235.28,493 235.4,493.96 235.04,494.68 M224,460 C210.8,460 200,470.8 200,484 C200,497.2 210.8,508 224,508 C237.2,508 248,497.2 248,484 C248,470.8 237.32,460 224,460" transform="translate(-200 -460)"/>
      </svg>
      </span>
    </span>
  </a>

  <span class="album-links">
    <a href="https://music.youtube.com/search?q=${encodeURIComponent(album.artistNames.join(", ") + " - " + album.nameAlbum)}" target="_blank" class="yt-icon">
      <span class="icon-default">
        <svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" fill="none">
  <circle cx="24" cy="24" r="14" stroke="#f3f3f3" stroke-width="2"/>
  <circle cx="24" cy="24" r="21.5" stroke="#f3f3f3" stroke-width="2"/>
  <path d="M31,24L19,31V17Z" fill="#f3f3f3"/>
</svg>
      </span>
      <span class="icon-hover">
        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <path fill="#FF0000" fill-opacity="0.7" d="M50,2.5C23.766,2.5,2.5,23.823,2.5,50.126c2.502,63.175,92.507,63.157,95-0.001C97.5,23.823,76.233,2.5,50,2.5z
            M50,77.399c-15.036,0-27.27-12.233-27.27-27.27c0.74-18.662,14.654-27.134,27.269-27.134c0.001,0,0.001,0,0.002,0
            c12.616,0.001,26.531,8.473,27.267,27.073C77.27,65.167,65.036,77.399,50,77.399z"/>
          <path fill="#FF0000" d="M50.002,26.103c-15.946-0.001-23.704,12.486-24.165,24.088C25.838,63.453,36.677,74.292,50,74.292
            S74.162,63.453,74.162,50.13C73.705,38.591,65.948,26.105,50.002,26.103z"/>
          <path fill="#FFFFFF" d="M41.055,52.528c-0.001,2.575,0.001,7.867,0,10.46c0,0,21.802-13.417,21.802-13.417L41.055,37.272V52.528z"/>
        </svg>
      </span>
    </a>

    <a href="https://music.apple.com/ua/search?term=${encodeURIComponent(album.artistNames.join(", ") + " - " + album.nameAlbum)}" target="_blank" class="apple-icon">
      <span class="icon-default">
        <svg viewBox="0 0 192 192" xmlns="http://www.w3.org/2000/svg" fill="none">
  <path stroke="#f3f3f3" stroke-width="12" d="m68 60 80-14M68 60v91m0-91V40.722a8 8 0 0 1 6.621-7.88l64-11.2c4.895-.857 9.379 2.91 9.379 7.88V46m0 0v89m-98.477.234-8.48 1.483A15.761 15.761 0 0 0 28 152.242c0 9.791 8.833 17.212 18.477 15.524l8.48-1.483A15.761 15.761 0 0 0 68 150.758c0-9.791-8.833-17.212-18.477-15.524Zm80-16-8.479 1.483A15.761 15.761 0 0 0 108 136.242c0 9.791 8.833 17.212 18.477 15.524l8.479-1.483A15.761 15.761 0 0 0 148 134.758c0-9.791-8.833-17.212-18.477-15.524Z"/>
</svg>
      </span>
      <span class="icon-hover">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="Apple Music" role="img" viewBox="0 0 512 512" fill="#000000" fill-opacity="0.7">
          <rect width="512" height="512" rx="15%" fill="url(#g)"></rect>
          <linearGradient id="g" x1=".5" y1=".99" x2=".5" y2=".02">
            <stop offset="0" stop-color="#FA233B"></stop>
            <stop offset="1" stop-color="#FB5C74"></stop>
          </linearGradient>
          <path fill="#ffffff" d="M199 359V199q0-9 10-11l138-28q11-2 12 10v122q0 15-45 20c-57 9-48 105 30 79 30-11 35-40 35-69V88s0-20-17-15l-170 35s-13 2-13 18v203q0 15-45 20c-57 9-48 105 30 79 30-11 35-40 35-69"/>
        </svg>
      </span>
    </a>
  </span>
</h3>

            <p class="alb-artist">${renderArtists(i, album)}</p>
            <p class="alb-genres">${joinedGenres}</p>
          </div>
        </div>

        <hr class="alb-sep">

        <div class="alb-meta">
          <p><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="#f3f3f3" d="M9 2a8 8 0 0 1 7.934 6.965l2.25 3.539c.148.233.118.58-.225.728L17 14.07V17a2 2 0 0 1-2 2h-1.999L13 22H4v-3.694c0-1.18-.436-2.297-1.244-3.305A8 8 0 0 1 9 2m12.154 16.102l-1.665-1.11A8.96 8.96 0 0 0 21 12a8.96 8.96 0 0 0-1.51-4.993l1.664-1.11A10.95 10.95 0 0 1 23 12c0 2.258-.68 4.356-1.846 6.102"/></svg> ${langText}</p>

          <p><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="#f3f3f3" d="M7.75 2.5a.75.75 0 0 0-1.5 0v1.58c-1.44.115-2.384.397-3.078 1.092c-.695.694-.977 1.639-1.093 3.078h19.842c-.116-1.44-.398-2.384-1.093-3.078c-.694-.695-1.639-.977-3.078-1.093V2.5a.75.75 0 0 0-1.5 0v1.513C15.585 4 14.839 4 14 4h-4c-.839 0-1.585 0-2.25.013z"/><path fill="#f3f3f3" fill-rule="evenodd" d="M2 12c0-.839 0-1.585.013-2.25h19.974C22 10.415 22 11.161 22 12v2c0 3.771 0 5.657-1.172 6.828S17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172S2 17.771 2 14zm15 2a1 1 0 1 0 0-2a1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2a1 1 0 0 0 0 2m-4-5a1 1 0 1 1-2 0a1 1 0 0 1 2 0m0 4a1 1 0 1 1-2 0a1 1 0 0 1 2 0m-6-3a1 1 0 1 0 0-2a1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2a1 1 0 0 0 0 2" clip-rule="evenodd"/></svg> ${album.date}</p>

          <p><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill="#f3f3f3" d="M2 1a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v7.256A4.5 4.5 0 0 0 12.5 8a4.5 4.5 0 0 0-3.59 1.787A.5.5 0 0 0 9 9.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .39-.187A4.5 4.5 0 0 0 8.027 12H6.5a.5.5 0 0 0-.5.5V16H3a1 1 0 0 1-1-1zm2 1.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5m3 0v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5m3.5-.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zM4 5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5M7.5 5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zm2.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5M4.5 8a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5z"/><circle cx="12.5" cy="12.5" r="3.5" fill="#f3f3f3"/><path fill="#282626" d="M20.82 6.49v1a3 3 0 0 1-.32 1.34a3 3 0 0 1-.87 1.07a3.1 3.1 0 0 1-1.25.57q-.301.06-.61.06q-.391 0-.77-.09l-4.24-1.2v8.22a4.79 4.79 0 1 1-1.5-3.47V2.46a.6.6 0 0 1 0-.2v-.08a.76.76 0 0 1 .54-.44h.44l6.3 1.79a3 3 0 0 1 2.22 2.93z" transform="translate(9.5 9.5) scale(0.25)"/></svg>
  <span class="label-wrapper">
    ${album.label || "-"}
    <span id="label-cross-${i}" class="blacklist-cross" data-type="label" data-name="${album.label}" style="cursor:pointer;"></span>
  </span>
</p>

          <p><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 48 48"><defs><mask id="ipSTime0"><g fill="none" stroke-linejoin="round" stroke-width="4"><path fill="#fff" stroke="#fff" d="M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z"/><path stroke="#000" stroke-linecap="round" d="M24.008 12v12.01l8.479 8.48"/></g></mask></defs><path fill="#f3f3f3" d="M0 0h48v48H0z" mask="url(#ipSTime0)"/></svg> ${album.duration}</p>
        </div>

        <div class="alb-footer">
          <button class="mark-listened-btn" onclick="markAlbumAsListened('${album.albumID}', this.closest('.album'))">
            ${album.listened ? "   " : "  "}
          </button>
          <span id="listens-${i}" class="alb-listens"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 20 20"><path fill="#f3f3f3" d="M5.312 4.566C4.19 5.685-.715 12.681 3.523 16.918c4.236 4.238 11.23-.668 12.354-1.789c1.121-1.119-.335-4.395-3.252-7.312c-2.919-2.919-6.191-4.376-7.313-3.251m9.264 9.59c-.332.328-2.895-.457-5.364-2.928c-2.467-2.469-3.256-5.033-2.924-5.363c.328-.332 2.894.457 5.36 2.926c2.471 2.467 3.258 5.033 2.928 5.365m.858-8.174l1.904-1.906a.999.999 0 1 0-1.414-1.414L14.02 4.568a.999.999 0 1 0 1.414 1.414M11.124 3.8a1 1 0 0 0 1.36-.388l1.087-1.926a1 1 0 0 0-1.748-.972L10.736 2.44a1 1 0 0 0 .388 1.36m8.748 3.016a1 1 0 0 0-1.36-.388l-1.94 1.061a1 1 0 1 0 .972 1.748l1.94-1.061a1 1 0 0 0 .388-1.36"/></svg> ${formatListens(album.listens)}
</span>
        </div>
      </div>

      <div class="tracks" id="tracks-${i}"></div>
    `;

    const favButton = document.createElement("div");
    favButton.classList.add("favorite-button");
    favButton.innerHTML = `
  <div class="favorite-icon">
    <svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
      <path fill="#84AAFB" d="M34,9c-4.2,0-7.9,2.1-10,5.4C21.9,11.1,18.2,9,14,9C7.4,9,2,14.4,2,21c0,11.9,22,24,22,24s22-12,22-24C46,14.4,40.6,9,34,9z"/>
    </svg>
  </div>
`;

    const checkmark = document.createElement("div");
    checkmark.classList.add("favorite-checkmark");
    checkmark.textContent = "";
    checkmark.style.display = favoriteAlbums[album.albumID] ? "block" : "none";
    favButton.appendChild(checkmark);

    attachTooltip(
      favButton,
      favoriteAlbums[album.albumID]
        ? "   "
        : "   ",
    );

    favButton.addEventListener("click", (e) => {
      e.stopPropagation();

      favButton.classList.add("clicked");
      setTimeout(() => favButton.classList.remove("clicked"), 150);

      if (favoriteAlbums[album.albumID]) {
        delete favoriteAlbums[album.albumID];
        checkmark.style.display = "none";
      } else {
        favoriteAlbums[album.albumID] = true;
        checkmark.style.display = "block";
      }

      localStorage.setItem("favoriteAlbums", JSON.stringify(favoriteAlbums));
      updateFavoritesModal();

      removeTooltip(favButton);
      attachTooltip(
        favButton,
        favoriteAlbums[album.albumID]
          ? "   "
          : "   ",
      );
    });

    albumDiv.appendChild(favButton);

    const spotifyIcon = albumDiv.querySelector(".spotify-icon");
    if (spotifyIcon) attachTooltip(spotifyIcon, "  Spotify");

    const ytIcon = albumDiv.querySelector(".yt-icon");
    if (ytIcon) attachTooltip(ytIcon, "  YouTube Music");

    const appleIcon = albumDiv.querySelector(".apple-icon");
    if (appleIcon) attachTooltip(appleIcon, "  Apple Music");

    if (album.good) {
      const starBox = document.createElement("div");
      starBox.className = "star-box";
      starBox.innerHTML = '<i class="fas fa-star star-icon"></i>';
      attachTooltip(
        starBox,
        "NUAM     ",
        "180px",
      );
      albumDiv.appendChild(starBox);
    }

    const nextAlbum = [...container.children].find((div) => {
      const idx = filteredAlbums.findIndex(
        (a) => a.albumID === div.dataset.albumId,
      );
      return idx > i;
    });

    if (nextAlbum) {
      container.insertBefore(albumDiv, nextAlbum);
    } else {
      container.appendChild(albumDiv);
    }
    albumDiv.querySelector("img").addEventListener("click", function () {
  const thumb = this;
  const imgSrc = thumb.src;
  const opened = document.querySelector(".enlarged-img");
  const modalOverlay = document.getElementById("preview-overlay");

  if (opened) {
    opened.remove();
    modalOverlay.classList.add("hidden");
    document.body.classList.remove("no-scroll");
    const prevTop = parseInt(document.body.style.top || "0") * -1;
    document.body.style.top = "";
    window.scrollTo(0, prevTop);
    return;
  }

  const scrollY = window.scrollY;

  const r = thumb.getBoundingClientRect();
  const startX = r.left;
  const startY = r.top;
  const startW = r.width;
  const startH = r.height;
  const aspect = startW / startH;

  const vw = window.innerWidth, vh = window.innerHeight;
  let targetW = Math.min(640, vw * 0.9);
  let targetH = targetW / aspect;
  if (targetH > vh * 0.9) { targetH = vh * 0.9; targetW = targetH * aspect; }
  const targetX = (vw - targetW) / 2;
  const targetY = (vh - targetH) / 2;

  const enlargedImg = document.createElement("img");
  enlargedImg.src = imgSrc;
  enlargedImg.classList.add("enlarged-img");

  Object.assign(enlargedImg.style, {
    position: "fixed",
    left: "0", top: "0",
    width: startW + "px",
    height: startH + "px",
    transformOrigin: "top left",
    transform: `translate(${startX}px, ${startY}px) scale(1,1)`,
    borderRadius: "0px",
    opacity: "1",
    transition: "transform .35s cubic-bezier(.2,.9,.2,1), opacity .2s ease, border-radius .35s ease"
  });

  document.body.appendChild(enlargedImg);

  modalOverlay.classList.remove("hidden");
  document.body.classList.add("no-scroll");
  document.body.style.top = `-${scrollY}px`;

  requestAnimationFrame(() => {
    const sx = targetW / startW;
    const sy = targetH / startH;
    enlargedImg.style.transform = `translate(${targetX}px, ${targetY}px) scale(${sx}, ${sy})`;
  });

  const closeImg = () => {
    const rr = thumb.getBoundingClientRect();
    const endX = rr.left;
    const endY = rr.top;

const thumbRadius = getComputedStyle(thumb).borderRadius || "8px";
enlargedImg.style.borderRadius = thumbRadius;

enlargedImg.style.transform = `translate(${endX}px, ${endY}px) scale(1,1)`;
modalOverlay.classList.add("hidden");

const cleanup = () => {
  enlargedImg.removeEventListener("transitionend", cleanup);
  requestAnimationFrame(() => {
    enlargedImg.remove();
    document.body.classList.remove("no-scroll");
    document.body.style.top = "";
    window.scrollTo(0, scrollY);
  });
};
enlargedImg.addEventListener("transitionend", cleanup, { once: true });
  };

  enlargedImg.addEventListener("click", closeImg, { once: true });
  modalOverlay.addEventListener("click", closeImg, { once: true });
});

    const tracksContainer = document.getElementById(`tracks-${i}`);

    const playAll = document.createElement("a");
    playAll.classList.add("track-circle", "play-all-toggle");
    playAll.innerHTML = '<i class="fas fa-play"></i>';
    playAll.dataset.albumId = album.albumID;

    attachTooltip(playAll, "   ");

    tracksContainer.appendChild(playAll);

    playAll.addEventListener("click", async () => {
      if (autoPlayingAlbum && autoPlayingAlbum !== album.albumID) {
        const prevBtn = document.querySelector(
          `.play-all-toggle[data-album-id="${autoPlayingAlbum}"]`,
        );
        if (prevBtn) prevBtn.innerHTML = '<i class="fas fa-play"></i>';

        if (prevBtn) {
          removeTooltip(prevBtn);
          attachTooltip(prevBtn, "   ");
        }

        if (currentHighlightedCircle) {
          currentHighlightedCircle.classList.remove("highlight");
          currentHighlightedCircle = null;
        }

        previewPlayer.pause();
        previewPlayer.currentTime = 0;

        const prevTracks = document.querySelector(
          `.album[data-album-id="${autoPlayingAlbum}"] .tracks`,
        );
        if (prevTracks) {
          prevTracks
            .querySelectorAll(".track-circle .progress-fill")
            .forEach((el) => (el.style.width = "0%"));
        }

        previewPlayer.ontimeupdate = null;
      }

      if (autoPlayingAlbum === album.albumID) {
        autoPlayingAlbum = null;
        playAll.innerHTML = '<i class="fas fa-play"></i>';

        removeTooltip(playAll);
        attachTooltip(playAll, "   ");

        togglePreview(true);

        if (currentHighlightedCircle) {
          currentHighlightedCircle.classList.remove("highlight");
          currentHighlightedCircle = null;
        }
        previewPlayer.pause();
        previewPlayer.currentTime = 0;
        previewActivated = false;
        const toggleBtn = document.getElementById("toggle-preview-button");
        if (toggleBtn) {
          toggleBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
        }

        return;
      }

      autoPlayingAlbum = album.albumID;

      togglePreview(false);

      autoPlayIndex = 0;
      playAll.innerHTML = '<i class="fas fa-stop"></i>';

      removeTooltip(playAll);
      attachTooltip(playAll, " ");

      if (!album.tracksInfo) {
        await loadAlbumTracksWithRetry(album);
      }

      function playNext() {
        const container = document.querySelector(
          `.album[data-album-id="${album.albumID}"] .tracks`,
        );
        const btn = document.querySelector(
          `.play-all-toggle[data-album-id="${album.albumID}"]`,
        );
        if (autoPlayingAlbum !== album.albumID) return;

        if (autoPlayIndex >= album.tracksIDs.length) {
          autoPlayingAlbum = null;
          if (btn) btn.innerHTML = '<i class="fas fa-play"></i>';
          if (currentHighlightedCircle) {
            currentHighlightedCircle.classList.remove("highlight");
            currentHighlightedCircle = null;
          }
          return;
        }

        container
          .querySelectorAll(".track-circle .progress-fill")
          .forEach((el) => (el.style.width = "0%"));

        const i = autoPlayIndex;
        const tid = album.tracksIDs[i];
        const hash = album.tracksMP3[i];
        const url = `https://p.scdn.co/mp3-preview/${hash}`;
        const circ = container.querySelector(
          `.track-circle[data-track-id="${tid}"]`,
        );

        if (currentHighlightedCircle)
          currentHighlightedCircle.classList.remove("highlight");
        if (circ) {
          circ.classList.add("highlight");
          currentHighlightedCircle = circ;
        }

        const token = ++playToken;

        previewPlayer.onended = null;
        previewPlayer.onerror = null;
        previewPlayer.ontimeupdate = null;

        const fillEl = circ && circ.querySelector(".progress-fill");
        if (fillEl) {
          previewPlayer.ontimeupdate = () => {
            const dur = previewPlayer.duration || 1;
            fillEl.style.width = (previewPlayer.currentTime / dur) * 100 + "%";
          };
        }

        const probe = new Audio();
        probe.preload = "auto";
        probe.src = url;

        probe.onerror = () => {
          if (token !== playToken || autoPlayingAlbum !== album.albumID) return;
          if (fillEl) fillEl.style.width = "0%";
          markUnavailableCircle(circ);
          autoPlayIndex = i + 1;
          playNext();
        };

        const startPlayback = () => {
          if (token !== playToken || autoPlayingAlbum !== album.albumID) return;

          previewPlayer.src = url;

          previewPlayer.onended = () => {
            if (token !== playToken) return;
            if (fillEl) fillEl.style.width = "0%";
            previewPlayer.ontimeupdate = null;
            autoPlayIndex = i + 1;
            playNext();
          };

          previewPlayer.onerror = () => {
            if (token !== playToken) return;
            if (fillEl) fillEl.style.width = "0%";
            previewPlayer.ontimeupdate = null;
            autoPlayIndex = i + 1;
            playNext();
          };

          previewPlayer.play().catch(() => {});
        };

        probe.oncanplaythrough = startPlayback;
        probe.oncanplay = startPlayback;
      }

      playNext();
      playAll.playNext = playNext;
    });

    album.tracksIDs.forEach((trackID, idx) => {
      const mp3hash = album.tracksMP3[idx] || "";
      if (!trackID || !mp3hash) return;

      const circle = document.createElement("a");
      circle.classList.add("track-circle");
      circle.href = `https://open.spotify.com/track/${trackID}`;
      circle.target = "_blank";
      circle.innerHTML = '<i class="fas fa-music"></i>';

      const fill = document.createElement("div");
      fill.className = "progress-fill";
      circle.appendChild(fill);

      circle.dataset.trackId = trackID;
      circle.dataset.albumId = album.albumID;

      circle.addEventListener("mouseenter", async (e) => {
        if (circle.dataset.unavail === "1") {
          if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
          return;
        }

        if (autoPlayingAlbum !== null) {
          const info = album.tracksInfo && album.tracksInfo[trackID];
          if (info) {
            showSimpleTooltip(
              e.clientX,
              e.clientY,
              `${info.artists.join(", ")}  ${info.name}`,
            );
          }
          return;
        }

        if (!previewActivated) return;

        showSimpleTooltip(e.clientX, e.clientY, " ");
        if (!window._spotifyToken) {
          window._spotifyToken = await getAccessToken();
        }
        if (!album.tracksInfo) {
          await loadAlbumTracksWithRetry(album);
        }
        const info = album.tracksInfo[trackID];
        if (info) {
          showSimpleTooltip(
            e.clientX,
            e.clientY,
            `${info.artists.join(", ")}  ${info.name}`,
          );
        }
      });

      circle.addEventListener("mousemove", (e) => {
        if (circle.dataset.unavail === "1") return;
        moveSimpleTooltip(e.clientX, e.clientY);
      });

      circle.addEventListener("mouseleave", () => {
        hideSimpleTooltip();
        if (previewActivated) {
          previewPlayer.pause();
          previewPlayer.currentTime = 0;
          previewPlayer.removeAttribute("src");
          previewPlayer.load();
        }
      });

      circle.dataset.albumId = album.albumID;
      attachTrackBehavior(circle, `https://p.scdn.co/mp3-preview/${mp3hash}`);

      circle.addEventListener("click", async (evt) => {
        evt.preventDefault();

        document
          .querySelectorAll(".track-circle .progress-fill")
          .forEach((el) => (el.style.width = "0%"));
        previewPlayer.ontimeupdate = null;

        if (autoPlayingAlbum && autoPlayingAlbum !== album.albumID) {
          const prevAlbumId = autoPlayingAlbum;
          autoPlayingAlbum = null;

          const prevBtn = document.querySelector(
            `.album[data-album-id="${prevAlbumId}"] .play-all-toggle`,
          );
          if (prevBtn) {
            prevBtn.innerHTML = '<i class="fas fa-play"></i>';
          }

          if (currentHighlightedCircle) {
            currentHighlightedCircle.classList.remove("highlight");
            currentHighlightedCircle = null;
          }

          previewPlayer.pause();
          previewPlayer.currentTime = 0;
        }

        if (autoPlayingAlbum === album.albumID) {
          const clickedIndex = album.tracksIDs.indexOf(trackID);
          if (clickedIndex >= 0) {
            autoPlayIndex = clickedIndex;

            const hash = album.tracksMP3[autoPlayIndex];
            previewPlayer.src = `https://p.scdn.co/mp3-preview/${hash}`;
            previewPlayer.currentTime = 0;
            previewPlayer.play().catch(() => {});

            if (currentHighlightedCircle) {
              currentHighlightedCircle.classList.remove("highlight");
            }
            const newCirc = tracksContainer.querySelector(
              `.track-circle[data-track-id="${trackID}"]`,
            );
            if (newCirc) {
              newCirc.classList.add("highlight");
              currentHighlightedCircle = newCirc;
            }

            previewPlayer.ontimeupdate = () => {
              const dur = previewPlayer.duration || 1;
              const pct = (previewPlayer.currentTime / dur) * 100;
              const fillEl = newCirc.querySelector(".progress-fill");
              if (fillEl) fillEl.style.width = pct + "%";
            };
          }
          return;
        }

        if (!previewActivated) {
          togglePreview(true);
        }

        previewPlayer.src = `https://p.scdn.co/mp3-preview/${mp3hash}`;
        previewPlayer.currentTime = 0;
        try {
          await previewPlayer.play();
        } catch (e) {
          console.warn("     :", e);
        }

        hideSimpleTooltip();
        showSimpleTooltip(evt.clientX, evt.clientY, " ");

        if (!window._spotifyToken) {
          window._spotifyToken = await getAccessToken();
        }
        if (!album.tracksInfo) {
          await loadAlbumTracksWithRetry(album);
        }
        const info = album.tracksInfo[trackID];
        if (info) {
          showSimpleTooltip(
            evt.clientX,
            evt.clientY,
            `${info.artists.join(", ")}  ${info.name}`,
          );
        }
      });

      tracksContainer.appendChild(circle);
    });

    const listensEl = document.getElementById(`listens-${i}`);
    if (album.listens === 0) {
      attachTooltip(
        listensEl,
        "     1000 ",
        "170px",
      );
    } else {
      attachTooltip(
        listensEl,
        "     ",
        "160px",
      );
    }

    const labelCrossEl = document.getElementById(`label-cross-${i}`);
    if (labelCrossEl) {
      attachTooltip(
        labelCrossEl,
        "    ",
        "160px",
      );
      labelCrossEl.addEventListener("click", function () {
        removeTooltip(labelCrossEl);
        blacklistedLabels.add(album.label);
        localStorage.setItem(
          "blacklistedLabels",
          JSON.stringify([...blacklistedLabels]),
        );
        smoothApplyFilters();
      });
    }

    albumDiv
      .querySelectorAll('.blacklist-cross[data-type="artist"]')
      .forEach((cross) => {
        attachTooltip(cross, "    ", "160px");
        cross.addEventListener("click", () => {
          const artistId = cross.dataset.name;
          removeTooltip(cross);
          blacklistedArtists.add(artistId);
          localStorage.setItem(
            "blacklistedArtists",
            JSON.stringify([...blacklistedArtists]),
          );
          smoothApplyFilters();
        });
      });
  }

  if (autoPlayingAlbum) {
    const playingDiv = document.querySelector(
      `.album[data-album-id="${autoPlayingAlbum}"]`,
    );
    if (playingDiv) {
      const btn = playingDiv.querySelector(".play-all-toggle");
      if (btn) {
        btn.innerHTML = '<i class="fas fa-stop"></i>';
        removeTooltip(btn);
        attachTooltip(btn, " ");
      }

      const trackID = albumsData.find((a) => a.albumID === autoPlayingAlbum)
        .tracksIDs[autoPlayIndex];
      const circ = playingDiv.querySelector(
        `.track-circle[data-track-id="${trackID}"]`,
      );
      if (circ) {
        circ.classList.add("highlight");
        currentHighlightedCircle = circ;

        const fill = circ.querySelector(".progress-fill");
        if (fill) {
          previewPlayer.ontimeupdate = () => {
            const dur = previewPlayer.duration || 1;
            fill.style.width = (previewPlayer.currentTime / dur) * 100 + "%";
          };
        }
      }
    }
  }

  currentIndex = endIndex;
const lazyEl = document.getElementById("lazy-loading");
if (currentIndex < data.length) {
  lazyEl.textContent = " ";
} else if (!isEmptyResult) {
  lazyEl.textContent = "";
}
}

function renderArtists(index, album) {
  const fragment = document.createDocumentFragment();

  album.artistNames.forEach((artist, i) => {
    const wrapper = document.createElement("span");
    wrapper.style.whiteSpace = "nowrap";

    if (artist === "Various Artists") {
      wrapper.appendChild(document.createTextNode(artist));
    } else {
      const artistLink = document.createElement("a");
      artistLink.textContent = artist;
      artistLink.href = `https://open.spotify.com/artist/${album.artistIDs[i] || ""}`;
      artistLink.target = "_blank";
      artistLink.style.color = "#f3f3f3";
      artistLink.style.textDecoration = "none";
      artistLink.style.fontWeight = "bold";
      wrapper.appendChild(artistLink);

      const crossSpan = document.createElement("span");
      crossSpan.id = `artist-cross-${index}-${i}`;
      crossSpan.classList.add("blacklist-cross");
      crossSpan.dataset.type = "artist";
      crossSpan.dataset.name = album.artistIDs[i];
      crossSpan.style.cursor = "pointer";
      crossSpan.textContent = " ";
      wrapper.appendChild(crossSpan);
    }

    fragment.appendChild(wrapper);

    if (i < album.artistNames.length - 1) {
      const comma = document.createElement("span");
      comma.textContent = ", ";
      fragment.appendChild(comma);
    }
  });

  const div = document.createElement("div");
  div.appendChild(fragment);
  return div.innerHTML;
}

function hideAlbum(albumID) {
  const albumDiv = document.querySelector(`.album[data-album-id="${albumID}"]`);
  if (albumDiv) {
    albumDiv.style.transition = "opacity 0.3s";
    albumDiv.style.opacity = "0";
    setTimeout(() => {
      albumDiv.remove();
      updateAlbumCount();
    }, 300);
  }
}

function showAlbum(album) {
  const container = document.getElementById("albums-container");
  const albumDiv = document.createElement("div");
  albumDiv.classList.add("album");
  albumDiv.style.opacity = "0";
  albumDiv.dataset.albumId = album.albumID;
  albumDiv.innerHTML = `
    <div class="album-overlay"></div>
    <img src="https://i.scdn.co/image/ab67616d0000b273${album.cover}" alt="${album.nameAlbum}">
    <div class="album-details">
      <div class="alb-head">
        ${releaseIcon(album.type)}
        <div class="alb-head-txt">
          <h3><a href="https://open.spotify.com/album/${album.albumID}" target="_blank">${album.nameAlbum}</a></h3>
          <p class="alb-artist">${renderArtists(0, album)}</p>
          <p class="alb-genres">${album.genres.map(friendlyGenreLabel).join(", ") || " "}</p>
        </div>
      </div>
      <hr class="alb-sep">
      <div class="alb-meta">
        <p>${album.date}</p>
        <p>${album.label || "-"}</p>
        <p>${album.duration || "-"}</p>
      </div>
    </div>
  `;
  container.appendChild(albumDiv);

  requestAnimationFrame(() => {
    albumDiv.style.transition = "opacity 0.3s";
    albumDiv.style.opacity = "1";
  });
}

function renderReleaseType(t) {
  if (t === "album") return " ";
  if (t === "ep") return "-";
  if (t === "compilation") return "";
  return t;
}

function attachTrackBehavior(circle, trackPreviewUrl) {
  const tipText =
    "   .     .";
  circle.addEventListener("mouseenter", (e) => {
    if (circle.dataset.unavail === "1") {
      if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
      return;
    }

    if (autoPlayingAlbum === circle.dataset.albumId) {
      const albumObj = albumsData.find(
        (a) => a.albumID === circle.dataset.albumId,
      );
      const info =
        albumObj &&
        albumObj.tracksInfo &&
        albumObj.tracksInfo[circle.dataset.trackId];
      if (info) {
        showSimpleTooltip(
          e.clientX,
          e.clientY,
          `${info.artists.join(", ")}  ${info.name}`,
        );
      }
      return;
    }

    if (!previewActivated) {
      showSimpleTooltip(e.clientX, e.clientY, tipText);
    } else {
      const token = Symbol();
      circle._hoverToken = token;

      const probe = new Audio();
      probe.preload = "auto";
      probe.src = trackPreviewUrl;

      const start = () => {
        if (circle._hoverToken !== token) return;
        previewPlayer.src = trackPreviewUrl;
        previewPlayer.onerror = () => {
          if (circle._hoverToken !== token) return;
          markUnavailableCircle(circle);
        };
        previewPlayer.play().catch(() => {});
      };

      probe.onerror = () => {
        if (circle._hoverToken !== token) return;
        markUnavailableCircle(circle);
      };

      probe.oncanplay = start;
      probe.oncanplaythrough = start;
    }
  });

  circle.addEventListener("mousemove", (e) => {
    if (!previewActivated || circle.dataset.unavail === "1") return;
    moveSimpleTooltip(e.clientX, e.clientY);
  });

  circle.addEventListener("mouseleave", () => {
    circle._hoverToken = null;

    hideSimpleTooltip();
    if (previewActivated) {
      previewPlayer.pause();
      previewPlayer.currentTime = 0;
      previewPlayer.removeAttribute("src");
      previewPlayer.load();
    }
  });
}

function markAlbumAsListened(albumID, albumElement, fromModal = false) {
  const album = albumsData.find((a) => a.albumID === albumID);
  if (!album) return;

  if (fromModal) {
    delete listenedAlbums[albumID];
    album.listened = false;
  } else {
    album.listened = !album.listened;
    if (album.listened) {
      listenedAlbums[albumID] = true;
    } else {
      delete listenedAlbums[albumID];
    }
  }

  saveListenedAlbums();
  updateListenedAlbumsModal();

  if (albumElement) {
    const markButton = albumElement.querySelector(".mark-listened-btn");
    markButton.textContent = album.listened
      ? "   "
      : "  ";

    albumElement.classList.toggle("album-listened", album.listened);

    if (hideListened && album.listened) {
      albumElement.style.transition = "opacity 0.3s";
      albumElement.style.opacity = "0";
      setTimeout(() => {
        albumElement.remove();
        forceLazyLoadCheck();
      }, 300);
    } else if (!album.listened && hideListened) {
      const reFiltered = getFilteredAlbums();
      const index = reFiltered.findIndex((a) => a.albumID === albumID);
      if (index === -1) return;

      if (sortOrder === "listens-desc") {
        reFiltered.sort((a, b) => b.listens - a.listens);
      } else {
        reFiltered.sort((a, b) => {
          const da = new Date(a.date);
          const db = new Date(b.date);
          return sortOrder === "asc" ? da - db : db - da;
        });
      }

      const container = document.getElementById("albums-container");
      const allDom = [...container.querySelectorAll(".album")];
      const nextDom = allDom.find((div) => {
        const idx = reFiltered.findIndex(
          (a) => a.albumID === div.dataset.albumId,
        );
        return idx > index;
      });

      const dummy = document.createElement("div");
      container.insertBefore(dummy, nextDom || null);
      const prevIndex = currentIndex;
      currentIndex = index;
      renderAlbums(reFiltered.slice(index, index + 1), false);
      dummy.remove();
      currentIndex = prevIndex;
    }
    return;
  }
  preserveScroll(() => applyFilters());
}

function saveListenedAlbums() {
  for (const key in listenedAlbums) {
    if (!listenedAlbums[key]) {
      delete listenedAlbums[key];
    }
  }
  localStorage.setItem("listenedAlbums", JSON.stringify(listenedAlbums));
}

function showBlacklist(isBlacklist = true) {
  const modal = document.getElementById("blacklist-modal");
  const closeBtn = modal.querySelector(".close");
  modal.style.display = "block";
  closeBtn.onclick = () => {
    modal.style.display = "none";
  };
  window.onclick = (ev) => {
    if (ev.target == modal) {
      modal.style.display = "none";
    }
  };
  if (isBlacklist) {
    document.getElementById("blacklist-tab").click();
  } else {
    document.getElementById("listened-albums-tab").click();
  }
}

(() => {
  const el = document.getElementById("temp-disable-blacklist");
  if (!el) return;

  const blTempContainer = document.querySelector(
    "#blacklist-content .bl-temp-toggle",
  );
  if (blTempContainer) {
    attachTooltip(
      blTempContainer,
      "   ,        .       .",
      "360px",
    );
  }

  el.addEventListener("change", (e) => {
    window.tempIgnoreBlacklist = e.target.checked;
    smoothApplyFilters();
  });
})();

function openTab(evt, tabName) {
  const tablinks = document.querySelectorAll(".tablink");
  const tabcontents = document.querySelectorAll(".tabcontent");
  tabcontents.forEach((tb) => tb.classList.remove("active"));
  tablinks.forEach((ln) => ln.classList.remove("active"));
  document.getElementById(tabName).classList.add("active");
  evt.currentTarget.classList.add("active");

  if (tabName === "blacklist-content") {
    updateBlacklist();
  } else if (tabName === "listened-albums-content") {
    updateListenedAlbumsModal();
  } else if (tabName === "export-content") {
    const dataTextarea = document.getElementById("data-textarea");
    dataTextarea.value = generateExportData();
  } else if (tabName === "favorites-content") {
    updateFavoritesModal();
  }
}

function updateBlacklist() {
  const artistsList = document.getElementById("blacklisted-artists");
  const labelsList = document.getElementById("blacklisted-labels");
  artistsList.innerHTML = "";
  labelsList.innerHTML = "";

  if (blacklistedArtists.size === 0) {
    const msg = document.createElement("p");
    msg.textContent = "    .";
    msg.style.textAlign = "center";
    msg.style.color = "#f3f3f3";
    artistsList.appendChild(msg);
  } else {
    blacklistedArtists.forEach((artistID) => {
      const artistName =
        albumsData.find((a) => a.artistIDs?.includes(artistID))?.artistNames?.[
          albumsData
            .find((a) => a.artistIDs?.includes(artistID))
            ?.artistIDs.indexOf(artistID)
        ] || "Unknown Artist";

      const li = document.createElement("li");
      const sp = document.createElement("span");
      if (artistName !== "Various Artists") {
        const link = document.createElement("a");
        link.href = `https://open.spotify.com/artist/${artistID}`;
        link.target = "_blank";
        link.textContent = artistName;
        link.style.color = "#f3f3f3";
        link.style.textDecoration = "none";
        link.addEventListener(
          "mouseover",
          () => (link.style.textDecoration = "underline"),
        );
        link.addEventListener(
          "mouseout",
          () => (link.style.textDecoration = "none"),
        );
        sp.appendChild(link);
      } else {
        sp.textContent = artistName;
      }
      sp.style.color = "#f3f3f3";

      const removeIcon = document.createElement("span");
      removeIcon.textContent = "";
      removeIcon.classList.add("blacklist-cross");
      removeIcon.addEventListener("click", () => {
        blacklistedArtists.delete(artistID);

        localStorage.setItem(
          "blacklistedArtists",
          JSON.stringify(Array.from(blacklistedArtists)),
        );
        updateBlacklist();

        const albumsContainer = document.getElementById("albums-container");
        smoothApplyFilters();
        forceLazyLoadCheck();
      });

      li.appendChild(sp);
      li.appendChild(removeIcon);
      artistsList.appendChild(li);
    });
  }

  if (blacklistedLabels.size === 0) {
    const msg2 = document.createElement("p");
    msg2.textContent = "    .";
    msg2.style.textAlign = "center";
    msg2.style.color = "#f3f3f3";
    labelsList.appendChild(msg2);
  } else {
    blacklistedLabels.forEach((label) => {
      const li = document.createElement("li");
      const sp = document.createElement("span");
      sp.textContent = label;
      sp.style.color = "#f3f3f3";

      const removeIcon = document.createElement("span");
      removeIcon.textContent = "";
      removeIcon.classList.add("blacklist-cross");
      removeIcon.addEventListener("click", () => {
        blacklistedLabels.delete(label);
        localStorage.setItem(
          "blacklistedLabels",
          JSON.stringify(Array.from(blacklistedLabels)),
        );
        updateBlacklist();

        const albumsContainer = document.getElementById("albums-container");
        smoothApplyFilters();
        forceLazyLoadCheck();
      });

      li.appendChild(sp);
      li.appendChild(removeIcon);
      labelsList.appendChild(li);
    });
  }
}

function updateListenedAlbumsModal() {
  const list = document.getElementById("listened-albums-list");
  list.innerHTML = "";

  const listenedArr = albumsData.filter((al) => al.listened);
  if (listenedArr.length === 0) {
    const msg = document.createElement("p");
    msg.textContent = "     .";
    msg.style.gridColumn = "1 / -1";
    msg.style.textAlign = "center";
    msg.style.color = "#f3f3f3";
    list.appendChild(msg);
  } else {
    listenedArr.forEach((al) => {
      const li = document.createElement("li");
      const a = document.createElement("a");
      const link = `https://open.spotify.com/album/${al.albumID}`;
      a.href = link;
      a.target = "_blank";
      a.textContent = `${al.artistNames.join(", ")}  ${al.nameAlbum}`;
      a.style.cursor = "pointer";

      const removeIcon = document.createElement("span");
      removeIcon.textContent = "";
      removeIcon.classList.add("blacklist-cross");
      removeIcon.style.cursor = "pointer";
      removeIcon.style.marginLeft = "10px";
      removeIcon.addEventListener("click", () => {
        markAlbumAsListened(al.albumID, null, true);
        li.remove();
        forceLazyLoadCheck();
      });

      li.appendChild(a);
      li.appendChild(removeIcon);
      list.appendChild(li);
    });
  }
}

function generateExportData() {
  const obj = {
    blacklistArtists: Array.from(blacklistedArtists),
    blacklistLabels: Array.from(blacklistedLabels),
    listenedAlbums: JSON.parse(localStorage.getItem("listenedAlbums")) || {},
    favoriteAlbums: JSON.parse(localStorage.getItem("favoriteAlbums")) || {},
    albumFilters: JSON.parse(localStorage.getItem("albumFilters")) || {},
    presets: getStoredPresets(),
  };
  return JSON.stringify(obj, null, 2);
}

function removeTooltip(el) {
  if (!el) return;
  try {
    if (el._tooltipCleanup) {
      el._tooltipCleanup();
      el._tooltipCleanup = null;
    }
    if (el._tooltip) {
      el._tooltip.remove();
      el._tooltip = null;
    }
  } catch (_) {}
}

function positionTooltip(x, y, tip) {
  const rect = tip.getBoundingClientRect();
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  let tx = x + 10;
  let ty = y + 10;
  if (tx + rect.width > vw) tx = x - rect.width - 10;
  if (ty + rect.height > vh) ty = y - rect.height - 10;
  tip.style.top = `${ty}px`;
  tip.style.left = `${tx}px`;
}

function preserveScroll(callback) {
  const container = document.getElementById("albums-container");
  const anchor = [...container.children].find(
    (el) => el.getBoundingClientRect().top >= 0,
  );
  const anchorId = anchor?.dataset?.albumId;
  const offset = anchor?.getBoundingClientRect().top || 0;

  callback();

  requestAnimationFrame(() => {
    if (anchorId) {
      const newAnchor = container.querySelector(
        `[data-album-id="${anchorId}"]`,
      );
      if (newAnchor) {
        const newOffset = newAnchor.getBoundingClientRect().top;
        const scrollY = window.scrollY + (newOffset - offset);
        window.scrollTo(0, scrollY);
      }
    }
  });
}

function positionTooltip(x, y, tip) {
  const rect = tip.getBoundingClientRect();
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  let tx = x + 10;
  let ty = y + 10;
  if (tx + rect.width > vw) tx = x - rect.width - 10;
  if (ty + rect.height > vh) ty = y - rect.height - 10;
  tip.style.left = `${tx}px`;
  tip.style.top = `${ty}px`;
}

function attachTooltip(el, text, width) {
  if (!el) return;
  el._tooltipText = text;
  if (width !== undefined) el._tooltipWidth = width;
  if (el._tooltipInited) return;
  el._tooltipInited = true;

  function getScrollableAncestors(node) {
    const arr = [window];
    let n = node.parentNode;
    while (n && n !== document) {
      if (n instanceof Element) {
        const cs = getComputedStyle(n);
        if (
          /(auto|scroll|overlay)/.test(
            cs.overflow + cs.overflowX + cs.overflowY,
          )
        ) {
          arr.push(n);
        }
      }
      n = n.parentNode;
    }
    return arr;
  }

  function hideTip() {
    try {
      if (el._tooltipCleanup) {
        el._tooltipCleanup();
        el._tooltipCleanup = null;
      }
      if (el._tooltip) {
        el._tooltip.remove();
        el._tooltip = null;
      }
    } catch (_) {}
  }

  el.addEventListener("mouseenter", (ev) => {
    if (!el._tooltip) {
      const tip = document.createElement("div");
      tip.className = "tooltip";
      tip.style.position = "fixed";
      tip.style.background = "#28262675";
      tip.style.color = "#f3f3f3";
      tip.style.padding = "5px 10px";
      tip.style.borderRadius = "8px";
      tip.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.3)";
      tip.style.fontSize = "12px";
      tip.style.zIndex = "9999";
      tip.style.pointerEvents = "none";
      tip.style.backdropFilter = "blur(8px) saturate(140%)";
      tip.style.webkitBackdropFilter = "blur(8px) saturate(140%)";

      document.body.appendChild(tip);
      el._tooltip = tip;
    }

    const tip = el._tooltip;
    tip.textContent = el._tooltipText;
    tip.style.maxWidth = el._tooltipWidth || "220px";
    tip.style.visibility = "visible";
    positionTooltip(ev.clientX, ev.clientY, tip);

    const scrollTargets = getScrollableAncestors(el);
    const onScroll = () => hideTip();
    const onPointerDown = () => hideTip();
    const onWheel = () => hideTip();
    const onResize = () => hideTip();
    const onKey = (e) => {
      if (e.key === "Escape") hideTip();
    };
    const onMoveOut = (e) => {
      if (!e.composedPath().includes(el)) hideTip();
    };

    for (const t of scrollTargets) {
      t.addEventListener("scroll", onScroll, { capture: true, passive: true });
    }
    document.addEventListener("pointerdown", onPointerDown, true);
    document.addEventListener("wheel", onWheel, {
      passive: true,
      capture: true,
    });
    window.addEventListener("resize", onResize, true);
    document.addEventListener("keydown", onKey, true);
    document.addEventListener("pointermove", onMoveOut, true);

    let raf = 0;
    const watchHover = () => {
      raf = requestAnimationFrame(() => {
        if (!el.matches(":hover")) hideTip();
        else watchHover();
      });
    };
    watchHover();

    el._tooltipCleanup = () => {
      for (const t of scrollTargets)
        t.removeEventListener("scroll", onScroll, true);
      document.removeEventListener("pointerdown", onPointerDown, true);
      document.removeEventListener("wheel", onWheel, true);
      window.removeEventListener("resize", onResize, true);
      document.removeEventListener("keydown", onKey, true);
      document.removeEventListener("pointermove", onMoveOut, true);
      cancelAnimationFrame(raf);
    };
  });

  el.addEventListener("mousemove", (ev) => {
    const tip = el._tooltip;
    if (tip && tip.style.visibility === "visible") {
      positionTooltip(ev.clientX, ev.clientY, tip);
    }
  });

  el.addEventListener("mouseleave", hideTip);
  el.addEventListener("blur", hideTip);
}

function removeTooltip(el) {
  if (!el) return;
  try {
    if (el._tooltipCleanup) {
      el._tooltipCleanup();
      el._tooltipCleanup = null;
    }
    if (el._tooltip) {
      el._tooltip.remove();
      el._tooltip = null;
    }
  } catch (_) {}
}

let simpleTooltip = null;
let simpleTooltipCleanup = null;

function showSimpleTooltip(x, y, text) {
  if (!simpleTooltip) {
    simpleTooltip = document.createElement("div");
    simpleTooltip.style.position = "fixed";
    simpleTooltip.style.background = "#28262675";
    simpleTooltip.style.color = "#f3f3f3";
    simpleTooltip.style.padding = "5px 10px";
    simpleTooltip.style.borderRadius = "8px";
    simpleTooltip.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.3)";
    simpleTooltip.style.fontSize = "12px";
    simpleTooltip.style.whiteSpace = "normal";
    simpleTooltip.style.maxWidth = "200px";
    simpleTooltip.style.zIndex = "9999";
    simpleTooltip.style.pointerEvents = "none";
    simpleTooltip.style.backdropFilter = "blur(8px) saturate(140%)";
    simpleTooltip.style.webkitBackdropFilter = "blur(8px) saturate(140%)";
    document.body.appendChild(simpleTooltip);
  }

  if (simpleTooltipCleanup) simpleTooltipCleanup();

  simpleTooltip.textContent = text;
  simpleTooltip.style.visibility = "visible";
  positionTooltip(x, y, simpleTooltip);

  const onScroll = () => hideSimpleTooltip();
  const onPointerDown = () => hideSimpleTooltip();
  const onWheel = () => hideSimpleTooltip();
  const onResize = () => hideSimpleTooltip();
  const onKey = (e) => {
    if (e.key === "Escape") hideSimpleTooltip();
  };

  window.addEventListener("scroll", onScroll, { capture: true, passive: true });
  document.addEventListener("pointerdown", onPointerDown, true);
  document.addEventListener("wheel", onWheel, { passive: true, capture: true });
  window.addEventListener("resize", onResize, true);
  document.addEventListener("keydown", onKey, true);

  simpleTooltipCleanup = () => {
    window.removeEventListener("scroll", onScroll, true);
    document.removeEventListener("pointerdown", onPointerDown, true);
    document.removeEventListener("wheel", onWheel, true);
    window.removeEventListener("resize", onResize, true);
    document.removeEventListener("keydown", onKey, true);
    simpleTooltipCleanup = null;
  };
}

function moveSimpleTooltip(x, y) {
  if (simpleTooltip && simpleTooltip.style.visibility === "visible") {
    positionTooltip(x, y, simpleTooltip);
  }
}

function hideSimpleTooltip() {
  if (simpleTooltip) {
    simpleTooltip.style.visibility = "hidden";
  }
  if (simpleTooltipCleanup) {
    simpleTooltipCleanup();
  }
}

function smoothApplyFilters() {
  clearActivePreset();
  isFiltering = true;
  const container = document.getElementById("albums-container");

  window.removeEventListener("scroll", handleScroll);
  container.style.transition = "opacity 0.2s";
  container.style.opacity = "0.3";

  setTimeout(() => {
    preserveScroll(() => applyFilters());

    requestAnimationFrame(() => {
      container.style.opacity = "1";
      isFiltering = false;
      window.addEventListener("scroll", throttle(handleScroll, 200));
    });
  }, 50);
}

function updateFavoritesModal() {
  const list = document.getElementById("favorites-albums-list");
  list.innerHTML = "";
  const favArr = albumsData.filter((al) => favoriteAlbums[al.albumID]);
  if (favArr.length === 0) {
    const msg = document.createElement("p");
    msg.textContent = "     .";
    msg.style.gridColumn = "1 / -1";
    msg.style.textAlign = "center";
    msg.style.color = "#f3f3f3";
    list.appendChild(msg);
  } else {
    favArr.forEach((al) => {
      const li = document.createElement("li");

      const img = document.createElement("img");
      img.src = `https://i.scdn.co/image/ab67616d0000b273${al.cover}`;
      img.alt = al.nameAlbum;

      const a = document.createElement("a");
      a.href = `https://open.spotify.com/album/${al.albumID}`;
      a.target = "_blank";
      a.textContent = `${al.artistNames.join(", ")}  ${al.nameAlbum}`;
      a.style.color = "#f3f3f3";

const removeIcon = document.createElement("span");
removeIcon.textContent = "";
removeIcon.classList.add("blacklist-cross");
removeIcon.style.cursor = "pointer";
removeIcon.addEventListener("click", () => {
  delete favoriteAlbums[al.albumID];
  localStorage.setItem("favoriteAlbums", JSON.stringify(favoriteAlbums));
  updateFavoritesModal();
});

const iconsCol = document.createElement("div");
iconsCol.style.display = "flex";
iconsCol.style.flexDirection = "column";
iconsCol.style.alignItems = "center";
iconsCol.style.justifyContent = "center";
iconsCol.style.gap = "6px";
iconsCol.style.marginLeft = "auto";

const mkBox = () => {
  const box = document.createElement("div");
  box.style.width = "20px";
  box.style.height = "20px";
  box.style.display = "inline-flex";
  box.style.alignItems = "center";
  box.style.justifyContent = "center";
  box.style.position = "relative";
  return box;
};

const removeBox = mkBox();
removeBox.appendChild(removeIcon);

const copyBox = mkBox();
copyBox.style.cursor = "pointer";

const icoCopy = document.createElement("i");
icoCopy.className = "fa-regular fa-copy";
icoCopy.style.fontSize = "16px";
icoCopy.style.color = "#bababa";
icoCopy.style.transition = "color .2s, opacity .2s";
icoCopy.style.position = "absolute";
icoCopy.style.left = "50%";
icoCopy.style.top = "50%";
icoCopy.style.transform = "translate(-50%,-50%)";

const icoCheck = document.createElement("i");
icoCheck.className = "fa-solid fa-check";
icoCheck.style.fontSize = "16px";
icoCheck.style.color = "#3cc16e";
icoCheck.style.opacity = "0";
icoCheck.style.transition = "opacity .2s";
icoCheck.style.position = "absolute";
icoCheck.style.left = "50%";
icoCheck.style.top = "50%";
icoCheck.style.transform = "translate(-50%,-50%)";

copyBox.appendChild(icoCopy);
copyBox.appendChild(icoCheck);

copyBox.addEventListener("mouseenter", () => {
  if (icoCheck.style.opacity === "0") icoCopy.style.color = "#f3f3f3";
});
copyBox.addEventListener("mouseleave", () => {
  if (icoCheck.style.opacity === "0") icoCopy.style.color = "#bababa";
});

const copyTitle = async () => {
  const txt = a.textContent || "";
  let ok = false;
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(txt);
      ok = true;
    }
  } catch(e){}
  if (!ok) {
    const ta = document.createElement("textarea");
    ta.value = txt;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.opacity = "0";
    ta.style.pointerEvents = "none";
    ta.style.setProperty("user-select", "text", "important");
    ta.style.setProperty("-webkit-user-select", "text", "important");
    document.body.appendChild(ta);
    ta.select();
    try { ok = document.execCommand("copy"); } catch(e){}
    document.body.removeChild(ta);
  }

  icoCopy.style.opacity = "0";
  icoCheck.style.opacity = "1";
  setTimeout(() => {
    icoCheck.style.opacity = "0";
    icoCopy.style.opacity = "1";
    icoCopy.style.color = "#bababa";
  }, 1000);
};

copyBox.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  copyTitle();
});

iconsCol.appendChild(removeBox);
iconsCol.appendChild(copyBox); 

li.appendChild(img);
li.appendChild(a);
li.appendChild(iconsCol);
list.appendChild(li);
    });
  }
}

function updateAlbumCount() {
  const el = document.getElementById("album-count");
  if (!el || !Array.isArray(filteredAlbums)) return;

  const sepIndex = filteredAlbums.findIndex((a) => a && a.__separatorType);

  const count = sepIndex === -1 ? filteredAlbums.length : sepIndex;

  el.textContent = String(count);
}

const toggleEditBtn = document.getElementById("toggle-edit-presets");
const presetsWrapper = document.querySelector(".presets-wrapper");
let sortable;

function attachPresetControls() {
  presetsWrapper.querySelectorAll(".preset-item").forEach((btn) => {
    if (!btn.querySelector(".drag-handle")) {
      const handle = document.createElement("div");
      handle.className = "drag-handle";
      btn.appendChild(handle);
    }

    if (!btn.querySelector(".delete-handle")) {
      const del = document.createElement("span");
      del.className = "delete-handle";
      del.textContent = "";
      btn.appendChild(del);
      del.addEventListener("click", (e) => {
        e.stopPropagation();
        showDeleteConfirm(btn);
      });
    }

    if (!btn.querySelector(".edit-name-handle")) {
      const edit = document.createElement("span");
      edit.className = "edit-name-handle";
      edit.textContent = "";
      btn.appendChild(edit);
      edit.addEventListener("click", (e) => {
        e.stopPropagation();
        showRenameModal(btn);
      });
    }
  });
}

toggleEditBtn.addEventListener("click", () => {
  const isEditing = presetsWrapper.classList.toggle("editing");

  toggleEditBtn.classList.toggle("active", isEditing);
  if (isEditing) {
    attachPresetControls();
    sortable = Sortable.create(presetsWrapper, {
      animation: 150,
      handle: ".drag-handle",
      onEnd: () => {
        const newArr = Array.from(presetsWrapper.children).map((b) =>
          JSON.parse(b.dataset.presetJson),
        );
        savePresetsToStorage(newArr);
      },
    });
  } else {
    sortable.destroy();
    presetsWrapper
      .querySelectorAll(".drag-handle, .delete-handle, .edit-name-handle")
      .forEach((el) => el.remove());
  }
});

function showDeleteConfirm(btn) {
  const overlay = document.createElement("div");
  overlay.style =
    "" +
    "position:fixed;top:0;left:0;width:100%;height:100%;" +
    "display:flex;align-items:center;justify-content:center;z-index:2000;" +
    "background: rgba(53, 53, 60, 0.55);" +
    "backdrop-filter: blur(8px) saturate(140%);" +
    "-webkit-backdrop-filter: blur(8px) saturate(140%);" +
    "background-image: var(--grain-bg);" +
    "background-size: 160px 160px;" +
    "background-blend-mode: overlay;";

  const dlg = document.createElement("div");
  dlg.style =
    "" +
    "background:#282626;padding:20px;border-radius:8px;" +
    "color:#f3f3f3;text-align:center;";

  dlg.addEventListener("click", (e) => e.stopPropagation());

  const txt = document.createElement("p");
  txt.textContent = " ?";
  txt.style = "padding:0px 20px 20px 20px;margin:auto;";

  const btnKeep = document.createElement("button");
  btnKeep.textContent = "";
  btnKeep.className = "modal-action keep-btn";
  btnKeep.style = "margin:0 10px;";

  const btnDel = document.createElement("button");
  btnDel.textContent = "";
  btnDel.className = "modal-action delete-btn";
  btnDel.style = "margin:0 10px;";

  function close() {
    document.removeEventListener("keydown", onKey);
    if (overlay.parentNode) document.body.removeChild(overlay);
    document.body.style.overflow = prevOverflow;
  }

  overlay.addEventListener("click", close);
  btnKeep.addEventListener("click", close);

  btnDel.addEventListener("click", () => {
    const cfg = JSON.parse(btn.dataset.presetJson);
    const arr = getStoredPresets().filter((p) => p.name !== cfg.name);
    savePresetsToStorage(arr);
    loadPresetsFromStorage();
    updateRestorePresetUI();
    close();
  });

  dlg.append(txt, btnKeep, btnDel);
  overlay.appendChild(dlg);

  const prevOverflow = document.body.style.overflow || "";
  document.body.style.overflow = "hidden";
  document.body.appendChild(overlay);

  const onKey = (e) => {
    if (e.key === "Escape") close();
  };
  document.addEventListener("keydown", onKey);
}

function showRenameModal(btn) {
  const modal = document.getElementById("edit-name-modal");
  const input = modal.querySelector("#edit-name-input");
  const msg = modal.querySelector("#edit-name-message");
  const save = modal.querySelector("#edit-name-save");
  const descInput = modal.querySelector("#edit-desc-input");

  const cfg = JSON.parse(btn.dataset.presetJson);
  const oldName = cfg.name;
  input.value = oldName;
  msg.textContent = "";
  if (descInput) descInput.value = cfg.desc || "";

  modal.style.display = "block";
  document.body.style.overflow = "hidden";
  input.focus();

  save.onclick = () => {
    const newName = input.value.trim();
    if (!newName) {
      msg.textContent = "  ";
      msg.className = "error";
      setTimeout(() => (msg.textContent = ""), 3000);
      return;
    }

    const presets = getStoredPresets();
    const idx = presets.findIndex((p) => p.name === oldName);
    if (idx >= 0) presets[idx].name = newName;
    const newDesc = (descInput?.value || "").trim().slice(0, 250);
    if (idx >= 0) presets[idx].desc = newDesc || undefined;

    savePresetsToStorage(presets);
    loadPresetsFromStorage();

    modal.style.display = "none";
    document.body.style.overflow = "auto";
  };
}

(() => {
  const modal = document.getElementById("edit-name-modal");
  const content = modal.querySelector(".modal-content");
  modal.querySelector(".close").addEventListener("click", () => {
    modal.style.display = "none";
    document.body.style.overflow = "auto";
  });

  modal.addEventListener("click", (e) => {
    if (!content.contains(e.target)) {
      modal.style.display = "none";
      document.body.style.overflow = "auto";
    }
  });
})();

document.getElementById("stats-button").addEventListener("click", () => {
  if (typeof createStatsModal === "function") createStatsModal();
  if (typeof openStatsModal === "function") openStatsModal();
});

window.createAboutModal = function () {
  if (document.getElementById("about-modal")) return;

  const src = document.getElementById("nuam-about-modal");
  const titleText = src?.querySelector("#nuam-about-title")?.textContent || " ";
  const bodyHtml  = src?.querySelector(".nuam-modal__body")?.innerHTML || "";

  const overlay = document.createElement("div");
  overlay.id = "about-modal";
  overlay.className = "modal hidden";

  overlay.innerHTML = `
    <div class="modal-content">
      <span class="close" id="about-close">&times;</span>
      <h3 style="color:#f3f3f3; margin:0 0 20px;">${titleText}</h3>
      <div class="modal-body" style="overflow:auto; color:#f3f3f3; font-size:16px; margin: -10px 0px -10px 0px;">
        ${bodyHtml}
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  const content = overlay.querySelector(".modal-content");
  const closeX  = overlay.querySelector("#about-close");

  closeX.addEventListener("click", () => {
    overlay.classList.add("hidden");
    document.body.style.overflow = "auto";
  });

  overlay.addEventListener("click", (e) => {
    if (!content.contains(e.target)) {
      overlay.classList.add("hidden");
      document.body.style.overflow = "auto";
    }
  });
};

window.openAboutModal = function () {
  const el = document.getElementById("about-modal");
  if (!el) return;
  el.classList.remove("hidden");
  document.body.style.overflow = "hidden";
};

document.getElementById("ld-about-btn")?.addEventListener("click", () => {
  if (typeof createAboutModal === "function") createAboutModal();
  if (typeof openAboutModal === "function") openAboutModal();
});
    
async function copyExportData() {
  const text = document.getElementById("data-textarea")?.value ?? "";

  try {
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return true;
    }
  } catch (_) {}

  try {
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.opacity = "0";
    ta.style.pointerEvents = "none";
    document.body.appendChild(ta);
    ta.select();
    const ok = document.execCommand("copy");
    document.body.removeChild(ta);
    return ok;
  } catch (_) {
    return false;
  }
}

(function attachExportCopy() {
  const oldBtn = document.getElementById("export-data");
  if (!oldBtn) return;
  const btn = oldBtn.cloneNode(true);
  oldBtn.replaceWith(btn);

  const msgEl = document.getElementById("export-message");

  btn.addEventListener("click", async (e) => {
    e.preventDefault();
    const ok = await copyExportData();
    if (msgEl) {
      msgEl.textContent = ok ? "!" : " ";
      msgEl.className = ok ? "success" : "error";
      setTimeout(
        () => {
          msgEl.textContent = " ";
          msgEl.className = "";
        },
        ok ? 2000 : 4000,
      );
    }
  });
})();

(function isolateWheel() {
  const ROOT = document.scrollingElement || document.documentElement;

  function isScrollable(el) {
    if (!(el instanceof Element)) return false;
    const cs = getComputedStyle(el);
    const canY =
      (cs.overflowY === "auto" ||
        cs.overflowY === "scroll" ||
        cs.overflowY === "overlay") &&
      el.scrollHeight > el.clientHeight + 1;
    const canX =
      (cs.overflowX === "auto" ||
        cs.overflowX === "scroll" ||
        cs.overflowX === "overlay") &&
      el.scrollWidth > el.clientWidth + 1;
    return canY || canX;
  }

  function closestScrollable(start) {
    let el = start;
    while (el && el !== document && el !== ROOT) {
      if (isScrollable(el)) return el;
      el = el.parentNode;
    }
    return null;
  }

  function willScroll(el, dx, dy) {
    if (!el) return false;
    const atTop = el.scrollTop <= 0;
    const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
    if (dy < 0 && atTop) return false;
    if (dy > 0 && atBottom) return false;

    const atLeft = el.scrollLeft <= 0;
    const atRight = el.scrollLeft + el.clientWidth >= el.scrollWidth - 1;
    if (dx < 0 && atLeft) return false;
    if (dx > 0 && atRight) return false;

    return true;
  }

  function isInside(selector, node) {
    while (node && node !== document) {
      if (node instanceof Element && node.matches(selector)) return true;
      node = node.parentNode;
    }
    return false;
  }

  document.addEventListener(
    "wheel",
    function (e) {
      if (e.ctrlKey) return;
      const path = e.composedPath ? e.composedPath() : null;
      const target = path ? path[0] : e.target;

      const scroller = closestScrollable(target);

      if (!scroller) {
        if (isInside(".controls, .modal", target)) e.preventDefault();
        return;
      }

      if (!willScroll(scroller, e.deltaX, e.deltaY)) {
        e.preventDefault();
      }
    },
    { passive: false, capture: true },
  );
})();

  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>

</body>
</html>
