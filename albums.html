<!DOCTYPE html> 
<html lang="ua">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NUAM Albums</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

  <link rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
    @font-face {
  font-family: "CustomFont";
  src: url("https://static.wixstatic.com/ufonts/c77f36_8e332f6e48954416a7131ece2e2fab0f/woff2/file.woff2")
    format("woff2");
}

html,
body {
  font-family: "CustomFont", Arial, sans-serif;
  background-color: #282626;
  margin: 0;
  padding: 0;
}

h1 {
  margin-top: 20px;
  color: #f3f3f3;
}

h4 {
  text-align: center;
  margin-top: 20px;
  color: #f3f3f3;
}

body::-webkit-scrollbar {
  width: 10px;
}
body::-webkit-scrollbar-track {
  background: #282626;
}
body::-webkit-scrollbar-thumb {
  background-color: #383838;
  border-radius: 8px;
  border: 2px solid #282626;
}

body::-webkit-scrollbar-button {
  display: none;
}

body.no-scroll {
  position: fixed;
  width: 100%;
  overflow-y: scroll;
}

:root {
  --grain-bg: url('data:image/svg+xml;utf8,\
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100">\
<filter id="grain">\
<feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" seed="2"/>\
<feColorMatrix type="saturate" values="0"/>\
</filter>\
<rect width="100%" height="100%" filter="url(%23grain)" opacity="0.15"/>\
</svg>');
}

.logo-wrapper {
  position: relative;
  display: inline-block;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  padding: 10px;
  margin-bottom: 10px;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
  transition: border-radius 0.3s ease;
  z-index: 1000;
}

.logo-wrapper:hover {
  border-radius: 8px 8px 0 0;
}

.logo-dropdown {
  z-index: 1001;
}

.logo-row {
  display: flex;
  align-items: center;
  gap: 8px;
  line-height: 35px;
}
.logo-row img {
  height: 35px;
  width: auto;
  display: block;
}
.logo-row a {
  display: flex;
  font-size: 14px;
  align-items: center;
  gap: 8px;
  text-decoration: none;
  color: #f3f3f3;
}
.logo-row a:hover {
  text-decoration: none;
}

.vertical-sep {
  width: 1px;
  height: 31px;
  background: #555;
}

#app-logo {
  background-image: var(--nuam-logo-url);
  background-repeat: no-repeat;
  background-size: contain;
}

.logo-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  width: 100%;
  box-sizing: border-box;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 0 0 8px 8px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  overflow: hidden;
  max-height: 0;
  opacity: 0;
  transition:
    max-height 0.3s ease,
    opacity 0.3s ease,
    transform 0.3s ease;
  z-index: 100;
  padding: 0 10px 10px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

.logo-wrapper:hover .logo-dropdown {
  max-height: 200px;
  opacity: 1;
  transform: translateY(0);
}

.logo-row a {
  position: relative;
  overflow: hidden;
}

.logo-row a img {
  position: relative;
  z-index: 1;
  transition: opacity 0.3s ease;
}

.logo-row a::after {
  content: "";
  position: absolute;
  inset: 0;
  z-index: 2;
  opacity: 0;
  transition: opacity 0.3s ease;
  pointer-events: none;
  background: linear-gradient(135deg, #84aafb, #90ee90);
  mask-size: contain;
  mask-repeat: no-repeat;
  mask-position: left center;
  -webkit-mask-size: contain;
  -webkit-mask-repeat: no-repeat;
  -webkit-mask-position: left center;
}

.logo-row a:hover::after {
  opacity: 1;
}

.logo-row:first-child a::after {
  mask-image: var(--mask-logo-main);
  -webkit-mask-image: var(--mask-logo-main);
  background: linear-gradient(1deg, #cdd28d, #89bfd0);
}

.logo-dropdown .logo-row:nth-child(1) a::after {
  mask-image: var(--mask-logo-1);
  -webkit-mask-image: var(--mask-logo-1);
  background: linear-gradient(1deg, #cdd28d, #89bfd0);
}

.logo-dropdown .logo-row:nth-child(2) a::after {
  mask-image: var(--mask-logo-2);
  -webkit-mask-image: var(--mask-logo-2);
  background: linear-gradient(1deg, #cdd28d, #89bfd0);
}

.logo-dropdown .logo-row:nth-child(3) a::after {
  mask-image: var(--mask-logo-3);
  -webkit-mask-image: var(--mask-logo-3);
  background: linear-gradient(1deg, #cdd28d, #89bfd0);
}

.logo-row a:hover img {
  opacity: 0;
}

#loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #282626;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  opacity: 1;
  transition: opacity 0.6s ease;
}

#loading-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

#loading-screen img {
  max-width: 50%;
  margin-bottom: 20px;
}

#csv-loading {
  margin-top: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: stretch;
  min-width: 260px;
  max-width: 520px;
  background: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
  border-radius: 8px;
  padding: 20px 20px;
  color: #f3f3f3;
}
#csv-loading-title {
  font-size: 14px;
}
#csv-loading-bar {
  height: 10px;
  border-radius: 4px;
  background: #282626;
  overflow: hidden;
}
#csv-loading-fill {
  width: 0%;
  height: 100%;
  background: rgba(132, 170, 251, 0.8);
  transition: width 0.1s linear;
}
#csv-loading-info {
  font-size: 12px;
  color: #bababa;
  display: flex;
  justify-content: space-between;
  gap: 10px;
}

.loading-text {
  color: #f3f3f3;
  font-size: 18px;
  margin-top: 20px;
  font-family: "CustomFont", sans-serif;
}

#genre-checkboxes::-webkit-scrollbar {
  width: 8px;
}
#genre-checkboxes::-webkit-scrollbar-track {
  background: transparent;
}
#genre-checkboxes::-webkit-scrollbar-thumb {
  background-color: #282626;
  border-radius: 8px;
  border: 1px solid transparent;
}

input[type="checkbox"] {
  width: 20px;
  height: 20px;
  margin: 5px 5px 5px 5px;
  cursor: pointer;
  appearance: none;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 4px;
  background-color: transparent;
  display: inline-block;
  position: relative;
  vertical-align: middle;
  margin-right: 10px;
  transition: border-color 0.3s ease;
}
input[type="checkbox"]:hover {
  border-color: rgba(132, 170, 251, 1);
}
input[type="checkbox"]:checked {
  background: rgba(132, 170, 251, 0.2);
  border-color: #84aafb;
}
input[type="checkbox"]:checked::after {
  content: "\2713";
  color: #f3f3f3;
  font-size: 12px;
  font-weight: bold;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

#albums-container .separator {
  grid-column: 1 / -1;
  display: flex;
  align-items: center;
  margin: 20px 0 20px;
  box-sizing: border-box;
}

#albums-container .separator .line {
  flex: 1;
  height: 2px;
  background-color: #383636;
  border: none;
}

#albums-container .separator .sep-text {
  margin: 0 10px;
  color: #f3f3f3;
  white-space: nowrap;
}

#genre-checkboxes {
  overflow-y: auto;
  display: grid;
  grid-template-columns: repeat(2, 1fr);
}

.controls {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  width: 460px;
  min-width: 260px;
  min-width: 0;
  position: fixed;
  top: 10px;
  bottom: 10px;
  left: 5px;
  padding: 10px 10px 10px 10px;
  overflow-y: auto;
  background: #282626;
  border-radius: 8px;
  border: 1px solid rgba(53, 53, 60, 0.55);
  background-clip: padding-box;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  z-index: 1000;
  user-select: none !important;
}

.controls::-webkit-scrollbar {
  width: 10px;
}
.controls::-webkit-scrollbar-track {
  background: transparent;
  margin: 5px 0;
}
.controls::-webkit-scrollbar-thumb {
  background: #383838;
  border-radius: 8px;
  border: 2px solid #282626;
}

.bottom-controls {
  margin-top: auto;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

label[for="nuam-recommended-checkbox"] {
  font-size: 14px;
}

.filter-section {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
  margin-bottom: 20px;
}

.filter-group {
  display: flex;
  flex-direction: row;
  gap: 10px;
  width: 100%;
  align-items: stretch;
}
.filter-group .checkbox-container {
  flex: 1;
  min-width: 0;
}

.checkbox-container {
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  padding: 5px;
  display: flex;
  flex-direction: column;
  gap: 5px;
  max-height: 200px;
  overflow: hidden;
  position: relative;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}
.checkbox-container label {
  display: inline-flex;
  align-items: center;
  gap: 5px;
  color: #f3f3f3;
}
.checkbox-container .section-title {
  position: sticky;
  top: 0;
  z-index: 10;
  background: #282626;
  font-size: 16px;
  text-align: left;
  color: #f3f3f3;
  border-radius: 8px;
}
.checkbox-grid {
  display: flex;
  flex-direction: column;
}

.genre-name,
.language-name,
.release-type-filter-item {
  font-size: 14px;
}
.genre-count,
.language-count {
  color: gray;
  font-size: 12px;
}

.sort-and-blacklist {
  display: flex;
  flex-direction: column;
  gap: 10px;
  width: 100%;
}
.sort-section {
  display: flex;
  gap: 10px;
  align-items: center;
}
#sort-order {
  cursor: pointer;
}
.sort-section select {
  width: 100%;
}
.sort-section label {
  flex-shrink: 0;
  white-space: nowrap;
}

.sort-section .custom-select {
  flex-grow: 1;
}

.custom-select.upward .options-container {
  top: auto;
  bottom: 100%;
  border-radius: 8px 8px 0 0;
  width: calc(100% + 2px);
}
.custom-select.upward.open {
  border-radius: 0 0 8px 8px;
}

.hide-listened-section {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 5px 5px 5px 5px;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  justify-content: flex-start;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

.hide-listened-section label {
  align-items: center;
  gap: 8px;
}

.album-count {
  color: #f3f3f3;
  padding-bottom: 20px;
}

.blacklist-row {
  display: flex;
  gap: 10px;
  align-items: center;
}

.blacklist-row .blacklist-section {
  flex: none;
}

.blacklist-row .hide-listened-section {
  flex: 1;
  height: 37px;
  background-color: #383838;
  display: flex;
  align-items: center;
  padding: 0 10px;
  border-radius: 8px;
  gap: 8px;
}

#show-listened-albums {
  cursor: pointer;
  text-decoration: underline;
}

.release-column {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.release-column .checkbox-container {
  flex: none;
}

.release-column .hide-listened-section {
  margin-top: auto;
  display: flex;
  align-items: center;
  padding: 5px 10px 5px 5px;
  border-radius: 8px;
  gap: 8px;
}

.blacklist-container {
  display: flex;
  gap: 20px;
}
.blacklist-artists,
.blacklist-labels {
  flex: 1;
  max-height: 300px;
  overflow: hidden;
  background-color: #282626;
  border-radius: 8px;
}

.blacklist-artists h4,
.blacklist-labels h4 {
  position: sticky;
  top: 0;
  background-color: #282626;
  padding: 10px;
  margin: 0;
  border-radius: 8px;
  z-index: 1;
}
.blacklist-artists ul,
.blacklist-labels ul {
  list-style-type: none;
  padding: 0;
  margin-top: 0px;
  margin-bottom: 0px;
  color: #f3f3f3;
}
.blacklist-artists li,
.blacklist-labels li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px;
}

.blacklist-section {
}

.blacklist-artists.checkbox-container,
.blacklist-labels.checkbox-container {
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

.blacklist-artists.checkbox-container ul,
.blacklist-labels.checkbox-container ul {
  flex: 1;
  overflow-y: auto;
}

.favorite-button {
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 11;
  cursor: pointer;
  padding: 5px;
  border-radius: 8px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  opacity: 0;
  transition:
    opacity 0.3s ease,
    transform 0.1s ease,
    border-color 0.3s ease;
  pointer-events: none;
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}
.favorite-button:hover {
  border-color: rgba(132, 170, 251, 1);
}

.album:hover .favorite-button {
  opacity: 1;
  transform: none;
  pointer-events: auto;
}

.favorite-button.clicked .favorite-icon {
  transform: scale(1.15);
}

.favorite-checkmark {
  position: absolute;
  top: 55%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 14px;
  color: #282626;
  font-weight: bold;
  display: none;
  z-index: 12;
  pointer-events: none;
}

.favorite-button svg {
  width: 100%;
  height: 100%;
}

.search-wrapper {
  display: flex;
  flex-direction: column;
  gap: 10px;
  flex-grow: 1;
  min-width: 0;
}

.search-buttons-column {
  display: flex;
  flex-direction: column;
  gap: 9px;
  width: 100%;
}

.search-buttons-column button {
  width: 100%;
  height: 23px;
  color: #f3f3f3;
  border-radius: 8px;
  font-size: 14px;
  font-family: "CustomFont";
  cursor: pointer;
  transition: border-color 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  padding: 0;
}

.search-buttons-column button:hover {
  border-color: rgba(132, 170, 251, 1);
}

#search-container {
  display: none;
  align-items: center;
  gap: 5px;
  width: 100%;
  padding: 0px 0px 15px 0px;
}

#search-input,
#preset-name-input,
#edit-name-input {
  flex-grow: 1;
  padding: 10px 5px 10px 10px;
  border-radius: 8px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  width: 100%;
  font-family: "CustomFont";
  background: #282626;
  color: #f3f3f3;
  transition: border 0.3s ease;
}
#preset-name-input,
#edit-name-input {
  width: 200px;
}
#search-input:focus,
#preset-name-input:focus {
  outline: none;
  box-shadow: none;
}
#search-input:hover,
#preset-name-input:hover,
#edit-name-input:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

input:-webkit-autofill,
input:-webkit-autofill:hover,
input:-webkit-autofill:focus,
input:-webkit-autofill:active {
  font-family: "CustomFont" !important;
  -webkit-text-fill-color: #f3f3f3 !important;
  box-shadow: 0 0 0px 1000px #282626 inset !important;
  border: 1px solid #84aafb !important;
}

#search-close {
  padding: 5px;
  border: none;
  background: none;
  color: #bababa;
  font-size: 16px;
  cursor: pointer;
  flex-shrink: 0;
  transition: color 0.3s ease;
}
#search-close:hover {
  color: #f3f3f3;
}

.tri-toggle {
  display: flex;
  gap: 5px;
  align-items: center;
  flex-shrink: 0;
  padding: 6px 5px 6px 5px;
  border-radius: 8px;
  background: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
  box-sizing: border-box;
}
.tri-toggle button {
  height: 28px;
  width: 28px;
  padding: 0 10px;
  border-radius: 8px;
  background: transparent;
  color: #f3f3f3;
  cursor: pointer;
  border: 1px solid rgba(132, 170, 251, 0.5);
  font-family: "CustomFont", Arial, sans-serif;
  font-size: 12px;
  line-height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition:
    border-color 0.2s,
    background-color 0.2s;
  white-space: nowrap;
}
.tri-toggle button:hover {
  border-color: rgba(132, 170, 251, 1);
}
.tri-toggle button.active {
  border-color: rgba(132, 170, 251, 1);
  background-color: rgba(132, 170, 251, 0.2);
}

#filters-container {
  display: flex;
  align-items: center;
  gap: 10px;
  width: 100%;
  padding: 0 0 15px 0;
  box-sizing: border-box;
  position: relative;
  min-width: 0;
  overflow-x: hidden;
}

#filters-container::-webkit-scrollbar {
  height: 8px;
}
#filters-container::-webkit-scrollbar-thumb {
  background: #383838;
  border-radius: 8px;
  border: 2px solid #282626;
}

#filters-container::before {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  left: 100px;
  width: 50px;
  pointer-events: none;
  background: linear-gradient(
    to right,
    rgba(40, 38, 38, 1) 0%,
    rgba(40, 38, 38, 0) 100%
  );
  opacity: 0;
  transition: opacity 0.2s ease;
  z-index: 10;
}

#filters-container::after {
  content: "";
  position: absolute;
  top: 0;
  bottom: 0;
  right: 28px;
  width: 50px;
  pointer-events: none;
  background: linear-gradient(
    to left,
    rgba(40, 38, 38, 1) 0%,
    rgba(40, 38, 38, 0) 100%
  );
  z-index: 10;
  opacity: 0;
  transition: opacity 0.2s ease;
}

#filters-container.scrolled-right::after {
  opacity: 1;
}

#filters-container.scrolled::before {
  opacity: 1;
}

.presets-wrapper {
  display: flex;
  gap: 10px;
  padding-right: 16px;
  white-space: nowrap;
  overflow-x: auto;
  flex: 1 1 0;
  max-width: 340px !important;
  min-width: 0;
  position: relative;
  scrollbar-width: none;
  -ms-overflow-style: none;
  scroll-behavior: smooth;
  overscroll-behavior: contain;
}

.presets-wrapper::-webkit-scrollbar {
  display: none;
}

.preset-item {
  flex: 0 0 auto;
}

#filters-container .preset-item {
  flex: 0 0 auto;
  height: 40px;
  padding: 0 15px;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  font-size: 14px;
  font-family: "CustomFont", Arial, sans-serif;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: border-color 0.3s ease;
  white-space: nowrap;
}
#filters-container .preset-item:hover {
  border-color: rgba(132, 170, 251, 1);
}
#filters-container .preset-item.preset-active {
  border-color: rgba(132, 170, 251, 1);
  background-color: rgba(132, 170, 251, 0.2);
}

#filters-container #add-preset {
  flex: none;
  width: 40px;
  height: 40px;
  font-size: 24px;
  font-weight: bold;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 50%;
  transition: border-color 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}
#filters-container #add-preset:hover {
  border-color: rgba(132, 170, 251, 1);
}

#filters-close {
  background: none;
  border: none;
  color: #bababa;
  font-size: 16px;
  cursor: pointer;
  transition: color 0.3s ease;
  flex-shrink: 0;
  margin-left: auto;
  margin-right: 5px;
  padding: 0;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
}
#filters-close:hover {
  color: #f3f3f3;
}

.listened-albums-container {
  max-height: 300px;
  overflow-y: auto;
  padding: 0px 10px 10px 0px;
  border-radius: 8px;
}
.listened-albums-container ul {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
  list-style-type: none;
  padding: 0;
  margin: 0;
  color: #f3f3f3;
}
.listened-albums-container li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 10px;
  border-radius: 8px;
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}
.listened-albums-container a {
  color: #f3f3f3;
  text-decoration: none;
}
.listened-albums-container a:hover {
  text-decoration: underline;
}
.listened-albums-container .blacklist-cross {
  cursor: pointer;
  color: #c0392b;
  font-size: 16px;
  transition: color 0.3s ease;
}
.listened-albums-container .blacklist-cross:hover {
  color: #e74c3c;
}
.listened-albums-container::-webkit-scrollbar {
  width: 8px;
}
.listened-albums-container::-webkit-scrollbar-track {
  background: #282626;
}
.listened-albums-container::-webkit-scrollbar-thumb {
  background: #383838;
  border-radius: 8px;
}

label,
select,
button {
  color: #f3f3f3;
}

.button-group {
  display: flex;
  gap: 10px;
  margin-top: 10px;
}
.button-group button {
  flex: 1;
}

.custom-select {
  position: relative;
  width: 100%;
  background-color: rgba(53, 53, 60, 0.55);
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  font-family: "CustomFont", Arial, sans-serif;
  user-select: none;
  transition: border-color 0.3s ease;
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
}
.custom-select:hover {
  border-color: rgba(132, 170, 251, 1);
}

.custom-select.open {
  border-radius: 8px 8px 0 0;
  border: 1px solid rgba(132, 170, 251, 1);
}

.custom-select,
.custom-select .options-container {
  box-sizing: border-box;
  width: 100%;
}

.custom-select .selected {
  padding: 5px 5px 5px 10px;
  cursor: pointer;
  color: #f3f3f3;
  font-size: 14px;
  transition: border-radius 0.2s ease;
  background-clip: padding-box;
  border-radius: 8px;
}

.custom-select .selected {
  position: relative;
  padding-right: 28px;
}

.custom-select .selected::after {
  content: "";
  position: absolute;
  top: 50%;
  right: 8px;
  width: 12px;
  height: 12px;
  transform: translateY(-50%);
  pointer-events: none;
  opacity: 0.8;
  background: no-repeat center / contain
    url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24"><path d="M7 9l5-5 5 5" fill="none" stroke="%2384aafb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M7 15l5 5 5-5" fill="none" stroke="%2384aafb" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
}

.custom-select.open .selected::after {
  opacity: 0;
}

.custom-select.open:not(.upward) .selected {
  background-color: #282626;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

.custom-select.upward.open .selected {
  background-color: #282626;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

.custom-select .options-container {
  position: absolute;
  top: 100%;
  left: -1px;
  width: calc(100% + 2px);
  border-top: none;
  border-left: 1px solid rgba(132, 170, 251, 1);
  border-right: 1px solid rgba(132, 170, 251, 1);
  border-bottom: 1px solid rgba(132, 170, 251, 1);
  border-radius: 0 0 8px 8px;
  font-size: 14px;
  display: none;
  flex-direction: column;
  z-index: 10;
  overflow: hidden;
}

.custom-select.upward .options-container {
  top: auto;
  bottom: 100%;
  border-top: 1px solid rgba(132, 170, 251, 1);
  border-bottom: none;
  border-left: 1px solid rgba(132, 170, 251, 1);
  border-right: 1px solid rgba(132, 170, 251, 1);
  border-radius: 8px 8px 0 0;
  width: calc(100% + 2px);
}

.custom-select .option {
  padding: 5px 5px 5px 10px;
  cursor: pointer;
  color: #f3f3f3;
}

.custom-select .option:hover {
  background-color: #282626;
}

button {
  padding: 10px 10px;
  background-color: rgba(132, 170, 251, 0.2);
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0);
  border-radius: 8px;
  cursor: pointer;
  transition: border 0.3s ease;
}
button:hover {
  border: 1px solid #84aafb;
}

#reset-filters-btn {
  background-color: rgba(53, 53, 60, 0.1);
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  width: 28px;
  height: 28px;
  font-size: 16px;
  line-height: 1;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0;
  margin-left: 6px;
  cursor: pointer;
  transition:
    border 0.3s ease,
    background-color 0.3s ease;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

#reset-filters-btn:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

.modal-content #preset-save,
.modal-content #edit-name-save,
.keep-btn,
.delete-btn {
  padding: 10px 20px;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  font-size: 14px;
  transition: border 0.3s ease;
}
.modal-content #preset-save,
.modal-content #edit-name-save {
  width: 100px;
}
.modal-content #preset-save:hover,
.modal-content #edit-name-save:hover,
.keep-btn:hover,
.delete-btn:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

.delete-btn {
  border: 1px solid rgba(192, 57, 43, 0.5);
}
.delete-btn:hover {
  border: 1px solid rgba(192, 57, 43, 1);
}

#preset-save-message.error {
  color: #e74c3c;
  font-size: 13px;
  margin-left: 10px;
}

#albums-container {
  position: relative;
  margin-left: 480px;
  padding: 20px 20px 80px 20px;
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
  gap: 20px;
  user-select: none !important;
  align-items: start;
}

.album {
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  overflow: visible;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  position: relative;
  display: flex;
  flex-direction: column;
  min-width: 400px;
  max-width: 500px;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
}

.album img {
  width: 100%;
  height: auto;
  cursor: pointer;
  border-radius: 8px 8px 0px 0px;
  transition:
    transform 0.3s ease,
    z-index 0.3s ease,
    border-radius 0.3s ease;
  backface-visibility: hidden;
  transform-style: preserve-3d;
  will-change: transform, border-radius;
}

.album img:hover {
  transform: scale(1.01);
  z-index: 10;
  border-radius: 8px;
}

.album-details {
  padding: 15px;
  flex-grow: 1;
}
.album-details h3 {
  margin: 0 0 10px 0;
  color: #f3f3f3;
}
.album-details p {
  margin: 5px 0;
  color: #f3f3f3;
}
.album-details a {
  color: #f3f3f3;
  text-decoration: none;
  font-weight: bold;
}
.album-details a:hover {
  text-decoration: underline;
}

.album .album-links {
  display: flex;
  gap: 6px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.album:hover .album-links {
  opacity: 1;
}

.album .album-links a {
  display: flex;
  width: 20px;
  height: 20px;
  position: relative;
}

.album .album-links .icon-default,
.album .album-links .icon-hover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.album .album-links .icon-hover {
  opacity: 0;
  transition: opacity 0.2s ease;
}

.album .album-links a:hover .icon-hover {
  opacity: 1;
}

.album .album-links a:hover .icon-default {
  opacity: 0;
}

.spotify-icon {
  flex-shrink: 0;
}

.album a .spotify-icon {
  display: flex;
  width: 20px;
  height: 20px;
  position: relative;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.album:hover a .spotify-icon {
  opacity: 1;
}

.album a .spotify-icon .icon-default,
.album a .spotify-icon .icon-hover {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.album a .spotify-icon .icon-hover {
  opacity: 0;
  transition: opacity 0.2s ease;
}

.album a .spotify-icon:hover .icon-hover {
  opacity: 1;
}

.album a .spotify-icon:hover .icon-default {
  opacity: 0;
}

.favorite-icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 28px;
  height: 28px;
  transition: transform 0.15s ease;
}

.favorite-icon-wrapper {
  position: absolute;
  top: 10px;
  left: 10px;
  font-size: 24px;
  z-index: 11;
  display: none;
}

.album:hover .favorite-icon-wrapper {
  display: block;
}

.favorite-icon-wrapper svg {
  width: 24px;
  height: 24px;
  cursor: pointer;
}

.tracks {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-top: auto;
  padding: 0 15px 15px;
  align-items: flex-start;
}

.track-circle {
  width: 40px;
  height: 40px;
  color: #f3f3f3;
  background-color: transparent;
  border-radius: 50%;
  border: 1px solid rgba(132, 170, 251, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  text-decoration: none;
  transition:
    background-color 0.3s ease,
    border-color 0.3s ease;
  position: relative;
  overflow: hidden;
}

.track-circle:hover {
  background-color: #282626;
  border-color: rgba(132, 170, 251, 1);
}
.track-circle i {
  font-size: 20px;
  color: #bababa;
  z-index: 1;
}
.track-circle .progress-fill {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 0%;
  background: rgba(132, 170, 251, 0.5);
  pointer-events: none;
  transition: width 0.1s linear;
}

.lazy-loading {
  text-align: center;
  margin: 0px 0px 100px 100px;
  margin-left: 480px;
  width: calc(100% - 480px);
  color: #f3f3f3;
  user-select: none !important;
}

audio {
  display: none;
}

.album-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(40, 38, 38, 0.7);
  display: none;
  pointer-events: none;
  z-index: 1;
}
.album-listened .album-overlay {
  display: block;
}
.album-listened img:hover {
  background-color: rgba(40, 38, 38, 0.7);
  border-radius: 0px !important;
  transform: none !important;
  z-index: auto !important;
}

.mark-listened-btn {
  cursor: pointer;
  padding: 5px 10px;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  align-self: flex-start;
  transition: border 0.3s ease;
  z-index: 9;
  transition: border-color 0.3s ease;
}
.mark-listened-btn:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

.enlarged-img {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 640px;
  z-index: 1000;
  cursor: pointer;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  user-select: none !important;
  opacity: 0;
  transition: opacity 0.3s ease;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
}
.enlarged-img.shown {
  opacity: 1;
}

.modal {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(53, 53, 60, 0.55);
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
  z-index: 2000;
}

.modal.hidden {
  display: none;
}

.modal-content {
  background-color: #282626;
  margin: 200px auto 0 auto;
  padding: 20px;
  border-radius: 8px;
  width: 1064px;
  user-select: none !important;
}

#preset-modal .modal-content {
  width: 520px;
  font-size: 14px;
}
#preset-modal .modal-content > #preset-name-input,
#preset-modal .modal-content > #preset-save,
#preset-modal .modal-content > #preset-desc-input,
#edit-name-modal .modal-content > #edit-name-input,
#edit-name-modal .modal-content > #edit-name-save,
#edit-name-modal .modal-content > #edit-desc-input {
  display: inline-block;
  vertical-align: middle;
  margin: 0;
}

#preset-modal .modal-content > #preset-name-input {
  margin-right: 10px;
}

#preset-name-input {
  width: 200px;
  flex: 0 0 auto;
}

#preset-modal .modal-content,
#edit-name-modal .modal-content {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  margin: 0;
}

#preset-name-input,
#preset-desc-input,
#edit-name-input,
#edit-desc-input {
  box-sizing: border-box;
}

.preset-actions-row {
  display: flex;
  align-items: center;
}

.preset-separator {
  border: none;
  border-top: 1px solid #555;
  margin: 20px 0;
}

.preset-restore-row {
  display: flex;
  justify-content: flex-start;
}

#preset-restore {
  height: 40px;
  padding: 10px 20px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  background: transparent;
  color: #f3f3f3;
  font-size: 14px;
  cursor: pointer;
  transition:
    border-color 0.3s ease,
    opacity 0.3s ease !important;
}

#preset-restore:hover {
  border-color: rgba(132, 170, 251, 1);
}

#preset-modal .preset-separator,
#preset-modal #preset-restore {
  display: none;
}

#preset-restore-msg {
  margin-left: 15px;
  margin-top: 10px;
  margin-bottom: -10px;
  color: #7dc77d;
  opacity: 0;
  transition: opacity 0.35s ease;
}

.preset-restore-row.show-msg #preset-restore-msg {
  opacity: 1;
}

.preset-restore-row.fade-out > * {
  opacity: 0;
  transition: opacity 0.35s ease;
}

#preset-modal .preset-separator.fade-out {
  opacity: 0;
  transition: opacity 0.35s ease;
}

.tabcontent {
  display: none;
}
.tabcontent.active {
  display: block;
}
.tablink {
  background-color: rgba(132, 170, 251, 0.2);
  color: #f3f3f3;
  padding: 10px 20px;
  border: 1px solid rgba(132, 170, 251, 0);
  cursor: pointer;
  transition:
    border-color 0.3s ease,
    background-color 0.3s ease;
  font-weight: bold;
  margin-bottom: 20px;
  margin-right: 10px;
}
.tablink.active {
  background-color: rgba(132, 170, 251, 0.2);
  border-color: rgba(132, 170, 251, 1);
  color: #f3f3f3;
}
.tablink.active:hover {
  border-color: rgba(132, 170, 251, 1);
}
.tablink:hover {
  background-color: rgba(132, 170, 251, 0.2);
  border-color: rgba(132, 170, 251, 1);
}

.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
  transition: color 0.3s ease;
}
.close:hover,
.close:focus {
  color: #f3f3f3;
  text-decoration: none;
  cursor: pointer;
}

.album-details .blacklist-cross {
  display: none;
}
.album-details:hover .blacklist-cross {
  display: inline;
}
.blacklist-cross {
  cursor: pointer;
  color: #c0392b;
  font-size: 11px;
  font-weight: bold;
  transition: color 0.3s ease;
  padding-right: 2px;
}
.blacklist-cross:hover {
  color: #e74c3c;
}

.export-import-container {
  display: flex;
  gap: 20px;
  justify-content: space-between;
}
.export-section,
.import-section {
  flex: 1;
}

textarea {
  width: 500px;
  height: 200px;
  padding: 10px;
  background-color: #282626;
  border-radius: 8px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  resize: none;
  color: #f3f3f3;
  scrollbar-width: auto;
  scrollbar-color: auto;
  transition: border-color 0.3s ease;
}
textarea:hover {
  border-color: rgba(132, 170, 251, 1);
}
textarea::-webkit-scrollbar {
  width: 14px;
}
textarea::-webkit-scrollbar-track {
  background: transparent;
}
textarea::-webkit-scrollbar-thumb {
  background-color: #383838;
  border-radius: 8px;
  border: 3px solid #282626;
}
textarea:focus {
  outline: none;
}

#export-data,
#import-data {
  margin-top: 0;
  padding: 10px 20px;
  font-size: 14px;
  cursor: pointer;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 8px;
  width: fit-content;
  vertical-align: middle;
  transition: border 0.3s;
}
#export-data:hover,
#import-data:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#export-message,
#import-message {
  font-size: 13px;
  display: flex;
  align-items: center;
}

#export-message.success,
#import-message.success {
  color: #7dc77d;
}

#export-message.error,
#import-message.error {
  color: #e74c3c;
}

#favorites-albums-list li {
  display: flex;
  align-items: center;
  gap: 8px;
}
#favorites-albums-list li img {
  width: 40px;
  height: 40px;
  object-fit: cover;
  border-radius: 4px;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
}

#favorites-albums-list a {
  text-decoration: none;
  transition: text-decoration 0.2s;
}

#favorites-albums-list a:hover {
  text-decoration: underline;
}

.button-line {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

.exclude-genre,
.exclude-language {
  cursor: pointer;
  color: #c0392b;
  margin-left: 5px;
  font-size: 12px;
  font-weight: bold;
  transition: color 0.3s ease;
}
.exclude-genre:hover,
.exclude-language:hover {
  color: #e74c3c;
}

.genre-filter-item .exclude-genre {
  visibility: hidden;
}
.genre-filter-item:hover .exclude-genre {
  visibility: visible;
}
.language-filter-item .exclude-language {
  display: none;
}
.language-filter-item:hover .exclude-language {
  display: inline;
}
.repeat-symbol,
.language-repeat-symbol {
  color: #7dc77d;
}
.repeat-symbol:hover,
.language-repeat-symbol:hover {
  color: #90ee90;
}

.star-box {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 40px;
  height: 40px;
  display: grid;
  place-items: center;
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  border: none;
  line-height: 0;
  z-index: 11;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
}

.star-box .star-icon {
  display: block;
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-size: 24px;
  line-height: 1;
  vertical-align: middle;
  color: #e6c200;
}

.section-title {
  position: sticky;
  top: 0;
  z-index: 10;
  background-color: #282626;
  padding: 10px 10px;
  font-size: 16px;
  font-weight: bold;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.genre-header {
  padding: 10px 10px;
  background-color: #282626;
  font-size: 18px;
}
.genre-buttons {
  display: flex;
  gap: 5px;
}
.genre-buttons button {
  display: flex;
  height: 28px;
  align-items: center;
  justify-content: center;
  padding: 4px 8px;
  font-size: 12px;
  border-radius: 8px;
  background-color: transparent;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  cursor: pointer;
  transition:
    border-color 0.3s,
    background-color 0.3s;
}
.genre-buttons button:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

.genre-buttons button.active {
  border-color: rgba(132, 170, 251, 1);
  background-color: rgba(132, 170, 251, 0.2);
}

#mode-any,
#mode-all,
#mode-only {
  width: 28px;
}

.alb-head {
  display: flex;
  gap: 12px;
  margin-bottom: 6px;
}
.rls-icon {
  width: 45px;
  height: 45px;
  flex-shrink: 0;
}
.alb-head-txt h3 {
  margin: 0;
  color: #f3f3f3;
  font-size: 18px;
}
.alb-head-txt .alb-artist,
.alb-head-txt {
  margin: 2px 0 0;
  color: #f3f3f3;
  font-size: 14px;
}
.alb-genres {
  font-size: 12px;
  margin: 2px 0 0;
  color: #f3f3f3;
}
.alb-artist {
  font-weight: bold;
}
.alb-artist a:hover {
  text-decoration: underline !important;
}

.alb-sep {
  border: 0;
  border-top: 1px solid #555;
  margin: 10px 0;
}

.alb-meta,
.alb-listens {
  display: flex;
  flex-wrap: wrap;
  font-size: 14px;
  color: #f3f3f3;
}
.alb-listens {
  gap: 6px;
}
.alb-meta p {
  width: 50%;
  box-sizing: border-box;
  display: flex;
  gap: 6px;
}
.alb-meta p svg,
.alb-listens svg,
.alb-meta svg {
  flex-shrink: 0;
  display: block;
}

.alb-footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 10px;
}

.album-cover-wrapper {
  width: 100%;
  aspect-ratio: 1 / 1;
  background-color: #333;
  border-radius: 8px;
  position: relative;
}

.album-cover-wrapper img.album-cover {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
  -webkit-user-drag: none;
  -khtml-user-drag: none;
  -moz-user-drag: none;
  -o-user-drag: none;
  user-drag: none;
}

.controls,
.modal-content,
.controls *,
.modal-content * {
  overscroll-behavior: none;
}

#label-select .options-container {
  max-height: 500px;
  display: none;
  flex-direction: column-reverse;
  border-left: 1px solid #84aafb;
  border-right: 1px solid #84aafb;
  border-top: 1px solid #84aafb;
  border-bottom: none;
  position: absolute;
  width: calc(100% + 2px);
  z-index: 99;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
}
.options-container {
  overflow: hidden;
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
}

#label-select .option-list {
  overflow-y: auto;
}

#label-select .option-fixed {
  flex-shrink: 0;
  padding-bottom: 9px;
  border-top: 1px solid #84aafb;
  display: flex;
  flex-direction: column;
}

#label-select .option-search {
  padding: 5px 5px 5px 10px;
  background: #282626;
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  transition: border 0.3s ease;
  border-radius: 8px;
  justify-content: center;
  margin-left: 10px;
  margin-right: 10px;
  margin-top: 5px;
  margin-bottom: 5px;
}

#label-select .option-search:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#label-select .option-search:focus {
  outline: none;
  box-shadow: none;
}

#label-select .option-fixed{ position: relative; }
#label-select .option-search{ padding-right: 28px; }

#label-select .option-clear{
  position: absolute;
  right: 10px;
  width: 26px;
  height: 16px;
  padding: 0px 0px;
  display: none;
  align-items: center;
  justify-content: center;
  border: 0;
  background: none;
  color: #bababa;
  line-height: 1;
  cursor: pointer;
  transition: color .15s ease;
}
#label-select .option-clear.visible{ display: flex; }
#label-select .option-clear:hover{ color: #eaeaea; }
  
#label-select .option-list {
  overflow-y: auto;
  max-height: 460px;
}

#label-select .option-list .option:first-child {
  border-top-left-radius: 8px;
}

#label-select .option-list .option:last-child {
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 0;
}

#label-select .option-list::-webkit-scrollbar {
  width: 14px;
}

#label-select .option-list::-webkit-scrollbar-track {
  background: transparent;
}

#label-select .option-list::-webkit-scrollbar-thumb,
#label-select .option-list::-webkit-scrollbar-thumb:hover,
#label-select .option-list::-webkit-scrollbar-thumb:active {
  background: #282626 !important;
  border: 3px solid #383838 !important;
  border-radius: 8px !important;
  background-clip: content-box !important;
}

#label-select .option-list::-webkit-scrollbar-button {
  display: none;
  width: 0;
  height: 0;
}

    #label-select .no-results {
  padding: 20px;
  text-align: center;
  color: #bababa;
  font-size: 14px;
  display: none;
  justify-content: center;
  align-items: center;
  height: 100%;
}

#label-select .label-sortbar{
  position: sticky; top: 0; z-index: 1;
  display: flex; align-items: center; gap: 8px;
  padding: 6px 10px;
  background-color: rgba(53, 53, 60, 0.55);
    background-image: var(--grain-bg);
    background-size: 20px 20px;
    background-blend-mode: overlay;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  border-bottom: 1px solid #84aafb;
}
#label-select .label-sortbar-title{
  font-family: "CustomFont"; font-size: 13px; color: #f3f3f3; white-space: nowrap;
}
#label-select .label-sortbar button{
  width: 28px; height: 28px;
  display: inline-flex; align-items: center; justify-content: center;
  border: 1px solid rgba(132,170,251,.5);
  border-radius: 6px; background: transparent; color: #f3f3f3; cursor: pointer;
  transition: border-color .2s ease, background .2s ease, color .2s ease;
}
#label-select .label-sortbar button.active{
  border-color: rgba(132,170,251,1);
  background: rgba(132,170,251,.1);
}

#label-select .label-sortbar i{
  font-size: 14px; line-height: 1; display: inline-block;
}

.option-all-labels {
  margin-top: 5px;
}
  
.range-wrapper {
  --start: 0%;
  --end: 100%;
  position: relative;
  height: 30px;
  margin: 5px 10px;
}

.range-wrapper::before {
  content: "";
  position: absolute;
  top: 50%;
  left: 0;
  width: 100%;
  height: 4px;
  background: rgba(132, 170, 251, 0.2);
  border-radius: 2px;
  transform: translateY(-50%);
  pointer-events: none;
}

.range-wrapper::after {
  content: "";
  position: absolute;
  top: 50%;
  left: var(--start);
  width: calc(var(--end) - var(--start));
  height: 4px;
  background: rgba(132, 170, 251, 0.5);
  border-radius: 2px;
  transform: translateY(-50%);
  pointer-events: none;
}

.range-wrapper input[type="range"] {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  background: transparent;
  pointer-events: none;
  -webkit-appearance: none;
}
.range-wrapper input[type="range"]::-webkit-slider-runnable-track {
  background: transparent;
  height: 4px;
}
.range-wrapper input[type="range"]::-webkit-slider-thumb {
  pointer-events: all;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #84aafb;
  cursor: pointer;
  margin-top: -6px;
  -webkit-appearance: none;
}

#toggle-edit-presets {
  width: 40px;
  height: 40px;
  font-size: 14px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  border-radius: 50px;
  background: transparent;
  color: #f3f3f3;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: border-color 0.3s;
}
#toggle-edit-presets:hover {
  border-color: rgba(132, 170, 251, 1);
}

#toggle-edit-presets.active {
  border: 1px solid rgba(132, 170, 251, 1);
}

.presets-wrapper .preset-item .drag-handle {
  display: none;
}
.presets-wrapper.editing .preset-item {
  position: relative;
}
.presets-wrapper.editing .preset-item .drag-handle {
  display: block;
  position: absolute;
  bottom: 6px;
  left: 50%;
  transform: translateX(-50%);
  width: 20px;
  height: 4px;
  background: rgba(255, 255, 255, 0.5);
  border-radius: 2px;
  cursor: grab;
}

.presets-wrapper.editing .preset-item .drag-handle::before {
  content: "";
  position: absolute;
  top: -7px;
  bottom: -7px;
  left: -7px;
  right: -7px;
}

.sortable-ghost {
  opacity: 1 !important;
}

.sortable-chosen {
  opacity: 0.3 !important;
  background-color: black !important;
}

.presets-wrapper .preset-item .delete-handle {
  display: none;
}
.presets-wrapper.editing .preset-item .delete-handle {
  display: block;
  position: absolute;
  top: 0;
  right: 0;
  width: 18px;
  height: 18px;
  line-height: 19px;
  text-align: center;
  background: #c0392b;
  color: #fff;
  border-radius: 0 8px 0 8px;
  cursor: pointer;
  font-size: 16px;
  transition: background 0.3s;
}

.presets-wrapper.editing .preset-item .delete-handle:hover {
  background: #e74c3c;
}

.presets-wrapper .preset-item .edit-name-handle {
  display: none;
}
.presets-wrapper.editing .preset-item .edit-name-handle {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  width: 18px;
  height: 18px;
  line-height: 19px;
  text-align: center;
  background: #596990;
  color: #fff;
  border-radius: 8px 0 8px 0;
  cursor: pointer;
  font-size: 14px;
  transition: background 0.3s;
}

.presets-wrapper.editing .preset-item .edit-name-handle:hover {
  background: #84aafb;
}

.modal-content input:not([type="checkbox"]) {
  flex-grow: 1;
  padding: 10px 5px 10px 10px;
  border-radius: 8px;
  border: 1px solid rgba(132, 170, 251, 0.5);
  width: 100%;
  font-family: "CustomFont";
  background: #282626;
  color: #f3f3f3;
  transition: border 0.3s ease;
}
.modal-content input:not([type="checkbox"]):focus {
  outline: none;
  box-shadow: none;
}
.modal-content input:not([type="checkbox"]):hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#blacklist-content .bl-temp-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 0 0 10px 0;
  color: #f3f3f3;
  background-color: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  padding: 5px 10px 5px 5px;
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
}

#blacklist-content .bl-temp-toggle label {
  cursor: pointer;
  user-select: none;
  margin: 0 0 0 -5px;
}

.modal-content {
  position: relative;
}

.modal-content h3 {
  display: block;
  vertical-align: middle;
  margin: 0 0 20px;
  color: #f3f3f3;
}

.modal-content .close {
  float: none !important;
  position: absolute !important;
  top: 20px;
  right: 20px;
  line-height: 1;
  font-size: 28px;
  cursor: pointer;
}

#edit-name-modal .modal-content {
  width: 520px;
}

.preview-overlay {
  position: fixed;
  inset: 0;
  background: rgba(53, 53, 60, 0.55);
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
  z-index: 1000;
}
.preview-overlay.hidden {
  display: none;
}

#toggle-preview-button {
  position: fixed;
  height: 40px;
  width: 40px;
  bottom: 30px;
  margin-left: 30px;
  z-index: 999;
  background: rgba(53, 53, 60, 0.75);
  color: #f3f3f3;
  border: 1px solid rgba(132, 170, 251, 0.5);
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 12px;
  cursor: pointer;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  transition: border 0.3s ease;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
}

#toggle-preview-button:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#toggle-preview-button:has(.fa-volume-up) {
  background: rgba(132, 170, 251, 0.2);
  border: 1px solid rgba(132, 170, 251, 1);
  background-image: var(--grain-bg);
  background-blend-mode: overlay;
}

#album-count-badge {
  position: fixed;
  bottom: 30px;
  z-index: 100;
  background: rgba(53, 53, 60, 0.55);
  border-radius: 8px;
  height: 40px;
  padding: 0 12px;
  box-sizing: border-box;
  color: #f3f3f3;
  font-size: 12px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  white-space: nowrap;
  gap: 6px;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
  user-select: none;
  cursor: default;
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: var(--grain-bg);
  background-size: 160px 160px;
  background-blend-mode: overlay;
}

.actions-row {
  display: flex;
  gap: 10px;
  align-items: center;
}

#favorites-button,
#blacklist-button,
#stats-button {
  width: 145px;
}

.genre-buttons {
  display: flex;
  align-items: center;
  gap: 8px;
}

.genre-buttons label {
  display: inline-flex;
  align-items: center;
  font-weight: normal;
  gap: 0px;
  font-size: 12px;
  color: #f3f3f3;
  cursor: pointer;
}

.genre-buttons input[type="checkbox"] {
  width: 16px;
  height: 16px;
  margin-right: 8px;
}

.genre-switch-sep {
  display: inline-block;
  width: 1px;
  height: 24px;
  background-color: #555;
  user-select: none;
}

.blacklist-artists,
.blacklist-labels {
  overflow: hidden;
}

.blacklist-artists.checkbox-container ul,
.blacklist-labels.checkbox-container ul {
  flex: 1;
  overflow-y: auto;
}

.blacklist-artists.checkbox-container ul::-webkit-scrollbar,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar {
  width: 8px;
}

.blacklist-artists.checkbox-container ul::-webkit-scrollbar-track,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-track {
  background: transparent;
}

.blacklist-artists.checkbox-container ul::-webkit-scrollbar-thumb,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-thumb,
.blacklist-artists.checkbox-container ul::-webkit-scrollbar-thumb:hover,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-thumb:hover,
.blacklist-artists.checkbox-container ul::-webkit-scrollbar-thumb:active,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-thumb:active {
  background: #282626 !important;
  border: 1px solid #282626 !important;
  border-radius: 8px !important;
  background-clip: content-box !important;
}

.blacklist-artists.checkbox-container ul::-webkit-scrollbar-button,
.blacklist-labels.checkbox-container ul::-webkit-scrollbar-button {
  display: none;
  width: 0;
  height: 0;
}

#scrollTopButton:hover {
  border: 1px solid rgba(132, 170, 251, 1);
}

#open-stats-btn {
  position: fixed;
  bottom: 30px;
  height: 40px;
  width: 40px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px 12px;
  background: #3b4050;
  color: #f3f3f3;
  border: 1px solid #3b4050;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  cursor: pointer;
  user-select: none;
  transition: border 0.3s ease;
  z-index: 999;
}

#stats-modal .modal-content {
  width: 1200px;
  height: calc(100vh - 120px);
  margin: 0 auto;
  overflow: hidden;
  max-width: none;
  max-height: none;
}

#stats-modal .stats-scroll {
  max-height: 100%;
  height: calc(100% - 60px);
  overflow-y: auto;
  padding-right: 8px;
  border-radius: 8px;
  -webkit-overflow-scrolling: touch;
}

#stats-modal .stats-scroll::-webkit-scrollbar {
  width: 8px;
}
#stats-modal .stats-scroll::-webkit-scrollbar-track {
  background: #282626;
}
#stats-modal .stats-scroll::-webkit-scrollbar-thumb {
  background: #383838;
  border-radius: 8px;
}

#stats-body {
  display: grid;
  gap: 10px;
  grid-template-columns: repeat(12, 1fr);
  grid-template-areas:
    "total   total   total   total   langs    langs    langs    langs    listens  listens  listens  listens"
    "genres  genres  genres  genres  genres   genres   genres   genres   genres   genres   genres   genres"
    "tracks  tracks  tracks  tracks  tracks   tracks   duration duration duration duration duration duration"
    "weekly  weekly  weekly  weekly  weekly   weekly   weekly   weekly   weekly   weekly   weekly   weekly";
  align-items: start;
}

.stats-card.area-total {
  grid-area: total;
}
.stats-card.area-langs {
  grid-area: langs;
}
.stats-card.area-listens {
  grid-area: listens;
}
.stats-card.area-genres {
  grid-area: genres;
}
.stats-card.area-tracks {
  grid-area: tracks;
}
.stats-card.area-duration {
  grid-area: duration;
}

.stats-card.area-weekly {
  grid-area: weekly;
}

#weekly-scroll {
  overflow-x: auto;
  padding: 0 6px;
}
#weekly-canvas {
  height: 360px;
  aspect-ratio: auto;
  display: block;
}

#weekly-scroll::-webkit-scrollbar {
  height: 8px;
}
#weekly-scroll::-webkit-scrollbar-track {
  background: transporent;
}
#weekly-scroll::-webkit-scrollbar-thumb {
  background: #282626;
  border-radius: 8px;
}

#stats-types-inline {
  display: flex;
  flex-wrap: wrap;
  gap: 6px 20px;
  font-size: 12px;
  color: #bababa;
  align-items: center;
  justify-content: center;
  padding-bottom: 5px;
}
#stats-types-inline .type-item {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 5px 5px;
}
#stats-types-inline .type-val {
  font-weight: 700;
  color: #bababa;
}

#genres-canvases {
  display: grid;
  grid-template-rows: auto auto;
  gap: 10px;
}

.stats-card {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 5px;
  border-radius: 8px;
  background-color: rgba(53, 53, 60, 0.55);
  background-image: var(--grain-bg);
  background-size: 20px 20px;
  background-blend-mode: overlay;
  color: #f3f3f3;
  overflow: visible;
}

.stats-card > h3 {
  top: 0;
  z-index: 10;
  background: #282626;
  padding: 10px;
  margin: 0;
  font-size: 16px;
  font-weight: 700;
  color: #f3f3f3;
  border-radius: 8px;
}

.stats-total {
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 48px;
  font-weight: 700;
  color: #f3f3f3;
  padding: 10px 0;
}

.stats-canvas {
  width: 100%;
  height: auto;
  aspect-ratio: 16/9;
  min-height: 160px;
  display: block;
}
#stats-body > .stats-card[style*="grid-column:1/-1"] .stats-canvas {
  min-height: 220px;
}

.stats-note {
  font-size: 12px;
  color: #a9b3c1;
  opacity: 0.8;
}

#favorites-modal .modal-content,
#favorites-modal .modal-content * {
  user-select: text !important;
}

.stats-title {
  margin: 0 0 20px;
}
.stats-title .stats-mode-wrap {
  display: inline-flex;
  vertical-align: middle;
  margin-left: 20px;
  position: static !important;
  padding: 5px 5px 5px 5px;
}
.stats-title .stats-mode-wrap button {
  line-height: 1;
  padding: 5px 5px 5px 5px;
}

    .ld-sep{
  display:block;
  height:1px;
  background:#555;
  border:0;
  margin-left:-10px;
  margin-right:-10px;
  width:calc(100% + 20px);
  box-sizing:content-box;
}
.ld-actions{
  display:flex;
  gap:10px;
  justify-content:center;
  align-items:center;
  padding:0;
  margin:0;
}

.ld-btn{
  display:flex !important;
  width:100%;
  height:30px;
  color:#f3f3f3;
  border-radius:8px;
  font-size:14px;
  font-family:"CustomFont";
  cursor:pointer;
  transition:border-color .3s ease;
  align-items:center;
  justify-content:center;
  box-sizing:border-box;
  padding:0;
  border: 1px solid rgba(132, 170, 251, 0);
  background-color: rgba(132, 170, 251, 0.2);
  text-decoration:none;
  line-height:1;
}

.ld-btn:hover{ border-color:rgba(132,170,251,1); text-decoration:none; }

.ld-btn__icon {
    width: 14px;
    height: 14px;
    flex: 0 0 14px;
    margin-left: 5px;
    display: block;
    align-self: center;
    transform: translateY(-2px);
}

.ld-btn__icon path{ fill:#f3f3f3; }
  
    #nuam-about-modal .modal-content,
#about-modal .modal-content {
  margin: 0;
  max-width: 100vh;
  overflow: auto;
}
    
    #nuam-about-modal .nuam-modal__body a,
#about-modal .modal-body a {
  color: #84aafb !important;
  font-weight: 700 !important;
  text-decoration: none !important;
}

#nuam-about-modal .nuam-modal__body a:hover,
#about-modal .modal-body a:hover {
  text-decoration: underline;
}

#nuam-about-modal .nuam-modal__body a:visited,
#about-modal .modal-body a:visited {
  color: #84aafb !important;
}
 
@media (max-width: 768px) {
  .controls {
    flex-direction: column;
    align-items: center;
  }
  .controls button,
  .controls select,
  .controls label {
    width: 100%;
    max-width: 300px;
  }
}

  </style>
</head>
<body>
  
  <div id="loading-screen">
  <img
    src="https://static.wixstatic.com/media/c77f36_f267062b41fa4c0a9d708971e3a36a18~mv2.png"
    alt="NUAM Albums Logo"
  />
  <div id="csv-loading">
    <div id="csv-loading-title">Підключення до бази NUAM…</div>
    <div id="csv-loading-bar"><div id="csv-loading-fill"></div></div>
    <div id="csv-loading-info">
      <span id="csv-loaded">0 Б</span><span id="csv-total">—</span>
    </div>
  </div>
</div>

<div class="controls">
  <div style="display: flex; align-items: stretch; gap: 10px; width: 100%;">
    <div class="logo-wrapper">
      <div class="logo-row">
        <a href="https://nuam.club/albums">
          <img
  id="app-logo"
  data-src="https://static.wixstatic.com/media/c77f36_f267062b41fa4c0a9d708971e3a36a18~mv2.png"
  alt="NUAM Albums Logo"
/>
          <span class="vertical-sep"></span>
          <span>Каталог альбомів України</span>
        </a>
      </div>

      <div class="logo-dropdown">
        <div class="logo-row">
          <a href="https://nuam.club/base">
            <img
  data-src="https://static.wixstatic.com/media/c77f36_266d45c9554a489da21c5f4fa4f9d79e~mv2.png"
  alt="NUAM Base Logo"
/>
            <span class="vertical-sep"></span>
            <span>База артистів України</span>
          </a>
        </div>
        <div class="logo-row">
          <a href="https://nuam.club/echo">
            <img
  data-src="https://static.wixstatic.com/media/c77f36_b0ac036b92b54f478d7e85548f99b6dd~mv2.png"
  alt="NUAM Echo Logo"
/>
            <span class="vertical-sep"></span>
            <span>Радар релізів України</span>
          </a>
        </div>
        <div class="logo-row">
          <a href="https://nuam.club">
            <img
              src="https://static.wixstatic.com/media/c77f36_09ede4c28e284822b304eab05c1f8d99~mv2.png"
              alt="NUAM Logo"
            />
            <span class="vertical-sep"></span>
            <span>Сайт проєкту</span>
          </a>
        </div>
        <div class="ld-sep" role="separator"></div>
<div class="ld-actions">
  <button id="ld-about-btn" type="button" class="ld-btn">Про проєкт</button>

  <a class="ld-btn" href="https://send.monobank.ua/jar/2BLPSRWwYb" target="_blank" rel="noopener noreferrer">
    Підтримати
    <svg class="ld-btn__icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
      <path d="M14 3h7v7h-2V6.41l-9.29 9.3-1.42-1.42 9.3-9.29H14V3Zm-4 4v2H5v10h12v-5h2v7H3V7h7Z"/>
    </svg>
  </a>
</div>

      </div>
    </div>

    <div class="search-wrapper">
      <div class="search-buttons-column">
        <button id="search-button">Пошук</button>
        <button id="filters-button">Фільтри</button>
      </div>
      <div
        id="search-container"
        style="display: none; align-items: center; gap: 5px;"
      >
        <div
          id="search-mode-toggle"
          class="tri-toggle"
          role="group"
          aria-label="Режим пошуку"
        >
          <button type="button" data-mode="artist">Артист</button>
          <button type="button" data-mode="artist-album" class="active">
            Артист+Альбом
          </button>
          <button type="button" data-mode="album">Альбом</button>
        </div>
        <input type="text" id="search-input" placeholder="Пошук релізів…" />
        <button id="search-close">✖</button>
      </div>

      <div
        id="filters-container"
        style="display: none; align-items: center; gap: 10px; width: 100%; padding: 0 0 15px 0;"
      >
        <button id="add-preset" class="add-preset-btn">+</button>
        <button id="toggle-edit-presets">
          <i class="fas fa-pencil-alt"></i>
        </button>

        <div class="presets-wrapper">
          <button
            class="preset-item"
            data-preset-json='{"name":"Жанри","filters":{}}'
          >
            Жанри
          </button>
          <button
            class="preset-item"
            data-preset-json='{"name":"Мови","filters":{}}'
          >
            Мови
          </button>
          <button
            class="preset-item"
            data-preset-json='{"name":"Тип релізу","filters":{}}'
          >
            Тип релізу
          </button>
          <button
            class="preset-item"
            data-preset-json='{"name":"Інше","filters":{}}'
          >
            Інше
          </button>
        </div>

        <button id="filters-close">✖</button>
      </div>
    </div>
  </div>

  <div id="preset-modal" class="modal hidden">
    <div class="modal-content">
      <span class="close" id="preset-close">&times;</span>
      <h3 style="color: #f3f3f3; margin-top: 0; margin-bottom: 20px;">
        Будуть збережені поточні вибрані фільтри та сортування
      </h3>
      <div class="preset-actions-row">
        <input
          id="preset-name-input"
          placeholder="Назва фільтра"
          style="margin-right:10px;"
        />
        <button id="preset-save" style="height:40px;">Зберегти</button>
        <span id="preset-save-message"></span>
      </div>

      <input
        id="preset-desc-input"
        placeholder="Опис фільтра (необов'язково)"
        maxlength="250"
        style="display:block; width:310px; margin-top:10px;"
      />

      <hr class="preset-separator" />

      <div class="preset-restore-row">
        <button id="preset-restore">Відновити стандартні фільтри</button>
      </div>
    </div>
  </div>

  <div id="edit-name-modal" class="modal hidden">
    <div class="modal-content">
      <span class="close" id="edit-name-close">&times;</span>
      <h3>Редагування назви фільтра</h3>
      <input
        id="edit-name-input"
        placeholder="Нова назва фільтра"
        style="margin-right:10px;"
      /><button id="edit-name-save" style="height:40px;">Зберегти</button>
      <span id="edit-name-message"></span>
      <input
        id="edit-desc-input"
        placeholder="Опис фільтра (необов'язково)"
        maxlength="250"
        style="width: 310px; display:block; margin:10px 0 0 0;"
      />
    </div>
  </div>

  <div class="filter-section">
    <div class="checkbox-container">
      <div class="section-title genre-header">
        <span>Жанри</span>
        <div class="genre-buttons">
          <button class="mode-btn" id="mode-any">
            <i class="fas fa-layer-group"></i>
          </button>
          <button class="mode-btn" id="mode-all">
            <i class="fas fa-check-double"></i>
          </button>
          <button class="mode-btn" id="mode-only">
            <i class="fas fa-filter-circle-xmark"></i>
          </button>
          <span class="genre-switch-sep"></span>
          <button id="select-all-genres">Вибрати всі</button>
          <button id="deselect-all-genres">Зняти всі</button>
        </div>
      </div>

      <div class="checkbox-grid" id="genre-checkboxes"></div>
    </div>
    <div class="filter-group">
      <div class="checkbox-container">
        <label class="section-title">Мови</label>
        <div class="checkbox-grid" id="language-checkboxes"></div>
      </div>
      <div class="release-column">
        <div
          class="checkbox-container"
          style="max-height: none; overflow-y: visible;"
        >
          <label class="section-title">Тип релізу</label>
          <div class="checkbox-grid" id="release-type-checkboxes"></div>
        </div>
        <div class="hide-listened-section">
          <label for="nuam-recommended-checkbox">
            <input
              type="checkbox"
              id="nuam-recommended-checkbox"
            />Рекомендовані NUAM
          </label>
        </div>
      </div>
    </div>
  </div>
  <div class="sort-and-blacklist">
    <div class="sort-section">
      <label for="sort-order">Сортування:</label>
      <div class="custom-select" id="sort-order">
        <div class="selected">Спочатку нові</div>
        <div class="options-container">
          <div class="option" data-value="desc">Спочатку нові</div>
          <div class="option" data-value="asc">Спочатку старі</div>
          <div class="option" data-value="listens-desc">
            Більше прослуховувань
          </div>
          <div class="option" data-value="listens-asc">
            Менше прослуховувань
          </div>
          <div class="option" data-value="duration-desc">Більш тривалі</div>
          <div class="option" data-value="duration-asc">Менш тривалі</div>
          <div class="option" data-value="tracks-desc">
            Більша кількість треків
          </div>
          <div class="option" data-value="tracks-asc">
            Менша кількість треків
          </div>
          <div class="option" data-value="popularity-growth">
            Активне зростання слухачів
          </div>
          <div class="option" data-value="random">Випадковий порядок</div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="release-period-filter">Період релізу:</label>
      <div class="custom-select" id="release-period-filter">
        <div class="selected">За будь-який час</div>
        <div class="options-container">
          <div class="option" data-value="">За будь-який час</div>
          <div class="option" data-value="7">За останній тиждень</div>
          <div class="option" data-value="14">За останні два тижні</div>
          <div class="option" data-value="30">За останній місяць</div>
          <div class="option" data-value="90">За останні три місяці</div>
          <div class="option" data-value="182">За останні півроку</div>
          <div class="option" data-value="365">За останній рік</div>

          <div class="range-wrapper" id="release-period-range">
            <input
              type="range"
              id="release-period-start"
              min="0"
              max="0"
              step="1"
            />
            <input
              type="range"
              id="release-period-end"
              min="0"
              max="0"
              step="1"
            />
          </div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="listen-count-filter">Прослуховувань:</label>
      <div class="custom-select" id="listen-count-filter">
        <div class="selected">Будь-яка кількість</div>
        <div class="options-container">
          <div class="option" data-value="">Будь-яка кількість</div>
          <div class="option" data-value="0-1000">До 1000</div>
          <div class="option" data-value="1000-2500">Від 1000 до 2500</div>
          <div class="option" data-value="2500-5000">Від 2500 до 5000</div>
          <div class="option" data-value="5000-10000">Від 5000 до 10 000</div>
          <div class="option" data-value="10000-25000">
            Від 10 000 до 25 000
          </div>
          <div class="option" data-value="25000-50000">
            Від 25 000 до 50 000
          </div>
          <div class="option" data-value="50000-100000">
            Від 50 000 до 100 000
          </div>
          <div class="option" data-value="100000-250000">
            Від 100 000 до 250 000
          </div>
          <div class="option" data-value="250000-500000">
            Від 250 000 до 500 000
          </div>
          <div class="option" data-value="500000-1000000">
            Від 500 000 до 1 000 000
          </div>
          <div class="option" data-value="1000000-">Від 1 000 000</div>

          <div class="range-wrapper" id="listen-count-range">
            <input
              type="range"
              id="listen-count-start"
              min="0"
              max="0"
              step="1"
            />
            <input
              type="range"
              id="listen-count-end"
              min="0"
              max="0"
              step="1"
            />
          </div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="duration-filter">Тривалість:</label>
      <div class="custom-select" id="duration-filter">
        <div class="selected">Будь-яка тривалість</div>
        <div class="options-container">
          <div class="option" data-value="">Будь-яка тривалість</div>
          <div class="option" data-value="short">До 30 хвилин</div>
          <div class="option" data-value="medium">30–60 хвилин</div>
          <div class="option" data-value="long">60–120 хвилин</div>
          <div class="option" data-value="very-long">Понад 120 хвилин</div>

          <div class="range-wrapper" id="duration-range">
            <input type="range" id="duration-start" min="0" max="0" step="1" />
            <input type="range" id="duration-end" min="0" max="0" step="1" />
          </div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="track-count-filter">Кількість треків:</label>
      <div class="custom-select" id="track-count-filter">
        <div class="selected">Будь-яка кількість</div>
        <div class="options-container">
          <div class="option" data-value="">Будь-яка кількість</div>
          <div class="option" data-value="5">5 і більше треків</div>
          <div class="option" data-value="12">12 і більше треків</div>

          <div class="range-wrapper" id="track-count-range">
            <input
              type="range"
              id="track-count-start"
              min="0"
              max="0"
              step="1"
            />
            <input type="range" id="track-count-end" min="0" max="0" step="1" />
          </div>
        </div>
      </div>
    </div>

    <div class="sort-section">
      <label for="track-count-filter">Альбоми лейблу:</label>
      <div class="custom-select upward" id="label-select">
        <div class="selected">Усі лейбли</div>
        <div class="options-container">
          <div class="option" data-value="">Усі лейбли</div>
        </div>
      </div>
    </div>

    <div class="actions-row">
      <button id="favorites-button">Обрані альбоми</button>
      <button id="blacklist-button">Чорний список</button>
      <button id="stats-button">Статистика</button>
    </div>
    <div class="bottom-controls">
      <div class="hide-listened-section">
        <label for="hide-listened">
          <input type="checkbox" id="hide-listened" />Приховати
          <span id="show-listened-albums">прослухані альбоми</span>
        </label>
      </div>
      <div class="album-count">
        Альбомів з урахуванням фільтрів: <span id="album-count">0</span>
      </div>
    </div>
  </div>
</div>

<div id="albums-container"></div>
<div id="preview-overlay" class="preview-overlay hidden"></div>

<div class="lazy-loading" id="lazy-loading">Завантаження альбомів…</div>

<div id="blacklist-modal" class="modal hidden">
  <div class="modal-content">
    <span class="close">&times;</span>

    <div class="tabs">
      <button
        class="tablink"
        id="favorites-tab"
        onclick="openTab(event, 'favorites-content')"
      >
        Обрані альбоми
      </button>
      <button
        class="tablink active"
        id="blacklist-tab"
        onclick="openTab(event, 'blacklist-content')"
      >
        Чорний список
      </button>
      <button
        class="tablink"
        id="listened-albums-tab"
        onclick="openTab(event, 'listened-albums-content')"
      >
        Прослухані альбоми
      </button>
      <button
        class="tablink"
        id="export-tab"
        onclick="openTab(event, 'export-content')"
      >
        Перенесення даних
      </button>
    </div>

    <div id="favorites-content" class="tabcontent">
      <div class="listened-albums-container">
        <ul id="favorites-albums-list"></ul>
      </div>
    </div>

    <div id="blacklist-content" class="tabcontent active">
      <div class="bl-temp-toggle">
        <input type="checkbox" id="temp-disable-blacklist" />
        <label for="temp-disable-blacklist"
          >Тимчасово вимкнути чорний список</label
        >
      </div>

      <div class="blacklist-container">
        <div class="blacklist-artists checkbox-container">
          <h4>Артисти</h4>
          <ul id="blacklisted-artists"></ul>
        </div>
        <div class="blacklist-labels checkbox-container">
          <h4>Лейбли</h4>
          <ul id="blacklisted-labels"></ul>
        </div>
      </div>
    </div>

    <div id="listened-albums-content" class="tabcontent">
      <div class="listened-albums-container">
        <ul id="listened-albums-list"></ul>
      </div>
    </div>

    <div id="export-content" class="tabcontent">
      <div class="export-import-container">
        <div
          class="export-section"
          style="display:flex; flex-direction:column; gap:10px;"
        >
          <label for="data-textarea">Дані для експорту:</label>
          <textarea id="data-textarea" readonly></textarea>
          <div class="button-line">
            <button id="export-data">Копіювати дані</button>
            <span id="export-message">&nbsp;</span>
          </div>
        </div>

        <div
          class="import-section"
          style="display:flex; flex-direction:column; gap:10px;"
        >
          <label for="import-textarea">Вставте сюди дані для імпорту:</label>
          <textarea
            id="import-textarea"
            placeholder="Вставте сюди дані"
          ></textarea>
          <div class="button-line">
            <button id="import-data">Завантажити дані</button>
            <span id="import-message">&nbsp;</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="listened-albums-content" class="tabcontent">
  <div class="listened-albums-container">
    <ul id="listened-albums-list"></ul>
  </div>
</div>
<div id="export-content" class="tabcontent">
  <div class="export-import-container">
    <div
      class="export-section"
      style="display: flex; flex-direction: column; gap: 10px;"
    >
      <label for="data-textarea">Дані для експорту:</label>
      <textarea id="data-textarea" readonly></textarea>
      <div class="button-line">
        <button id="export-data">Копіювати дані</button>
        <span id="export-message"> </span>
      </div>
    </div>
    <div
      class="import-section"
      style="display: flex; flex-direction: column; gap: 10px;"
    >
      <label for="import-textarea">Вставте сюди дані для імпорту:</label>
      <textarea id="import-textarea" placeholder="Вставте сюди дані"></textarea>
      <div class="button-line">
        <button id="import-data">Завантажити дані</button>
        <span id="import-message"> </span>
      </div>
    </div>
  </div>
</div>

<div class="modal-overlay"></div>

  <div id="nuam-about-modal" class="modal hidden" aria-hidden="true">
  <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="nuam-about-title">

    <div class="nuam-modal__header">
      <h3 id="nuam-about-title" class="nuam-modal__title">Про проєкт</h3>
      <button id="nuam-about-close" class="nuam-modal__close" aria-label="Закрити">×</button>
    </div>
    <div class="nuam-modal__body">
      <p><strong>NUAM Albums</strong> — вебдодаток сервісу <a href="https://nuam.club" target="_blank" rel="noopener noreferrer">NUAM</a> з автоматично оновлюваним каталогом музичних альбомів України: повноформатних релізів, міні-альбомів та компіляцій.</p>
      <p>У вашому розпорядженні широкий набір інструментів для пошуку, сортування та детальної фільтрації за різними параметрами. Слухайте уривки треків безпосередньо в додатку, переглядайте статистику, зберігайте власні фільтри для швидкого доступу, відзначайте улюблені альбоми.</p>
        <p>Досліджуйте українську сцену — вона значно більша й різноманітніша, ніж здається!</p>
    </div>
  </div>
</div>
  
<div
  id="scrollTopButton"
  onmouseenter="this.style.borderColor='rgba(132,170,251,1)'"
  onmouseleave="this.style.borderColor='rgba(132, 170, 251, 0.5)'"
  style='
  position: fixed;
  bottom: 20px;
  right: 30px;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 1px solid rgba(132, 170, 251, 0.5);
  display: none;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  z-index: 1999;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  transition: opacity 0.3s, border-color 0.3s ease;
  user-select: none;
  background-color: rgba(53, 53, 60, 0.55);
  backdrop-filter: blur(8px) saturate(140%);
  -webkit-backdrop-filter: blur(8px) saturate(140%);
  background-image: url(&apos;data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><filter id="grain"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" seed="2"/><feColorMatrix type="saturate" values="0"/></filter><rect width="100%25" height="100%25" filter="url(%23grain)" opacity="0.15"/></svg>&apos;);
  background-size: 20px 20px;
  background-blend-mode: overlay;
'
>
  <svg
    xmlns="http://www.w3.org/2000/svg"
    width="24"
    height="24"
    fill="#f3f3f3"
    viewBox="0 0 24 24"
  >
    <path d="M12 4l-8 8h6v8h4v-8h6z" />
  </svg>
</div>

  <script>
    
const NUAM_CACHE_NAME='nuam-cache-v1';
const NUAM_KEYS={etag:'nuam.csv:etag',lm:'nuam.csv:lm',len:'nuam.csv:len',hash:'nuam.csv:sha256'};

const CSVLOG = {
  on: true,
  g: null,
  start(tag, url){ if(!this.on) return; this.g = console.groupCollapsed ? console.groupCollapsed(`[CSV] ${tag}: ${url}`) : null; },
  info(...a){ if(this.on) console.log('[CSV]', ...a); },
  end(){ if(this.on && console.groupEnd) console.groupEnd(); }
};

async function sha256Hex(t){
  const enc=new TextEncoder().encode(t);
  const buf=await crypto.subtle.digest('SHA-256',enc);
  return [...new Uint8Array(buf)].map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function readFromCache(url){
  const c=await caches.open(NUAM_CACHE_NAME);
  const m=await c.match(url,{ignoreSearch:false,ignoreVary:false});
  return m ? await m.text() : null;
}
async function writeToCache(url,text){
  const c=await caches.open(NUAM_CACHE_NAME);
  await c.put(url,new Response(text,{headers:{'Content-Type':'text/csv; charset=utf-8'}}));
}
function normETag(s){ return (s||'').trim().replace(/^W\//i,'').replace(/^"+|"+$/g,''); }

async function loadNuamCsvText(url){
  const ttl = document.getElementById("csv-loading-title");

  const prevET = localStorage.getItem(NUAM_KEYS.etag) || '';
  const prevLM = localStorage.getItem(NUAM_KEYS.lm)   || '';
  const prevHS = localStorage.getItem(NUAM_KEYS.hash) || '';

  const cachedBody = await readFromCache(url);

  if (prevET || prevLM){
    const h = new Headers();
    if (prevET) h.set('If-None-Match', prevET);
    if (prevLM) h.set('If-Modified-Since', prevLM);

    const r = await fetch(url, { method:'GET', headers:h, cache:'no-cache' });

    if (r.status === 304 && cachedBody != null){
      if (ttl) ttl.textContent = "Використовуємо базу з кешу";
      return { text: cachedBody, source: 'cache-304' };
    }

    if (r.ok){
      if (ttl) ttl.textContent = "Завантаження бази NUAM…";
      const text = await r.text();
      await writeToCache(url, text);
      const et = r.headers.get('ETag'); if (et) localStorage.setItem(NUAM_KEYS.etag, normETag(et));
      const lm = r.headers.get('Last-Modified'); if (lm) localStorage.setItem(NUAM_KEYS.lm, lm);
      try{ const hsh = await sha256Hex(text); localStorage.setItem(NUAM_KEYS.hash, hsh); }catch(_){}
      return { text, source: 'network-200' };
    }

    if (cachedBody != null){
      if (ttl) ttl.textContent = "Використовуємо базу з кешу";
      return { text: cachedBody, source: 'cache-fallback' };
    }

    throw new Error('CSV fetch failed: ' + r.status);
  }

  const r2 = await fetch(url, { method:'GET', cache:'no-cache' });
  if (!r2.ok) throw new Error('HTTP ' + r2.status);
  if (ttl) ttl.textContent = "Завантаження бази NUAM…";
  const text2 = await r2.text();
  await writeToCache(url, text2);
  const et2 = r2.headers.get('ETag'); if (et2) localStorage.setItem(NUAM_KEYS.etag, normETag(et2));
  const lm2 = r2.headers.get('Last-Modified'); if (lm2) localStorage.setItem(NUAM_KEYS.lm, lm2);
  try{ const h2 = await sha256Hex(text2); localStorage.setItem(NUAM_KEYS.hash, h2); }catch(_){}
  return { text: text2, source: 'network-200' };
}
    
    function loadCsvWithRetry(
  url,
  options,
  retries = 3,
  delay = 1000,
  fallbackUrl = null,
){
  let attempts = 0;

  async function tryLoad(currentUrl){
    const ttl = document.getElementById("csv-loading-title");
    if (ttl) ttl.textContent = "Підключення до бази NUAM…";

    try{
      const res = await loadNuamCsvText(currentUrl);

      if (res && res.source && String(res.source).startsWith('cache')) {
        const t = document.getElementById("csv-loading-title");
        if (t) t.textContent = "Використовуємо базу з кешу";
      }
      const opts = { ...(options||{}) };
      if ('download' in opts) delete opts.download;
      Papa.parse(res.text, opts);

    }catch(err){
      attempts++;
      if (attempts < retries){
        setTimeout(()=>{ tryLoad(currentUrl); }, delay);
        return;
      }
      if (fallbackUrl && currentUrl !== fallbackUrl){
        attempts = 0;
        tryLoad(fallbackUrl);
        return;
      }
      if (options && typeof options.error === 'function'){
        try { options.error(err instanceof Error ? err : new Error(String(err))); } catch(_){}
      }
    }
  }

  tryLoad(url);
}

    const WORKER_URL = "https://nuam-albums.hi-f50.workers.dev";
    
async function getAccessToken() {
  const r = await fetch(`${WORKER_URL}/spotify/token`, { method: "POST" });
  const j = await r.json();
  return j.access_token;
}

async function getAlbumTracks(albumId, _token_ignored) {
  let all = [];
  let url = `${WORKER_URL}/spotify/v1/albums/${albumId}/tracks?limit=50`;
  while (url) {
    const r = await fetch(url);
    const j = await r.json();
    all = all.concat((j && j.items) || []);
    if (j && j.next) {
      const u = new URL(j.next);
      url = `${WORKER_URL}/spotify${u.pathname}${u.search}`;
    } else {
      url = null;
    }
  }
  return all.map((t) => ({
    id: t.id,
    name: t.name,
    artists: t.artists.map((a) => a.name),
  }));
}

let autoPlayingAlbum = null;
let autoPlayIndex = 0;
let currentHighlightedCircle = null;

async function loadAlbumTracksWithRetry(album) {
  if (!window._spotifyToken) {
    window._spotifyToken = await getAccessToken();
  }
  try {
    const list = await getAlbumTracks(album.albumID, window._spotifyToken);
    album.tracksInfo = Object.fromEntries(list.map((t) => [t.id, t]));
  } catch (err) {
    console.warn("Ошибка при получении треков (пробуем обновить токен)", err);

    window._spotifyToken = await getAccessToken();

    const list = await getAlbumTracks(album.albumID, window._spotifyToken);
    album.tracksInfo = Object.fromEntries(list.map((t) => [t.id, t]));
  }
}

let activePresetButton = null;
let isPresetLoading = false;

(function () {
  if (window.__csvBarInstalled) return;
  window.__csvBarInstalled = true;

  function human(n) {
    if (!n && n !== 0) return "—";
    const u = ["Б", "КБ", "МБ", "ГБ"];
    let i = 0;
    while (n >= 1024 && i < u.length - 1) {
      n /= 1024;
      i++;
    }
    return n.toFixed(i ? 1 : 0) + " " + u[i];
  }
  function isCsv(input) {
    try {
      const url =
        typeof input === "string" ? input : input && input.url ? input.url : "";
      if (window.newSheetUrl && typeof newSheetUrl === "string")
        return url === newSheetUrl;
      return /\/nuam\.csv(\?|$)/.test(url);
    } catch (_) {
      return false;
    }
  }
  function ensureIDs() {
    return !!(
      document.getElementById("csv-loading") &&
      document.getElementById("csv-loading-fill") &&
      document.getElementById("csv-loaded") &&
      document.getElementById("csv-total") &&
      document.getElementById("csv-loading-title")
    );
  }

  (function () {
    const _open = XMLHttpRequest.prototype.open;
    const _send = XMLHttpRequest.prototype.send;
    XMLHttpRequest.prototype.open = function (m, u) {
      this.__csv = isCsv(u);
      return _open.apply(this, arguments);
    };
    XMLHttpRequest.prototype.send = function (b) {
      if (this.__csv && ensureIDs()) {
        const fill = () => document.getElementById("csv-loading-fill");
        const got = () => document.getElementById("csv-loaded");
        const tot = () => document.getElementById("csv-total");
        const ttl = () => document.getElementById("csv-loading-title");

        this.addEventListener("progress", (e) => {
          if (e.lengthComputable) {
            tot().textContent = human(e.total);
            got().textContent = human(e.loaded);
            fill().style.width =
              Math.min(100, Math.round((e.loaded * 100) / e.total)) + "%";
          } else {
            got().textContent = human(e.loaded || 0);
          }
        });
        this.addEventListener("loadstart", () => {
  try {
    const l = Number(this.getResponseHeader && this.getResponseHeader("content-length"));
    if (l) tot().textContent = human(l);
  } catch (_) {}
  ttl().textContent = "Завантаження бази NUAM…";
});

        this.addEventListener("loadend", () => {
  fill().style.width = "100%";
});

        this.addEventListener("error", () => {
          ttl().textContent = "Помилка завантаження";
        });
        this.addEventListener("abort", () => {
          ttl().textContent = "Скасовано";
        });
      }
      return _send.apply(this, arguments);
    };
  })();

  (function () {
    const _fetch = window.fetch;
    window.fetch = async function (res, init) {
      const rsp = await _fetch(res, init);
      try {
        if (!rsp.body || !isCsv(res) || !ensureIDs()) return rsp;
        const fill = document.getElementById("csv-loading-fill");
        const got = document.getElementById("csv-loaded");
        const tot = document.getElementById("csv-total");
        const ttl = document.getElementById("csv-loading-title");

        const total = Number(rsp.headers.get("content-length")) || 0;
        if (total) tot.textContent = human(total);

        ttl.textContent = "Завантаження бази NUAM…";
const [a, b] = rsp.body.tee();
(async () => {
  const r = b.getReader();
  let rec = 0;
  for (;;) {
    const { done, value } = await r.read();
    if (done) break;
    rec += value.byteLength;
    got.textContent = human(rec);
    if (total) {
      fill.style.width = Math.min(100, Math.round((rec * 100) / total)) + "%";
    }
  }
  if (!total) {
    tot.textContent = human(rec);
    fill.style.width = "100%";
  }
})();
return new Response(a, {
  status: rsp.status,
  statusText: rsp.statusText,
  headers: rsp.headers,
});

      } catch (_) {
        return rsp;
      }
    };
  })();
})();

const newSheetUrl = "https://nuam-albums.hi-f50.workers.dev/nuam.csv";
const fallbackSheetUrl =
  "https://docs.google.com/spreadsheets/d/e/2PACX-1vTRGgPDeRNQcSe5tV2h3zu-rtMr-i7ph-4hU6HKglhXKdaAB5UFXUrdWLZKb8hwGyWgDxL5LDfnmrqe/pub?gid=1559781011&single=true&output=csv";

let searchQuery = "";

const previewPlayer = new Audio();

function markUnavailableCircle(circle) {
  if (!circle) return;

  circle.dataset.unavail = "1";

  const icon = circle.querySelector("i.fas");
  if (icon) {
    icon.className = "fas fa-music";
    icon.style.color = "#c0392b94";
  }

  if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
  if (typeof removeTooltip === "function") removeTooltip(circle);

  circle.removeAttribute("title");
  if (circle.dataset && "tooltip" in circle.dataset)
    delete circle.dataset.tooltip;

  if (typeof attachTooltip === "function") {
    attachTooltip(circle, "Уривок треку поки що недоступний");
  }
}

let playToken = 0;

previewPlayer.preload = "none";
previewPlayer.crossOrigin = "anonymous";
let previewActivated = false;
let previewProbe = null;

const scrollTopButton = document.getElementById("scrollTopButton");
const togglePreviewBtn = document.createElement("button");
togglePreviewBtn.id = "toggle-preview-button";

attachTooltip(
  togglePreviewBtn,
  "Увімкнути відтворення уривків треків при наведенні",
  "180px",
);

scrollTopButton.parentNode.insertBefore(togglePreviewBtn, scrollTopButton);

const iconOn = '<i class="fas fa-volume-up"></i>';
const iconOff = '<i class="fas fa-volume-xmark"></i>';
togglePreviewBtn.innerHTML = iconOff;

(function moveAlbumCount() {
  const el = document.querySelector(".album-count");
  if (!el) return;
  el.classList.remove("album-count");
  el.id = "album-count-badge";
  document.body.appendChild(el);

  const resetBtn = document.createElement("button");
  resetBtn.id = "reset-filters-btn";
  resetBtn.type = "button";
  resetBtn.textContent = "↺";
  el.appendChild(resetBtn);

  if (typeof attachTooltip === "function") {
    attachTooltip(resetBtn, "Встановити фільтри за замовчуванням", "250px");
  }

  resetBtn.addEventListener("click", (e) => {
    e.preventDefault();
    window.resetFiltersToDefault();
  });
})();

function togglePreview(state) {
  previewActivated =
    state === true || state === false ? state : !previewActivated;
  if (!previewActivated) {
    previewPlayer.pause();
    previewPlayer.currentTime = 0;
    previewPlayer.removeAttribute("src");
    previewPlayer.load();
  }
  togglePreviewBtn.innerHTML = previewActivated ? iconOn : iconOff;

  removeTooltip(togglePreviewBtn);
  attachTooltip(
    togglePreviewBtn,
    previewActivated
      ? "Вимкнути відтворення уривків треків при наведенні"
      : "Увімкнути відтворення уривків треків при наведенні",
    "180px",
  );
}

togglePreview(previewActivated);
togglePreviewBtn.addEventListener("click", () => {
  if (autoPlayingAlbum) {
    const prevAlbum = autoPlayingAlbum;
    autoPlayingAlbum = null;

    const prevBtn = document.querySelector(
      `.play-all-toggle[data-album-id="${prevAlbum}"]`,
    );
    if (prevBtn) {
      prevBtn.innerHTML = '<i class="fas fa-play"></i>';
      removeTooltip(prevBtn);
      attachTooltip(prevBtn, "Відтворити всі треки альбому", "180px");
    }

    if (currentHighlightedCircle) {
      currentHighlightedCircle.classList.remove("highlight");
      currentHighlightedCircle = null;
    }

    const prevTracksContainer = document.querySelector(
      `.album[data-album-id="${prevAlbum}"] .tracks`,
    );
    if (prevTracksContainer) {
      prevTracksContainer
        .querySelectorAll(".track-circle .progress-fill")
        .forEach((el) => (el.style.width = "0%"));
    }

    previewPlayer.pause();
    previewPlayer.currentTime = 0;
    previewPlayer.ontimeupdate = null;
  }

  togglePreview();
});

function fixPos() {
  const cont = document.getElementById("albums-container");
  const btn = document.getElementById("toggle-preview-button");
  const stats = document.getElementById("open-stats-btn");
  const badge = document.getElementById("album-count-badge");
  if (!cont || !btn) return;

  btn.style.left = cont.getBoundingClientRect().left + "px";

  let baseRect = btn.getBoundingClientRect();
  if (stats) {
    stats.style.left = baseRect.left + baseRect.width + 10 + "px";
    baseRect = stats.getBoundingClientRect();
  }

  if (badge) {
    badge.style.left = baseRect.left + baseRect.width + 10 + "px";
  }
}

window.addEventListener("scroll", fixPos);
window.addEventListener("resize", fixPos);
fixPos();

const loaderImg = document.querySelector("#loading-screen img");
if (loaderImg) {
  document.getElementById("app-logo").src = loaderImg.src;
}

const artistsSheetId = "1_PavIrMhHpUHXG7uDrT83yznb2nrJfSd-9G8Hnm9ywM";
const artistsGid = "0";
const allowedArtistIds = new Set();

function showRestoredMessage() {
  const btn = document.getElementById("preset-restore");
  if (!btn) return;

  const FADE_MS = 300;
  const HOLD_MS = 2000;

  const parent = btn.parentNode;

  let msg = document.getElementById("preset-restore-msg");
  if (!msg) {
    msg = document.createElement("span");
    msg.id = "preset-restore-msg";
    msg.textContent = "Стандартні пресети відновлено";
    msg.style.cssText = [
      "display:inline-block",
      "opacity:0",
      "color:#7dc77d",
      `transition:opacity ${FADE_MS}ms ease`,
      "white-space:nowrap",
    ].join(";");
    parent.insertBefore(msg, btn);
  }

  const cs = getComputedStyle(btn);
  msg.style.minWidth = cs.width;
  msg.style.lineHeight = cs.height;

  btn.style.transition = `opacity ${FADE_MS}ms ease`;
  void btn.offsetWidth;
  btn.style.opacity = "0";

  setTimeout(() => {
    btn.style.display = "none";
    msg.style.opacity = "1";
  }, FADE_MS);

  setTimeout(() => {
    msg.style.opacity = "0";
  }, FADE_MS + HOLD_MS);

  setTimeout(
    () => {
      msg.remove();
      btn.style.display = "";
      btn.style.opacity = "0";
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          btn.style.opacity = "1";
        });
      });
    },
    FADE_MS + HOLD_MS + FADE_MS,
  );
}

function restoreDefaultsAndNotify(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }
  if (typeof restoreDefaultPresets === "function") restoreDefaultPresets();
  if (typeof loadPresetsFromStorage === "function") loadPresetsFromStorage();
  if (typeof updateRestorePresetUI === "function") updateRestorePresetUI();
  showRestoredMessage();
}

function loadAllowedArtists() {
  return new Promise((resolve, reject) => {
    const q = encodeURIComponent("select F,K");
    const url = `https://docs.google.com/spreadsheets/d/${artistsSheetId}/gviz/tq?gid=${artistsGid}&tqx=out:csv&tq=${q}`;

    Papa.parse(url, {
      download: true,
      header: false,
      skipEmptyLines: true,
      complete: (results) => {
        results.data.forEach((row) => {
          row.forEach((cell) => {
            if (!cell) return;
            const m = cell.match(/artist\/([^?]+)/);
            if (m) allowedArtistIds.add(m[1]);
          });
        });

        resolve();
      },
      error: (err) => {
        console.error("Помилка під час завантаження списку артистів", err);
        reject(err);
      },
    });
  });
}

let albumsData = [];
let currentIndex = 0;
let sortOrder = "desc";
let hideListened = false;
let audioActivated = false;
let filteredAlbums = [];
let isFiltering = false;
let blacklistedArtists = new Set(
  JSON.parse(localStorage.getItem("blacklistedArtists")) || [],
);
let blacklistedLabels = new Set(
  JSON.parse(localStorage.getItem("blacklistedLabels")) || [],
);
let labelFilter = "";

const LABEL_ALIASES = {
  "ПОТОП": ["ПОТОП Distribution"],
  "Dear Deer": ["Dear Deer Black"],
  "GM DIGITAL": ["Gm Digital", "Vg Star / Gm Digital"],
  "BEST MUSIC": ["LEVEL SOUND / Best Music"],
  "NoLeak": ["NoLeakLabel"],
  "Papa Music": ["Papa Music 2.0"],
  "ReidlMusic": ["ReidlMusic, LLC.", "REIDLMUSIC, LLC."],
  "Vista": ["Vista Distribution"],
  "VG STAR": ["Vg Star / Gm Digital", "VG STAR RN"]
};
const __LABEL_VARIANT_TO_CANON = (() => {
  const m = new Map();
  for (const [canon, vars] of Object.entries(LABEL_ALIASES)) {
    const k = canon.trim();
    m.set(k.toLowerCase(), k);
    m.set(k, k);
    (vars || []).forEach(v => {
      const vv = String(v).trim();
      if (vv) m.set(vv.toLowerCase(), k);
    });
  }
  return m;
})();
function canonLabel(lbl){
  if (!lbl) return "";
  const key = String(lbl).trim();
  return __LABEL_VARIANT_TO_CANON.get(key.toLowerCase()) || key;
}
    
function releaseIcon(t) {
  if (t === "compilation")
    return `<svg class="rls-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><rect x="5" y="5" width="190" height="190" rx="40" ry="40" fill="none" stroke="#f3f3f3" stroke-width="4"/><text x="50%" y="43%" text-anchor="middle" font-family="Arial Black, Arial, sans-serif" font-size="75" fill="#f3f3f3">CO</text><text x="50%" y="83%" text-anchor="middle" font-family="Arial Black, Arial, sans-serif" font-size="75" fill="#f3f3f3">MP</text></svg>`;
  if (t === "album")
    return `<svg class="rls-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><rect x="5" y="5" width="190" height="190" rx="40" ry="40" fill="none" stroke="#f3f3f3" stroke-width="4"/><text x="50%" y="54%" text-anchor="middle" dominant-baseline="middle" font-family="Arial Black, Arial, sans-serif" font-size="115" fill="#f3f3f3">LP</text></svg>`;
  return `<svg class="rls-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200"><rect x="5" y="5" width="190" height="190" rx="40" ry="40" fill="none" stroke="#f3f3f3" stroke-width="4"/><text x="50%" y="54%" text-anchor="middle" dominant-baseline="middle" font-family="Arial Black, Arial, sans-serif" font-size="115" fill="#f3f3f3">EP</text></svg>`;
}

const listenedAlbums = JSON.parse(localStorage.getItem("listenedAlbums")) || {};
const favoriteAlbums = JSON.parse(localStorage.getItem("favoriteAlbums")) || {};

const languageLabels = {
  ukr: "українська",
  eng: "англійська",
  rus: "російська",
  "other lang": "інші мови",
};

const REPLACE_LABELS = {
  "other lang": "Інші мови",
  "producing work for international": "intl prod",
  "like old trash": "estrade",
};

function mapName(s) {
  const k = String(s).trim().toLowerCase();
  return REPLACE_LABELS[k] || s;
}

const batchSize = 20;
let isEmptyResult = false;

const PRESETS_KEY = "albumPresets";

const DEFAULT_PRESET_NAMES = [
  "Актуальне",
  "Популярні альбоми",
  "Великі релізи",
  "Хорошого потроху",
];

function isAnyDefaultMissing() {
  const names = new Set(getStoredPresets().map((p) => p.name));
  for (const n of DEFAULT_PRESET_NAMES) if (!names.has(n)) return true;
  return false;
}

function hasUserPresets() {
  const std = new Set(DEFAULT_PRESET_NAMES);
  return getStoredPresets().some((p) => !std.has(p.name));
}

function updateRestorePresetUI() {
  const modal = document.getElementById("preset-modal");
  const btn = modal && modal.querySelector("#preset-restore");
  const sep = modal && modal.querySelector(".preset-separator");
  if (!btn || !sep) return;

  if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
  if (typeof removeTooltip === "function") removeTooltip(btn);

  const STD = new Set([
    "Актуальне",
    "Популярні альбоми",
    "Великі релізи",
    "Хорошого потроху",
  ]);
  const list = getStoredPresets();
  const names = new Set(list.map((p) => p.name));

  const missingDefaults = [...STD].some((n) => !names.has(n));
  const hasUser = list.some((p) => !STD.has(p.name));

  btn.style.display = missingDefaults ? "inline-block" : "none";
  sep.style.display = missingDefaults ? "block" : "none";

  btn.dataset.missingDefaults = missingDefaults ? "1" : "0";
  btn.dataset.hasUser = hasUser ? "1" : "0";
}

const DEFAULT_PRESETS = [
  {
    name: "Актуальне",
    desc: "Найсвіжіші та найгарячіші альбоми з потенційним зростанням слухачів",
    filters: {
      selectedGenres: [],
      excludedGenres: ["phonk", "ai", "producing work for international", "like old trash"],
      selectedLanguages: [],
      excludedLanguages: ["rus"],
      selectedReleaseTypes: [],
      sortOrder: "popularity-growth",
      hideListened: false,
      nuamRecommended: false,

      period: "14",
      periodStart: "",
      periodEnd: "",

      duration: "",
      durationStart: 0,
      durationEnd: 999,
      trackCount: "range",
      trackStart: 3,
      trackEnd: 999,
      labelFilter: "",

      listenCount: "",
      listenStart: 0,
      listenEnd: 999999999,

      genreMode: "any",
      genreOnlySelected: false,
    },
  },
  {
    name: "Популярні альбоми",
    desc: "Найпопулярніші повноформатні альбоми за останній час",

    filters: {
      selectedGenres: [],
      excludedGenres: ["phonk", "ai", "producing work for international", "like old trash"],
      selectedLanguages: [],
      excludedLanguages: ["rus"],

      selectedReleaseTypes: ["album"],
      sortOrder: "listens-desc",
      hideListened: false,
      nuamRecommended: false,

      period: "90",
      periodStart: "",
      periodEnd: "",

      duration: "",
      durationStart: 0,
      durationEnd: 999,
      trackCount: "",
      trackStart: 0,
      trackEnd: 999,
      labelFilter: "",

      listenCount: "",
      listenStart: 0,
      listenEnd: 999999999,

      genreMode: "any",
      genreOnlySelected: false,
    },
  },
  {
    name: "Великі релізи",
    desc: "Великі альбоми з активним зростанням слухачів",

    filters: {
      selectedGenres: [
        "pop/indie",
        "rock",
        "hip-hop",
        "metal",
        "post-punk",
        "folk",
      ],
      excludedGenres: ["phonk", "ai", "producing work for international", "like old trash"],
      selectedLanguages: [],
      excludedLanguages: ["rus"],

      selectedReleaseTypes: ["album"],
      sortOrder: "popularity-growth",
      hideListened: false,
      nuamRecommended: false,

      period: "90",
      periodStart: "",
      periodEnd: "",

      duration: "range",
      durationStart: 40,
      durationEnd: 999,

      trackCount: "",
      trackStart: 0,
      trackEnd: 999,
      labelFilter: "",

      listenCount: "",
      listenStart: 0,
      listenEnd: 999999999,

      genreMode: "any",
      genreOnlySelected: false,
    },
  },
  {
    name: "Хорошого потроху",
    desc: "Не хочете слухати музику альбомами? Почніть хоча б з коротких.",

    filters: {
      selectedGenres: [],
      excludedGenres: ["phonk", "ai", "producing work for international", "like old trash"],
      selectedLanguages: [],
      excludedLanguages: ["rus"],
      selectedReleaseTypes: [],
      sortOrder: "random",
      hideListened: false,
      nuamRecommended: false,

      period: "182",
      periodStart: "",
      periodEnd: "",

      duration: "range",
      durationStart: 10,
      durationEnd: 20,

      trackCount: "",
      trackStart: 0,
      trackEnd: 999,
      labelFilter: "",

      listenCount: "range",
      listenStart: 1001,
      listenEnd: 999999999,

      genreMode: "any",
      genreOnlySelected: false,
    },
  },
];

function ensureDefaultPresets() {
  const current = getStoredPresets();
  const byName = new Map(current.map((p) => [p.name, p]));
  let changed = false;

  DEFAULT_PRESETS.forEach((def) => {
    const cur = byName.get(def.name);
    if (!cur) {
      current.push(def);
      changed = true;
    } else if (def.desc && !cur.desc) {
      cur.desc = def.desc;
      changed = true;
    }
  });

  if (changed) savePresetsToStorage(current);
}

function getStoredPresets() {
  try {
    const raw = localStorage.getItem(PRESETS_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch {
    return [];
  }
}
function savePresetsToStorage(arr) {
  localStorage.setItem(PRESETS_KEY, JSON.stringify(arr));
}

function restoreDefaultPresets() {
  if (typeof DEFAULT_PRESETS === "undefined") return;

  const current = getStoredPresets();
  const names = new Set(current.map((p) => p.name));
  let changed = false;

  DEFAULT_PRESETS.forEach((def) => {
    if (!names.has(def.name)) {
      current.push(def);
      changed = true;
    }
  });

  if (changed) savePresetsToStorage(current);
  loadPresetsFromStorage();
  updateRestorePresetUI();
}

function loadPresetsFromStorage() {
  const wrapper = presetsWrapper;
  if (!wrapper) return;
  wrapper.innerHTML = "";
  getStoredPresets().forEach((preset) => {
    const btn = document.createElement("button");
    btn.className = "preset-item";
    btn.textContent = preset.name;
    btn.dataset.presetJson = JSON.stringify(preset);
    btn.addEventListener("click", () => applyPreset(preset));
    if (preset.desc) {
      if (typeof attachTooltip === "function") attachTooltip(btn, preset.desc);
      btn.removeAttribute("title");
      btn.setAttribute("aria-label", preset.desc);
    }

    wrapper.appendChild(btn);
  });

  if (presetsWrapper.classList.contains("editing")) {
    attachPresetControls();

    if (sortable) sortable.destroy();
    sortable = Sortable.create(presetsWrapper, {
      animation: 150,
      handle: ".drag-handle",
      onEnd: () => {
        const newArr = Array.from(presetsWrapper.children).map((b) =>
          JSON.parse(b.dataset.presetJson),
        );
        savePresetsToStorage(newArr);
      },
    });
  }
  updateRestorePresetUI();
}

function clearActivePreset() {
  if (activePresetButton) {
    activePresetButton.classList.remove("preset-active");
    activePresetButton = null;
  }
}

function applyPreset(preset) {
  if (!preset.filters) return;
  isPresetLoading = true;

  localStorage.setItem("albumFilters", JSON.stringify(preset.filters));

  loadFiltersAfterRender();
  smoothApplyFilters();
  clearActivePreset();

  document
    .querySelectorAll("button.preset-item")
    .forEach((b) => b.classList.remove("preset-active"));
  const btn = [...document.querySelectorAll("button.preset-item")].find(
    (b) => b.textContent === preset.name,
  );
  if (btn) {
    btn.classList.add("preset-active");
    activePresetButton = btn;
  }

  isPresetLoading = false;
}

window.applyDefaultFilters = function () {
  ["phonk", "ai", "producing work for international", "like old trash"].forEach((g) => {
    const cb = document.getElementById(`genre-${encodeURIComponent(g)}`);
    if (cb) {
      cb.disabled = true;
      const cross = cb.parentNode.querySelector(".exclude-genre");
      cross.textContent = "↻";
      cross.classList.add("repeat-symbol");
      const lbl = cb.nextElementSibling;
      lbl.style.textDecoration = "line-through";
      lbl.style.color = "gray";
    }
  });
  const cbL = document.getElementById("language-rus");
  if (cbL) {
    cbL.disabled = true;
    const crossL = cbL.parentNode.querySelector(".exclude-language");
    crossL.textContent = "↻";
    crossL.classList.add("language-repeat-symbol");
    const lblL = cbL.nextElementSibling;
    lblL.style.textDecoration = "line-through";
    lblL.style.color = "gray";
  }
  document.getElementById("hide-listened").checked = true;
  hideListened = true;
  preserveScroll(() => smoothApplyFilters());
  saveFiltersToCache();
};

window.resetFiltersToDefault = function () {
  if (typeof clearActivePreset === "function") clearActivePreset();
  localStorage.removeItem("albumFilters");
  isPresetLoading = true;

  document.querySelectorAll(".genre-checkbox").forEach(function (cb) {
    cb.checked = false;
    cb.disabled = false;

    var parent = cb.closest(".genre-item") || cb.parentNode;
    var lbl =
      cb.nextElementSibling || (parent ? parent.querySelector("label") : null);
    if (lbl) {
      lbl.style.textDecoration = "none";
      lbl.style.color = "#f3f3f3";
      ["excluded", "removed", "gray-out", "line-through"].forEach(function (c) {
        lbl.classList.remove(c);
      });
    }
    if (parent && parent.classList) {
      ["excluded", "removed", "gray-out"].forEach(function (c) {
        parent.classList.remove(c);
      });
      if (parent.dataset) {
        delete parent.dataset.excluded;
        delete parent.dataset.state;
      }
    }
    var cross = parent
      ? parent.querySelector(".exclude-genre")
      : cb.parentNode.querySelector(".exclude-genre");
    if (cross) {
      cross.textContent = "✖";
      cross.classList.remove("repeat-symbol", "active");
      cross.removeAttribute("data-excluded");
      cross.removeAttribute("aria-pressed");
    }
  });

  document.querySelectorAll(".language-checkbox").forEach(function (cb) {
    cb.checked = false;
    cb.disabled = false;

    var parent = cb.closest(".language-item") || cb.parentNode;
    var lbl =
      cb.nextElementSibling || (parent ? parent.querySelector("label") : null);
    if (lbl) {
      lbl.style.textDecoration = "none";
      lbl.style.color = "#f3f3f3";
      ["excluded", "removed", "gray-out", "line-through"].forEach(function (c) {
        lbl.classList.remove(c);
      });
    }
    if (parent && parent.classList) {
      ["excluded", "removed", "gray-out"].forEach(function (c) {
        parent.classList.remove(c);
      });
      if (parent.dataset) {
        delete parent.dataset.excluded;
        delete parent.dataset.state;
      }
    }
    var cross = parent
      ? parent.querySelector(".exclude-language")
      : cb.parentNode.querySelector(".exclude-language");
    if (cross) {
      cross.textContent = "✖";
      cross.classList.remove("language-repeat-symbol", "active");
      cross.removeAttribute("data-excluded");
      cross.removeAttribute("aria-pressed");
    }
    cb.removeAttribute("data-excluded");
  });
  [
    "excludedLanguages",
    "excludedLangs",
    "languageExcludes",
    "langExcludes",
  ].forEach(function (key) {
    var v = window[key];
    if (Array.isArray(v)) v.length = 0;
    else if (v && typeof v.clear === "function") v.clear();
  });
  ["excludedLanguages", "languageExcludes", "langExcludes"].forEach(
    function (k) {
      try {
        localStorage.removeItem(k);
      } catch (e) {}
    },
  );

  document.querySelectorAll(".release-type-checkbox").forEach(function (cb) {
    cb.checked = false;
  });

  (function () {
    const any = document.getElementById("mode-any");
    const all = document.getElementById("mode-all");
    const only = document.getElementById("mode-only");
    [any, all, only].forEach((b) => {
      if (b) {
        b.classList.remove("active");
        b.setAttribute("aria-pressed", "false");
      }
    });
    if (any) {
      any.classList.add("active");
      any.setAttribute("aria-pressed", "true");
    }

    try {
      localStorage.removeItem("genreMode");
      localStorage.removeItem("genreOnlySelected");
    } catch (e) {}
  })();

  var clickFirst = function (id) {
    var opt = document.querySelector(
      "#" + id + " .options-container .option:first-child",
    );
    if (opt) opt.click();
  };
  clickFirst("sort-order");
  clickFirst("release-period-filter");
  clickFirst("duration-filter");
  clickFirst("track-count-filter");
  clickFirst("listen-count-filter");
  clickFirst("label-select");

  const nuam = document.getElementById("nuam-recommended-checkbox");
  if (nuam) nuam.checked = false;

  labelFilter = "";
  const selectedLabelDiv = document.querySelector("#label-select .selected");
  if (selectedLabelDiv) {
    selectedLabelDiv.textContent = "Усі лейбли";
    selectedLabelDiv.dataset.value = "";
  }

  var hide = document.getElementById("hide-listened");

  if (hide) hide.checked = true;

  window.applyDefaultFilters();
  isPresetLoading = false;
  applyDefaultFilters();
};

window.addEventListener("DOMContentLoaded", init);

(function () {
  if (window.__stats_inited__) return;
  window.__stats_inited__ = true;

  function normStr(x) {
    return (x ?? "").toString().trim();
  }
  function toNum(x) {
    const n = Number((x ?? "").toString().replace(/[^\d.]/g, ""));
    return Number.isFinite(n) ? n : 0;
  }

  function parseHHMMSS(s) {
    s = normStr(s);
    if (!s) return 0;
    const p = s.split(":").map(Number);
    if (p.length === 3) return p[0] * 3600 + p[1] * 60 + p[2];
    if (p.length === 2) return p[0] * 60 + p[1];
    return toNum(s);
  }

  function splitMulti(v) {
    return normStr(v)
      .split(/[;,|/]/)
      .map((x) => x.trim())
      .filter(Boolean);
  }

  function bucketListens(n) {
    if (n < 1000) return "0–1 000";
    if (n < 5000) return "1 000–5 000";
    if (n < 10000) return "5 000–10 000";
    if (n < 25000) return "10 000–25 000";
    if (n < 50000) return "25 000–50 000";
    if (n < 100000) return "50 000–100 000";
    if (n < 250000) return "100 000–250 000";
    if (n < 500000) return "250 000–500 000";
    if (n < 1000000) return "500 000–1 000 000";
    return "1 000 000+";
  }

  function bucketDuration(sec) {
    if (sec < 300) return "1–5 хв";
    if (sec < 600) return "5–10 хв";
    if (sec < 1200) return "10–20 хв";
    if (sec < 1800) return "20–30 хв";
    if (sec < 3600) return "30–60 хв";
    if (sec < 5400) return "60–90 хв";
    if (sec < 7200) return "90–120 хв";
    return "120+ хв";
  }

  function bucketTracks(n) {
    if (n <= 3) return "1–3";
    if (n <= 4) return "3–4";
    if (n <= 6) return "4–6";
    if (n <= 9) return "6–9";
    if (n <= 12) return "9–12";
    return "12+";
  }

  function collectCounts(arr) {
    const map = new Map();
    for (const k of arr) {
      map.set(k, (map.get(k) || 0) + 1);
    }
    return map;
  }

  function sortMapDesc(map) {
    return [...map.entries()].sort((a, b) => b[1] - a[1]);
  }

  window.computeAlbumStats = function (albums) {
    const total = albums.length;

    const typesArr = [];
    const langsArr = [];
    const genresArr = [];
    const listensArr = [];
    const durArr = [];
    const tracksArr = [];

    for (const a of albums) {
      const type = (a.type ?? a.Type ?? "").toString().trim();
      if (type) typesArr.push(type);

      const langs =
        Array.isArray(a.languages) && a.languages.length ? a.languages : [];
      for (const L0 of langs) {
        const L = (L0 ?? "").toString().trim().toLowerCase();
        if (!L) continue;
        if (L.includes("без голосу") || L.includes("no voice")) {
          langsArr.push("Без голосу");
        } else if (/(ukr|укр|україн)/.test(L)) {
          langsArr.push("Українська");
        } else if (/(eng|англ|english)/.test(L)) {
          langsArr.push("Англійська");
        } else if (/(rus|рос|росій|russian)/.test(L)) {
          langsArr.push("Російська");
        } else {
          const mapped = mapName(L0);
          const out =
            String(mapped).trim().toLowerCase() === "Інші мови"
              ? "Інші мови"
              : String(mapped)
                  .trim()
                  .replace(/^./, (c) => c.toUpperCase());
          langsArr.push(out);
        }
      }

      if (Array.isArray(a.genres)) {
        for (const g of a.genres) {
          const gg = (g ?? "").toString().trim();
          if (gg) genresArr.push(mapName(gg));
        }
      }

      const listensVal = Number(a.listens ?? 0);
      listensArr.push(
        bucketListens(Number.isFinite(listensVal) ? listensVal : 0),
      );

      const durSec = parseHHMMSS(a.duration ?? "");
      durArr.push(bucketDuration(durSec));

      const trCount = Array.isArray(a.tracksIDs) ? a.tracksIDs.length : 0;
      if (trCount > 0) tracksArr.push(bucketTracks(trCount));
    }

    const types = sortMapDesc(collectCounts(typesArr));
    const langs = sortMapDesc(collectCounts(langsArr));
    const listens = sortMapDesc(collectCounts(listensArr));
    const dur = sortMapDesc(collectCounts(durArr));
    const tracks = sortMapDesc(collectCounts(tracksArr));

    const gMap = collectCounts(genresArr.map((x) => x || "(невідомо)"));
    const gSorted = sortMapDesc(gMap);
    const top20 = gSorted.slice(0, 20);

    return {
      total,
      types,
      langs,
      genresAll: gSorted,
      genresTop: top20,
      listens,
      dur,
      tracks,
    };
  };

  function clearCanvas(cnv) {
    const ctx = cnv.getContext("2d");
    ctx.clearRect(0, 0, cnv.width, cnv.height);
  }
  function autoDPR(cnv) {
    const dpr = window.devicePixelRatio || 1;
    const rect = cnv.getBoundingClientRect();
    cnv.width = Math.round(rect.width * dpr);
    cnv.height = Math.round(rect.height * dpr);
    const ctx = cnv.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    return ctx;
  }

  window.drawBar = function (cnv, data, opts = {}) {
    const ctx = autoDPR(cnv);
    const W = cnv.clientWidth,
      H = cnv.clientHeight;
    clearCanvas(cnv);
    if (W < 20 || H < 20 || !data || !data.length) return;

    const labels = data.map((d) => String(d[0]));
    const values = data.map((d) => Number(d[1]) || 0);
    const max = Math.max(1, ...values);

    ctx.font = "12px CustomFont,Arial";
    const longest = labels.reduce(
      (m, s) => Math.max(m, ctx.measureText(s).width),
      0,
    );
    const labelPad = 14;
    const labelW = Math.min(160, Math.max(80, Math.ceil(longest) + labelPad));

    const pad = 12,
      gap = 8,
      rightPad = 20;
    const innerH = H - pad * 2;
    const n = values.length || 1;
    const rowH = Math.min(32, Math.max(10, (innerH - (n - 1) * gap) / n));
    const availW = Math.max(2, W - (labelW + rightPad + 4));
    let y = pad;

    const total = values.reduce((s, x) => s + (+x || 0), 0);
    let accumTenths = 0;

    for (let i = 0; i < n; i++) {
      const v = values[i];
      const w = Math.max(2, availW * (v / max));

      ctx.fillStyle = "#f3f3f3";
      ctx.textBaseline = "middle";
      ctx.textAlign = "left";
      ctx.fillText(labels[i], 8, y + rowH / 2);

      ctx.fillStyle = "#4a9eff";
      ctx.fillRect(labelW, y, w, rowH);

      ctx.fillStyle = "#e9eef5";
      ctx.textBaseline = "middle";
      ctx.textAlign = "left";
      let pct = total > 0 ? (v * 100) / total : 0;
      let tenths = Math.round(pct * 10);

      if (i === n - 1) tenths = Math.max(0, 1000 - accumTenths);
      accumTenths += tenths;

      const text = `${v} (${(tenths / 10).toFixed(1)}%)`;
      const tw = ctx.measureText(text).width;
      const preferredX = labelW + w + 6;
      const clampedX = Math.min(preferredX, W - 6 - tw);
      ctx.fillText(text, clampedX, y + rowH / 2);
      y += rowH + gap;
    }
  };

  window.drawBar2Cols = function (cnv, leftData, rightData) {
    const ctx = autoDPR(cnv);
    const W = cnv.clientWidth,
      H = cnv.clientHeight;
    clearCanvas(cnv);

    const L = Array.isArray(leftData) ? leftData : [];
    const R = Array.isArray(rightData) ? rightData : [];

    if (W < 20 || H < 20 || (!L.length && !R.length)) return;

    const pad = 12,
      colGap = 24,
      rightPad = 20,
      rowGap = 8;
    const innerH = H - pad * 2;
    const colW = Math.max(40, (W - pad * 2 - colGap) / 2);

    ctx.font = "12px CustomFont,Arial";

    function measureLabelW(arr) {
      if (!arr.length) return 80;
      var max = 0;
      for (var i = 0; i < arr.length; i++) {
        var w = ctx.measureText(String(arr[i][0])).width;
        if (w > max) max = w;
      }
      var labelPad = 14;
      var res = Math.ceil(max) + labelPad;
      if (res < 80) res = 80;
      if (res > 160) res = 160;
      return res;
    }

    function drawPanel(x0, data) {
      if (!data.length) return;
      var n = data.length;
      var values = new Array(n);
      var max = 1;
      for (var i = 0; i < n; i++) {
        var v = Number(data[i][1]) || 0;
        values[i] = v;
        if (v > max) max = v;
      }
      var total = values.reduce(function (s, x) {
        return s + (+x || 0);
      }, 0);
      var accumTenths = 0;

      var labelW = measureLabelW(data);
      if (labelW > colW - 30) labelW = colW - 30;
      var availW = colW - (labelW + rightPad + 4);
      if (availW < 2) availW = 2;

      var rowH = (innerH - (n - 1) * rowGap) / n;
      if (rowH > 32) rowH = 32;
      if (rowH < 10) rowH = 10;

      var y = pad;
      for (var i = 0; i < n; i++) {
        var v = values[i];
        var w = availW * (v / max);
        if (w < 2) w = 2;

        ctx.fillStyle = "#f3f3f3";
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        ctx.fillText(String(data[i][0]), x0 + 8, y + rowH / 2);

        ctx.fillStyle = "#4a9eff";
        ctx.fillRect(x0 + labelW, y, w, rowH);

        ctx.fillStyle = "#e9eef5";
        ctx.textBaseline = "middle";
        ctx.textAlign = "left";
        var pct = total > 0 ? (v * 100) / total : 0;
        var tenths = Math.round(pct * 10);

        if (i === n - 1) tenths = Math.max(0, 1000 - accumTenths);
        accumTenths += tenths;

        var text = String(v) + " (" + (tenths / 10).toFixed(1) + "%)";
        var tw = ctx.measureText(text).width;
        var preferredX = x0 + labelW + w + 6;
        var rightEdge = x0 + colW - 6;
        var clampedX = Math.min(preferredX, rightEdge - tw);
        ctx.fillText(text, clampedX, y + rowH / 2);
        y += rowH + rowGap;
      }
    }

    drawPanel(pad, L);
    drawPanel(pad + colW + colGap, R);
  };

  window.drawDonut = function (cnv, data) {
    const ctx = autoDPR(cnv);
    const W = cnv.clientWidth,
      H = cnv.clientHeight;
    clearCanvas(cnv);

    if (W < 20 || H < 20 || !data || !data.length) return;

    const cx = W / 2,
      cy = H / 2;
    const baseR = Math.min(W, H) / 2 - 10;
    const R = Math.max(1, baseR);
    const r = Math.max(0.5, R * 0.55);

    const sum = data.reduce((s, [_k, v]) => s + v, 0) || 1;

    let ang = -Math.PI / 2;
    for (let i = 0; i < data.length; i++) {
      const val = data[i][1];
      if (!val) continue;
      const a2 = ang + 2 * Math.PI * (val / sum);
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.arc(cx, cy, R, ang, a2);
      ctx.closePath();
      ctx.fillStyle = `hsl(${(i * 47) % 360} 70% 55%)`;
      ctx.fill();

      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalCompositeOperation = "source-over";

      ang = a2;
    }
  };

  window.createStatsModal = function () {
    if (document.getElementById("stats-modal")) return;

    const overlay = document.createElement("div");
    overlay.id = "stats-modal";
    overlay.className = "modal hidden";

    overlay.innerHTML = `
    <div class="modal-content">
      <span class="close" id="stats-close">&times;</span>
      <h3 class="stats-title">Статистика альбомів
  <span id="stats-mode-toggle" class="tri-toggle stats-mode-wrap" role="group" aria-label="Режим статистики">
    <button type="button" data-mode="all" class="active">ALL</button>
    <button type="button" data-mode="lp">LP</button>
    <button type="button" data-mode="ep">EP</button>
  </span>
</h3>

      <div class="stats-scroll">
        <div id="stats-body">

  <div class="stats-card area-total" id="stats-total-card">
    <h3>Загальна кількість альбомів</h3>
    <div class="stats-total" id="stats-total">0</div>
    <div id="stats-types-inline"></div>
  </div>

  <div class="stats-card area-langs">
    <h3>Мови</h3>
    <canvas class="stats-canvas" id="cnv-langs"></canvas>
  </div>

  <div class="stats-card area-listens">
    <h3>Прослуховування</h3>
    <canvas class="stats-canvas" id="cnv-listens"></canvas>
  </div>

  <div class="stats-card area-genres">
    <h3>Жанри</h3>
    <canvas class="stats-canvas" id="cnv-genres"></canvas>
  </div>

  <div class="stats-card area-tracks">
    <h3>Кількість треків</h3>
    <canvas class="stats-canvas" id="cnv-tracks"></canvas>
  </div>

  <div class="stats-card area-duration">
    <h3>Тривалість</h3>
    <canvas class="stats-canvas" id="cnv-duration"></canvas>
  </div>
  <div class="stats-card area-weekly">
  <h3>Релізи по тижнях</h3>
  <div id="weekly-scroll">
    <canvas id="weekly-canvas" class="stats-canvas"></canvas>
  </div>
</div>
</div>
      </div>
    </div>
  `;

    document.body.appendChild(overlay);

    document
      .getElementById("stats-close")
      .addEventListener("click", closeStatsModal);
    overlay.addEventListener("click", (e) => {
      if (e.target.id === "stats-modal") closeStatsModal();
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "Escape") closeStatsModal();
    });

    (function () {
      const wrap = document.getElementById("stats-mode-toggle");
      if (!wrap) return;
      const btns = wrap.querySelectorAll("button[data-mode]");
      btns.forEach((btn) => {
        btn.addEventListener("click", () => {
          const m = btn.getAttribute("data-mode");
          window.__stats_mode = m;
          btns.forEach((b) => b.classList.toggle("active", b === btn));
          const s =
            typeof window.__getStatsByMode === "function"
              ? window.__getStatsByMode()
              : window.__album_stats_all || window.__album_stats;
          if (s && typeof renderAlbumStats === "function") renderAlbumStats(s);
        });
      });
    })();
  };

  openStatsModal = function () {
    const el = document.getElementById("stats-modal");
    if (!el) return;
    el.classList.remove("hidden");

    requestAnimationFrame(() => {
      const s =
        typeof window.__getStatsByMode === "function"
          ? window.__getStatsByMode()
          : window.__album_stats_all || window.__album_stats;
      if (s) renderAlbumStats(s);
    });

    if (!window.__stats_resize_handler__) {
      window.__stats_resize_handler__ = () => {
        if (!el.classList.contains("hidden")) {
          const s =
            typeof window.__getStatsByMode === "function"
              ? window.__getStatsByMode()
              : window.__album_stats_all || window.__album_stats;
          if (s) renderAlbumStats(s);
        }
      };
      window.addEventListener("resize", window.__stats_resize_handler__);
    }
  };

  window.closeStatsModal = function () {
    const el = document.getElementById("stats-modal");
    if (!el) return;
    el.classList.add("hidden");
    if (window.__stats_resize_handler__) {
      window.removeEventListener("resize", window.__stats_resize_handler__);
      window.__stats_resize_handler__ = null;
    }
  };

  window.renderAlbumStats = function (stats) {
    const $ = (id) => document.getElementById(id);
    const withRounded = (el, fn) => {
      const ctx = el.getContext("2d");
      const orig = ctx.fillRect;
      ctx.fillRect = function (x, y, w, h) {
        this.fillStyle = "#6f84b4";

        const width = Math.abs(w),
          height = Math.abs(h);
        const left = w < 0 ? x - width : x;
        const top = h < 0 ? y - height : y;
        const r = Math.min(8, width / 2, height / 2);
        if (r > 0) {
          this.beginPath();
          const right = left + width,
            bottom = top + height;
          this.moveTo(left + r, top);
          this.arcTo(right, top, right, top + r, r);
          this.arcTo(right, bottom, right - r, bottom, r);
          this.arcTo(left, bottom, left, bottom - r, r);
          this.arcTo(left, top, left + r, top, r);
          this.closePath();
          this.fill();
        } else {
          orig.call(this, x, y, w, h);
        }
      };
      try {
        fn();
      } finally {
        ctx.fillRect = orig;
      }
    };

    const drawIf = (el, data) => {
      if (el && data && data.length) withRounded(el, () => drawBar(el, data));
    };

    function buildWeeklyReleaseData() {
      const DAY = 24 * 60 * 60 * 1000,
        WEEK = 7 * DAY;

      const mode = String(window.__stats_mode || "all").toLowerCase();
      const src =
        mode === "lp"
          ? window.__albums_lp_for_stats || []
          : mode === "ep"
            ? window.__albums_ep_for_stats || []
            : window.__albums_all_for_stats || [];

      if (!Array.isArray(src) || !src.length) return [];

      const dates = src.map((a) => new Date(a.date));
      const minDate = new Date(Math.min.apply(null, dates));
      const maxAlbumTime = Math.max.apply(
        null,
        dates.map((d) => +d),
      );

      const startIdx = 0;
      const lastIdx = Math.floor((maxAlbumTime - +minDate) / WEEK);
      let endIdx = lastIdx;

      const buckets = [];
      for (let i = startIdx; i <= endIdx; i++) {
        const ws = new Date(+minDate + i * WEEK);
        const label = ws.toLocaleDateString("uk-UA", {
          day: "2-digit",
          month: "2-digit",
          year: "2-digit",
        });
        buckets.push([label, 0]);
      }

      for (const a of src) {
        const d = new Date(a.date);
        const idx = Math.floor((d - minDate) / WEEK);
        if (idx < startIdx || idx > endIdx) continue;
        buckets[idx - startIdx][1] += 1;
      }
      return buckets;
    }

    function drawWeeklyColumns(cnv, data) {
      const bar = 22,
        gap = 8,
        pad = 12,
        bottom = 57,
        top = 24;
      const n = Math.max(1, data.length);
      const cssWidth = pad + n * (bar + gap) - gap + pad;
      cnv.style.width = cssWidth + "px";

      const ctx = autoDPR(cnv);
      clearCanvas(cnv);

      const W = cnv.clientWidth,
        H = cnv.clientHeight;
      if (W < 30 || H < 30 || !data || !data.length) return;

      const max = Math.max(1, ...data.map((d) => +d[1] || 0));
      const innerH = Math.max(2, H - top - bottom);

      ctx.font = "12px CustomFont,Arial";
      ctx.textAlign = "center";
      ctx.textBaseline = "alphabetic";

      for (let i = 0; i < data.length; i++) {
        const j = data.length - 1 - i;
        const [label, v0] = data[j];
        const v = +v0 || 0;
        const h = Math.max(2, innerH * (v / max));
        const x = pad + i * (bar + gap);
        const y = top + (innerH - h);

        ctx.fillStyle = "#6f84b4";
        ctx.fillRect(x, y, bar, h);

        ctx.fillStyle = "#a9b3c1";
        ctx.save();
        ctx.translate(x + bar / 2, H - 28);
        ctx.rotate(-Math.PI / 3);
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }

      ctx.fillStyle = "#e9eef5";
      for (let i = 0; i < data.length; i++) {
        const j = data.length - 1 - i;
        const v = +data[j][1] || 0;
        const h = Math.max(2, innerH * (v / max));
        const x = pad + i * (bar + gap);
        const y = top + (innerH - h) - 6;
        ctx.textAlign = "center";
        ctx.textBaseline = "alphabetic";
        ctx.fillText(String(v), x + bar / 2, y);
      }
    }

    const total = (stats && stats.total) != null ? stats.total : 0;
    const totalEl = $("stats-total");
    if (totalEl) totalEl.textContent = total;

    drawIf($("cnv-langs"), stats?.langs || []);
    drawIf($("cnv-listens"), stats?.listens || []);
    drawIf($("cnv-duration"), stats?.dur || []);
    drawIf($("cnv-tracks"), stats?.tracks || []);

    {
      const weekly = buildWeeklyReleaseData();
      const wcnv = document.getElementById("weekly-canvas");
      if (wcnv && weekly && weekly.length) {
        withRounded(wcnv, () => drawWeeklyColumns(wcnv, weekly));
      }
    }

    {
      const wwrap = document.getElementById("weekly-scroll");
      if (wwrap && !wwrap.dataset.wheelified) {
        wwrap.addEventListener(
          "wheel",
          (e) => {
            if (e.ctrlKey) return;
            const dx =
              Math.abs(e.deltaY) >= Math.abs(e.deltaX) ? e.deltaY : e.deltaX;
            wwrap.scrollLeft += dx * 1.5;
            e.preventDefault();
          },
          { passive: false },
        );
        wwrap.dataset.wheelified = "1";
      }
    }

    const typesBox = $("stats-types-inline");
    if (typesBox) {
      const __mode = String(window.__stats_mode || "all").toLowerCase();
      typesBox.innerHTML = "";
      typesBox.style.display = __mode === "all" ? "" : "none";

      if (__mode === "all") {
        const types = stats?.types || null;
        if (Array.isArray(types) && types.length) {
          const base = total || types.reduce((s, [, v]) => s + (+v || 0), 0);
          types
            .filter(([, v]) => +v > 0)
            .sort((a, b) => b[1] - a[1])
            .forEach(([name, val]) => {
              const p = base ? Math.round((+val * 100) / base) : 0;
              const div = document.createElement("div");
              div.className = "type-item";
              div.innerHTML = `<span class="type-name">${name}</span><span class="type-val">${val} <small>(${p}%)</small></span>`;
              typesBox.appendChild(div);
            });
        }
      }
    }

    {
      const cnv = document.getElementById("cnv-genres");
      if (cnv) {
        const all = Array.isArray(stats?.genresAll)
          ? stats.genresAll
          : stats?.genresTop || stats?.genres || [];
        const entries = all.filter(function (item) {
          var k = item[0],
            v = item[1];
          return k && String(k).toLowerCase() !== "інші" && +v > 0;
        });
        const left = [],
          right = [];
        for (var i = 0; i < entries.length; i++) {
          (i % 2 === 0 ? left : right).push(entries[i]);
        }
        withRounded(cnv, () => drawBar2Cols(cnv, left, right));
      }
    }
  };

  window.__stats_mode = window.__stats_mode || "all";
  window.__getStatsByMode = function () {
    const m = window.__stats_mode || "all";
    if (m === "lp")
      return (
        window.__album_stats_lp ||
        window.__album_stats_all ||
        window.__album_stats ||
        null
      );
    if (m === "ep")
      return (
        window.__album_stats_ep ||
        window.__album_stats_all ||
        window.__album_stats ||
        null
      );
    return window.__album_stats_all || window.__album_stats || null;
  };

  window.setupStats = function (albums) {
    const old = document.getElementById("open-stats-btn");
    if (old) old.remove();
    if (typeof createStatsModal === "function") createStatsModal();

    const arr = Array.isArray(albums) ? albums : [];
    const getType = (a) => String(a.type ?? a.Type ?? "").toLowerCase();
    const isLP = (a) => /\b(album|lp)\b/.test(getType(a));
    const isEP = (a) => /\bep\b/.test(getType(a));

    window.__album_stats_all = computeAlbumStats(arr);
    window.__album_stats_lp = computeAlbumStats(arr.filter(isLP));
    window.__album_stats_ep = computeAlbumStats(arr.filter(isEP));

    window.__albums_all_for_stats = arr.slice();
    window.__albums_lp_for_stats = arr.filter(isLP);
    window.__albums_ep_for_stats = arr.filter(isEP);

    window.__stats_mode = window.__stats_mode || "all";

    if (typeof fixPos === "function") {
      fixPos();
      requestAnimationFrame(fixPos);
      setTimeout(fixPos, 0);
    }
  };
})();

async function init() {
  try {
    await loadAllowedArtists();
  } catch (e) {
    console.warn(
      "Не вдалося завантажити список артистів — показуємо всі альбоми",
    );
  }

  loadCsvWithRetry(
    newSheetUrl,
    {
      download: true,
      header: true,
      complete: function (results) {
        const rawData = results.data;
        processAlbumData(rawData);
        const loading = document.getElementById("loading-screen");
        if (loading) {
          loading.classList.add("hidden");
          loading.addEventListener("transitionend", () => loading.remove(), {
            once: true,
          });
        }
        populateFilters();
        populateLabelOptions();
        if (typeof window.readGenreModes !== "function") {
          const anyBtn = document.getElementById("mode-any");
          const allBtn = document.getElementById("mode-all");
          const onlyBtn = document.getElementById("mode-only");
          if (
            anyBtn &&
            !anyBtn.classList.contains("active") &&
            allBtn &&
            !allBtn.classList.contains("active")
          ) {
            anyBtn.classList.add("active");
            anyBtn.setAttribute("aria-pressed", "true");
          }
        }
        initBasicCustomSelect(document.getElementById("sort-order"));
        const pgOpt = document.querySelector(
          '#sort-order .option[data-value="popularity-growth"]',
        );
        if (pgOpt)
          attachTooltip(
            pgOpt,
            "Вгорі будуть показані альбоми, популярність яких зростає швидше за інші",
            "180px",
          );
        const sortSel = document
          .getElementById("sort-order")
          .querySelector(".selected");
        if (!sortSel.dataset.value) sortSel.dataset.value = "desc";
        initBasicCustomSelect(document.getElementById("duration-filter"));
        initBasicCustomSelect(document.getElementById("track-count-filter"));
        initBasicCustomSelect(document.getElementById("release-period-filter"));
        (function initReleasePeriodSlider() {
          const start = document.getElementById("release-period-start");
          const end = document.getElementById("release-period-end");
          const wrapper = document.getElementById("release-period-range");
          const dates = albumsData.map((a) => new Date(a.date));
          const minDate = new Date(Math.min(...dates));
          const now = new Date();
          const maxW = Math.ceil((now - minDate) / (7 * 24 * 60 * 60 * 1000));

          const weekOptions = [];
          for (let i = 0; i <= maxW; i++) {
            const d = new Date(minDate.getTime() + i * 7 * 24 * 60 * 60 * 1000);
            weekOptions.push(d.toISOString().slice(0, 10));
          }
          localStorage.setItem(
            "release-week-options",
            JSON.stringify(weekOptions),
          );

          [start, end].forEach((el) => {
            el.min = 0;
            el.max = maxW;
            el.step = 1;
          });
          start.value = 0;
          end.value = maxW;

          let debounce;
          function updateRange(skipApply = false) {
            const s = +start.value;
            const e = +end.value;

            const d1 = new Date(
              minDate.getTime() + s * 7 * 24 * 60 * 60 * 1000,
            );
            const d2 = new Date(
              minDate.getTime() + e * 7 * 24 * 60 * 60 * 1000,
            );
            const sd = d1.toISOString().slice(0, 10);
            const td = d2.toISOString().slice(0, 10);

            const sel = document.querySelector(
              "#release-period-filter .selected",
            );
            if (sel) {
              if (s === 0 && e === maxW) {
                sel.textContent = "За будь-який час";
                delete sel.dataset.value;
              } else {
                sel.textContent = `${sd} – ${td}`;
                sel.dataset.value = "range";
              }
            }

            wrapper.style.setProperty("--start", (s / maxW) * 100 + "%");
            wrapper.style.setProperty("--end", (e / maxW) * 100 + "%");

            clearTimeout(debounce);
            if (!skipApply) {
              debounce = setTimeout(() => {
                saveFiltersToCache();
                smoothApplyFilters();
              }, 500);
            }
          }

          start.addEventListener("input", () => {
            if (+start.value > +end.value) start.value = end.value;
            updateRange(false);
          });

          end.addEventListener("input", () => {
            if (+end.value < +start.value) end.value = start.value;
            updateRange(false);
          });

          updateRange(true);
          window.updateReleaseRangeTip = updateRange;
        })();

        (function initDurationSlider() {
          const start = document.getElementById("duration-start");
          const end = document.getElementById("duration-end");
          const wrapper = document.getElementById("duration-range");
          const mins = albumsData.map((a) => {
            const [h, m] = (a.duration || "00:00:00").split(":").map((x) => +x);
            return h * 60 + m;
          });
          const minV = Math.min(...mins),
            maxV = Math.max(...mins);
          [start, end].forEach((el) => {
            el.min = minV;
            el.max = maxV;
            el.step = 1;
          });
          start.value = minV;
          end.value = maxV;
          let debounce;
          function upd(skipApply = false) {
            const s = +start.value,
              e = +end.value;
            const sel = document.querySelector("#duration-filter .selected");
            if (s === minV && e === maxV) {
              sel.textContent = "Будь-яка тривалість";
              sel.removeAttribute("data-value");
            } else if (s === minV) {
              sel.textContent = `До ${e} хв`;
              sel.dataset.value = `${minV}-${e}`;
            } else if (e === maxV) {
              sel.textContent = `Від ${s} хв`;
              sel.dataset.value = `${s}-${maxV}`;
            } else {
              sel.textContent = `${s}–${e} хв`;
              sel.dataset.value = "range";
            }

            wrapper.style.setProperty(
              "--start",
              ((s - minV) / (maxV - minV)) * 100 + "%",
            );
            wrapper.style.setProperty(
              "--end",
              ((e - minV) / (maxV - minV)) * 100 + "%",
            );
            clearTimeout(debounce);
            if (!skipApply) {
              debounce = setTimeout(() => {
                saveFiltersToCache();
                smoothApplyFilters();
              }, 300);
            }
          }
          start.addEventListener("input", () => {
            if (+start.value > +end.value) start.value = end.value;
            upd(false);
          });
          end.addEventListener("input", () => {
            if (+end.value < +start.value) end.value = start.value;
            upd(false);
          });
          upd(true);
        })();

        (function initTrackCountSlider() {
          const start = document.getElementById("track-count-start");
          const end = document.getElementById("track-count-end");
          const wrapper = document.getElementById("track-count-range");
          const cnts = albumsData.map((a) => a.tracksIDs.length);
          const minV = Math.min(...cnts),
            maxV = Math.max(...cnts);
          [start, end].forEach((el) => {
            el.min = minV;
            el.max = maxV;
            el.step = 1;
          });
          start.value = minV;
          end.value = maxV;
          let debounce;
          function upd(skipApply = false) {
            const s = +start.value,
              e = +end.value;
            const sel = document.querySelector("#track-count-filter .selected");
            if (s === minV && e === maxV) {
              sel.textContent = "Будь-яка кількість";
              sel.removeAttribute("data-value");
            } else if (s === minV) {
              sel.textContent = `До ${e} треків`;
              sel.dataset.value = `${minV}-${e}`;
            } else if (e === maxV) {
              sel.textContent = `Від ${s} треків`;
              sel.dataset.value = `${s}-${maxV}`;
            } else {
              sel.textContent = `${s}–${e} треків`;
              sel.dataset.value = "range";
            }

            wrapper.style.setProperty(
              "--start",
              ((s - minV) / (maxV - minV)) * 100 + "%",
            );
            wrapper.style.setProperty(
              "--end",
              ((e - minV) / (maxV - minV)) * 100 + "%",
            );
            clearTimeout(debounce);
            if (!skipApply) {
              debounce = setTimeout(() => {
                saveFiltersToCache();
                smoothApplyFilters();
              }, 300);
            }
          }
          start.addEventListener("input", () => {
            if (+start.value > +end.value) start.value = end.value;
            upd(false);
          });
          end.addEventListener("input", () => {
            if (+end.value < +start.value) end.value = start.value;
            upd(false);
          });
          upd(true);
        })();

        (function initListenCountSlider() {
          const start = document.getElementById("listen-count-start");
          const end = document.getElementById("listen-count-end");
          const wrapper = document.getElementById("listen-count-range");

          const allListens = albumsData.map((a) => a.listens || 0);
          const posListens = allListens
            .filter((x) => x > 0)
            .sort((a, b) => a - b);
          if (posListens.length === 0) {
            posListens.push(1000);
          }

          const BINS = 100;
          const N = posListens.length;
          const steps = [0];
          for (let i = 1; i <= BINS; i++) {
            const idx = Math.floor(((i - 1) * (N - 1)) / (BINS - 1));
            steps.push(posListens[idx]);
          }

          [start, end].forEach((el) => {
            el.min = 0;
            el.max = steps.length - 1;
            el.step = 1;
          });
          start.value = 0;
          end.value = steps.length - 1;

          let debounce;

          function update(skipApply = false) {
            let i = +start.value;
            let j = +end.value;
            if (i > j) {
              i = j;
              start.value = i;
            }
            if (j < i) {
              j = i;
              end.value = j;
            }

            const sVal = steps[i];
            const eVal = steps[j];
            const sel = document.querySelector(
              "#listen-count-filter .selected",
            );

            if (i === 0 && j === steps.length - 1) {
              sel.textContent = "Будь-яка кількість";
              sel.removeAttribute("data-value");
            } else if (i === 0) {
              sel.textContent = `До ${formatListens(eVal)}`;
              sel.dataset.value = `0-${eVal}`;
            } else if (j === steps.length - 1) {
              sel.textContent = `Від ${formatListens(sVal)}`;
              sel.dataset.value = `${sVal}-`;
            } else {
              sel.textContent = `${formatListens(sVal)}–${formatListens(eVal)}`;
              sel.dataset.value = `${sVal}-${eVal}`;
            }

            const L = steps.length - 1;
            wrapper.style.setProperty("--start", (i / L) * 100 + "%");
            wrapper.style.setProperty("--end", (j / L) * 100 + "%");

            clearTimeout(debounce);
            if (!skipApply) {
              debounce = setTimeout(() => {
                saveFiltersToCache();
                smoothApplyFilters();
              }, 200);
            }
          }

          start.addEventListener("input", () => update(false));
          end.addEventListener("input", () => update(false));

          update(true);
        })();
        initBasicCustomSelect(document.getElementById("listen-count-filter"));
        attachGlobalEventListeners();

        const toggleEditBtn = document.getElementById("toggle-edit-presets");
        attachTooltip(toggleEditBtn, "Редагувати список фільтрів", "180px");
        const addPresetBtn = document.getElementById("add-preset");
        attachTooltip(addPresetBtn, "Створити фільтр", "160px");
        ensureDefaultPresets();
        loadPresetsFromStorage();

        const addBtn = document.getElementById("add-preset");
        const modal = document.getElementById("preset-modal");
        const closeX = document.getElementById("preset-close");
        const saveBtn = document.getElementById("preset-save");
        const inputName = document.getElementById("preset-name-input");
        const inputDesc = document.getElementById("preset-desc-input");

        const restoreBtn = document.getElementById("preset-restore");
        if (restoreBtn && !restoreBtn.dataset.bound) {
          restoreBtn.addEventListener("click", restoreDefaultsAndNotify);

          restoreBtn.addEventListener("mouseenter", (e) => {
            if (restoreBtn.style.display === "none") return;
            const hasUser = (function () {
              const STD = new Set([
                "Актуальне",
                "Популярні альбоми",
                "Великі релізи",
                "Хорошого потроху",
              ]);
              return getStoredPresets().some((p) => !STD.has(p.name));
            })();
            if (!hasUser) return;
            if (typeof removeTooltip === "function") removeTooltip(restoreBtn);
            if (typeof attachTooltip === "function")
              attachTooltip(restoreBtn, "Ваші фільтри будуть збережені");
            if (typeof moveSimpleTooltip === "function")
              moveSimpleTooltip(e.clientX, e.clientY);
          });

          restoreBtn.addEventListener("mousemove", (e) => {
            if (restoreBtn.style.display === "none") return;
            const hasUser = (function () {
              const STD = new Set([
                "Актуальне",
                "Популярні альбоми",
                "Великі релізи",
                "Хорошого потроху",
              ]);
              return getStoredPresets().some((p) => !STD.has(p.name));
            })();
            if (!hasUser) return;
            if (typeof moveSimpleTooltip === "function")
              moveSimpleTooltip(e.clientX, e.clientY);
          });

          restoreBtn.addEventListener("mouseleave", () => {
            if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
            if (typeof removeTooltip === "function") removeTooltip(restoreBtn);
          });

          restoreBtn.dataset.bound = "1";
        }

        addBtn.addEventListener("click", () => {
          inputName.value = "";
          modal.style.display = "block";
          document.body.style.overflow = "hidden";
          inputName.focus();
          if (inputDesc) inputDesc.value = "";

          updateRestorePresetUI();

          const oldBtn = document.getElementById("preset-restore");
          if (oldBtn) {
            const newBtn = oldBtn.cloneNode(true);
            oldBtn.parentNode.replaceChild(newBtn, oldBtn);

            newBtn.addEventListener("click", restoreDefaultsAndNotify);

            newBtn.addEventListener("mouseenter", (e) => {
              if (newBtn.style.display === "none") return;
              if (newBtn.dataset.missingDefaults !== "1") return;
              if (newBtn.dataset.hasUser !== "1") return;
              if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
              if (typeof showSimpleTooltip === "function") {
                showSimpleTooltip(
                  e.clientX,
                  e.clientY,
                  "Ваші фільтри будуть збережені",
                );
              } else if (typeof attachTooltip === "function") {
                attachTooltip(newBtn, "Ваші фільтри будуть збережені");
              }
            });

            newBtn.addEventListener("mousemove", (e) => {
              if (newBtn.style.display === "none") return;
              if (newBtn.dataset.missingDefaults !== "1") return;
              if (newBtn.dataset.hasUser !== "1") return;
              if (typeof moveSimpleTooltip === "function")
                moveSimpleTooltip(e.clientX, e.clientY);
            });

            newBtn.addEventListener("mouseleave", () => {
              if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
              if (typeof removeTooltip === "function") removeTooltip(newBtn);
            });
          }
        });

        closeX.addEventListener("click", () => {
          modal.style.display = "none";
          document.body.style.overflow = "auto";
        });

        modal.addEventListener("click", (e) => {
          if (e.target === modal) {
            modal.style.display = "none";
            document.body.style.overflow = "auto";
          }
        });

        const editNameModal = document.getElementById("edit-name-modal");
        const editNameClose = editNameModal.querySelector(".close");

        editNameClose.addEventListener("click", () => {
          editNameModal.style.display = "none";
          document.body.style.overflow = "auto";
        });

        editNameModal.addEventListener("click", (e) => {
          if (e.target === editNameModal) {
            editNameModal.style.display = "none";
            document.body.style.overflow = "auto";
          }
        });

        const saveMsg = document.getElementById("preset-save-message");
        saveBtn.addEventListener("click", () => {
          const name = inputName.value.trim();
          if (!name) {
            saveMsg.textContent = "Вкажіть назву фільтра";
            saveMsg.className = "error";
            setTimeout(() => {
              saveMsg.textContent = "";
              saveMsg.className = "";
            }, 2000);
            return;
          }
          saveMsg.textContent = "";
          saveMsg.className = "";

          saveFiltersToCache();
          const arr = getStoredPresets();
          const cf = JSON.parse(localStorage.getItem("albumFilters") || "{}");
          const desc = (inputDesc?.value || "").trim().slice(0, 250);
          const presetObj = { name, filters: cf, ...(desc ? { desc } : {}) };
          const idx = arr.findIndex((p) => p.name === name);
          if (idx >= 0) arr[idx] = presetObj;
          else arr.push(presetObj);

          savePresetsToStorage(arr);
          loadPresetsFromStorage();
          updateRestorePresetUI();
          modal.style.display = "none";
        });

        const wrap = document.querySelector(".presets-wrapper");
        const fc = document.getElementById("filters-container");
        const filtersButton = document.getElementById("filters-button");

        function updateFade() {
          const overflow = wrap.scrollWidth > wrap.clientWidth;
          const atLeft = wrap.scrollLeft > 0;
          const atRight = wrap.scrollLeft + wrap.clientWidth < wrap.scrollWidth;
          fc.classList.toggle("scrolled", atLeft);
          fc.classList.toggle("scrolled-right", overflow && atRight);
        }

        wrap.addEventListener("scroll", updateFade);
wrap.addEventListener(
  "wheel",
  (e) => {
    const el = wrap;

    if (el.scrollWidth <= el.clientWidth) return;

    const dx = e.deltaX || 0;
    const dy = e.deltaY || 0;
    const delta = Math.abs(dy) >= Math.abs(dx) ? dy : dx;
    if (!delta) return;

    const before = el.scrollLeft;
    el.scrollLeft += delta;

    if (el.scrollLeft !== before) e.preventDefault();

    requestAnimationFrame(updateFade);
  },
  { passive: false }
);

        filtersButton.addEventListener("click", () => {
          requestAnimationFrame(updateFade);
        });

        requestAnimationFrame(updateFade);
        window.addEventListener("resize", updateFade);
        setupStats(albumsData);

        const albumFilters =
          JSON.parse(localStorage.getItem("albumFilters")) || null;
        if (albumFilters) {
          loadFiltersAfterRender();
        } else {
          window.applyDefaultFilters();
        }
      },
      error: function (error) {
        console.error("Помилка під час завантаження CSV:", error);
      },
    },
    3,
    1000,
    fallbackSheetUrl,
  );
}

function initBasicCustomSelect(select) {
  const selected = select.querySelector(".selected");
  const optionsContainer = select.querySelector(".options-container");

  selected.addEventListener("click", (e) => {
    e.stopPropagation();
    document.querySelectorAll(".custom-select").forEach((otherSelect) => {
      if (otherSelect !== select) {
        otherSelect.querySelector(".options-container").style.display = "none";
        otherSelect.classList.remove("open");
      }
    });

    (function(){
      const ls = document.querySelector('#label-select .option-search');
      const lc = document.querySelector('#label-select .options-container');
      if (ls && lc && lc.style.display !== "flex") {
        if (ls.value) { ls.value = ""; ls.dispatchEvent(new Event("input", { bubbles: true })); }
      }
    })();

    const isOpen = optionsContainer.style.display === "flex";
    if (!isOpen) {
      const r = select.getBoundingClientRect();
      optionsContainer.style.display = "flex";
      const h = optionsContainer.scrollHeight;
      optionsContainer.style.display = "none";
      if (r.bottom + h > window.innerHeight) select.classList.add("upward");
      else select.classList.remove("upward");
    }
    optionsContainer.style.display = isOpen ? "none" : "flex";
    select.classList.toggle("open", !isOpen);
  });

  optionsContainer.querySelectorAll(".option").forEach((option) => {
    option.addEventListener("click", () => {
      selected.textContent = option.textContent;
      selected.dataset.value = option.dataset.value;
      optionsContainer.style.display = "none";
      select.classList.remove("open");

      if (select.id === "release-period-filter") {
        const start = document.getElementById("release-period-start");
        const end = document.getElementById("release-period-end");
        const wrapper = document.getElementById("release-period-range");
        start.value = start.min;
        end.value = end.max;
        wrapper.style.setProperty("--start", "0%");
        wrapper.style.setProperty("--end", "100%");
      }
      if (select.id === "duration-filter") {
        document.getElementById("duration-start").value =
          document.getElementById("duration-start").min;
        document.getElementById("duration-end").value =
          document.getElementById("duration-end").max;
        document.getElementById("duration-range").style.setProperty("--start", "0%");
        document.getElementById("duration-range").style.setProperty("--end", "100%");
      }
      if (select.id === "track-count-filter") {
        document.getElementById("track-count-start").value =
          document.getElementById("track-count-start").min;
        document.getElementById("track-count-end").value =
          document.getElementById("track-count-end").max;
        document.getElementById("track-count-range").style.setProperty("--start", "0%");
        document.getElementById("track-count-range").style.setProperty("--end", "100%");
      }
      if (select.id === "listen-count-filter") {
        document.getElementById("listen-count-start").value =
          document.getElementById("listen-count-start").min;
        document.getElementById("listen-count-end").value =
          document.getElementById("listen-count-end").max;
        document.getElementById("listen-count-range").style.setProperty("--start", "0%");
        document.getElementById("listen-count-range").style.setProperty("--end", "100%");
      }

      if (select.id === "sort-order") sortOrder = option.dataset.value;

      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });
  });

  document.addEventListener("click", (e) => {
    if (!select.contains(e.target)) {
      optionsContainer.style.display = "none";
      select.classList.remove("open");

      if (select.id === "label-select") {
        const ls = select.querySelector(".option-search");
        if (ls && ls.value) { ls.value = ""; ls.dispatchEvent(new Event("input", { bubbles: true })); }
      }
    }
  });
}

function friendlyGenreLabel(g) {
  if (g === "producing work for international") return "intl prod";
  if (g === "ai") return "AI";
  if (g === "instrumental rock") return "alt. instrumental";
  if (g === "like old trash") return "estrade";
  return g;
}

function formatListens(num) {
  if (num >= 10000) {
    return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
  }
  return num;
}

function processAlbumData(rawData) {
  albumsData.length = 0;

  const seenAlbumIDs = new Set();

  rawData.forEach((item) => {
    if (!item.alName || !item.Type) return;
    if (item.excluded && item.excluded.trim() === "+") return;

    const type = item.Type.toLowerCase();

    const artistIDs = item.artID
      ? item.artID
          .split(",")
          .map((id) => id.trim())
          .filter((id) => id)
      : [];

    if (
      allowedArtistIds.size > 0 &&
      type !== "compilation" &&
      !artistIDs.some((id) => allowedArtistIds.has(id))
    ) {
      return;
    }

    const albumID = item.alURL;

    if (seenAlbumIDs.has(albumID)) return;
    seenAlbumIDs.add(albumID);

    const album = {
      nameAlbum: item.alName,
      albumID,
      date: item.Date,
      type,
      cover: item.Cover,
      genres: (() => {
        let base = item.Genres
          ? item.Genres.split(", ")
              .map((g) => g.trim())
              .filter((g) => g)
          : [];
        let extra = item.addGenre
          ? item.addGenre
              .split(",")
              .map((g) => g.trim())
              .filter((g) => g)
          : [];

        extra.forEach((g) => {
          if (g.startsWith("-")) {
            base = base.filter((bg) => bg !== g.slice(1).trim());
          }
        });
        extra.forEach((g) => {
          if (!g.startsWith("-") && !base.includes(g)) {
            base.push(g);
          }
        });
        if (base.includes("like old trash") && base.includes("pop/indie")) {
          base = base.filter((g) => g !== "pop/indie");
        }
        return base;
      })(),
      languages: (() => {
        let base = item.Lang
          ? item.Lang.split(", ")
              .map((l) => {
                const t =
                  l.trim().toLowerCase() === "no voice"
                    ? "без голосу"
                    : l.trim();
                return t;
              })
              .filter((l) => l)
          : [];
        let extra = item.addLang
          ? item.addLang
              .split(",")
              .map((l) => {
                const t =
                  l.trim().toLowerCase() === "no voice"
                    ? "без голосу"
                    : l.trim();
                return t;
              })
              .filter((l) => l)
          : [];

        extra.forEach((l) => {
          if (l.startsWith("-")) {
            base = base.filter((bl) => bl !== l.slice(1).trim());
          }
        });
        extra.forEach((l) => {
          if (!l.startsWith("-") && !base.includes(l)) {
            base.push(l);
          }
        });
        return base;
      })(),
      listens: parseInt(item.Listens, 10) || 0,
      label: item.Label || "",
      duration: item.Duration || "",
      tracksIDs: item.Tracks
        ? item.Tracks.split(",")
            .map((t) => t.trim())
            .filter((t) => t)
        : [],
      tracksMP3: item.MP3
        ? item.MP3.split(",")
            .map((m) => m.trim())
            .filter((m) => m)
        : [],
      good: item.Good && item.Good.trim() === "+",
      artistNames: item.artName
        ? item.artName
            .split(",,")
            .map((a) => a.trim())
            .filter((a) => a)
        : [],
      artistIDs,
      listened: !!listenedAlbums[item.alURL],
      growthScore: -Infinity,
    };

    if (item.Listens) {
      const history = item.Listens.split(",")
        .map((x) => parseInt(x.trim(), 10))
        .filter((n) => !isNaN(n));
      if (history.length >= 2) {
        const recent = history.slice(0, 8);
        const deltas = [];
        for (let i = 0; i < recent.length - 1; i++) {
          deltas.push(recent[i] - recent[i + 1]);
        }
        album.growthScore = deltas.reduce((a, b) => a + b, 0) / deltas.length;
      }
    }

    album.popularity = ((p) => (Number.isFinite(p) ? p : -Infinity))(
      parseInt(item.Popularity, 10),
    );
    albumsData.push(album);
  });
}

function populateFilters() {
  const genreContainer = document.getElementById("genre-checkboxes");
  const languageContainer = document.getElementById("language-checkboxes");
  const releaseTypeContainer = document.getElementById(
    "release-type-checkboxes",
  );

  const genresCountMap = new Map();
  const languagesCountMap = new Map();
  const releaseTypesSet = new Set();

  albumsData.forEach((album) => {
    album.genres.forEach((genre) => {
      genresCountMap.set(genre, (genresCountMap.get(genre) || 0) + 1);
    });
    if (album.languages.length === 0) {
      languagesCountMap.set(
        "без голосу",
        (languagesCountMap.get("без голосу") || 0) + 1,
      );
    } else {
      album.languages.forEach((lang) => {
        const mappedLang =
          lang.trim().toLowerCase() === "no voice" ? "без голосу" : lang;
        languagesCountMap.set(
          mappedLang,
          (languagesCountMap.get(mappedLang) || 0) + 1,
        );
      });
    }
    releaseTypesSet.add(album.type);
  });

  const desiredGenreOrder = [
    "pop/indie",
    "rock",
    "hip-hop",
    "electronic",
    "metal",
    "post-punk",
    "trap",
    "phonk",
    "folk",
    "jazz",
    "worship",
    "instrumental",
    "instrumental rock",
    "piano",
    "synthwave",
    "cinematic",
    "hyperpop",
    "vocal guitar",
    "vocal piano",
    "cover",
    "remix",
    "live",
    "phonk beats",
    "beats rap",
    "beats lo-fi",
    "chillout",
    "drone",
    "exp. electronic",
    "exp. instrumental",
    "like old trash",
    "opera",
    "a cappella",
    "background",
    "jersey club",
    "ai",
    "producing work for international",
    "christmas",
  ];

  const sortedGenres = [
    ...desiredGenreOrder
      .filter((genre) => genresCountMap.has(genre))
      .map((genre) => [genre, genresCountMap.get(genre)]),
    ...[...genresCountMap.entries()]
      .filter(([genre]) => !desiredGenreOrder.includes(genre))
      .sort((a, b) => a[0].localeCompare(b[0])),
  ];

  genreContainer.innerHTML = "";
  const genreFrag = document.createDocumentFragment();
  sortedGenres.forEach(([genre, count]) => {
    const div = document.createElement("div");
    div.classList.add("genre-filter-item");

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.value = genre;
    checkbox.id = `genre-${encodeURIComponent(genre)}`;
    checkbox.classList.add("genre-checkbox");

    const label = document.createElement("label");
    label.htmlFor = checkbox.id;

    const genreName = document.createElement("span");
    genreName.classList.add("genre-name");
    genreName.textContent = friendlyGenreLabel(genre);

    if (genre === "producing work for international") {
      attachTooltip(
        genreName,
        "Музика українських продюсерів для іноземних артистів",
        "180px",
      );
    }

    const genreCount = document.createElement("span");
    genreCount.classList.add("genre-count");
    genreCount.textContent = ` (${count})`;

    const genreCross = document.createElement("span");
    genreCross.textContent = "✖";
    genreCross.classList.add("exclude-genre");
    genreCross.style.cursor = "pointer";
    genreCross.setAttribute("data-genre", genre);

    label.appendChild(genreName);
    label.appendChild(genreCount);

    div.appendChild(checkbox);
    div.appendChild(label);
    div.appendChild(genreCross);
    genreFrag.appendChild(div);
  });

  genreContainer.appendChild(genreFrag);

  const defaultLangOrder = ["ukr", "eng", "rus", "other lang", "без голосу"];
  languageContainer.innerHTML = "";
  const languageFrag = document.createDocumentFragment();
  defaultLangOrder.forEach((langKey) => {
    const count = languagesCountMap.get(langKey) || 0;
    if (count > 0 || langKey === "без голосу") {
      const div = document.createElement("div");
      div.classList.add("language-filter-item");

      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.value = langKey;
      checkbox.id = `language-${encodeURIComponent(langKey)}`;
      checkbox.classList.add("language-checkbox");

      const label = document.createElement("label");
      label.htmlFor = checkbox.id;

      const languageName = document.createElement("span");
      languageName.classList.add("language-name");
      languageName.textContent = languageLabels[langKey] || langKey;

      const languageCount = document.createElement("span");
      languageCount.classList.add("language-count");
      languageCount.textContent = ` (${count})`;

      const languageCross = document.createElement("span");
      languageCross.textContent = "✖";
      languageCross.classList.add("exclude-language");
      languageCross.style.cursor = "pointer";
      languageCross.setAttribute("data-language", langKey);

      label.appendChild(languageName);
      label.appendChild(languageCount);

      div.appendChild(checkbox);
      div.appendChild(label);
      div.appendChild(languageCross);
      languageFrag.appendChild(div);
    }
  });

  languageContainer.appendChild(languageFrag);

  releaseTypeContainer.innerHTML = "";
  const releaseTypeLabels = {
    album: "LP",
    ep: "EP",
    compilation: "Компіляції",
  };
  const releaseTypeCounts = {};
  albumsData.forEach((album) => {
    releaseTypeCounts[album.type] = (releaseTypeCounts[album.type] || 0) + 1;
  });

  releaseTypesSet.forEach((rType) => {
    const div = document.createElement("div");
    div.classList.add("release-type-filter-item");

    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.value = rType;
    checkbox.id = `release-type-${rType}`;
    checkbox.classList.add("release-type-checkbox");

    const label = document.createElement("label");
    label.htmlFor = checkbox.id;
    label.innerHTML = `${releaseTypeLabels[rType] || rType} <span class="genre-count">(${releaseTypeCounts[rType] || 0})</span>`;

    div.appendChild(checkbox);
    div.appendChild(label);
    releaseTypeContainer.appendChild(div);
  });
}

function populateLabelOptions() {

  const map = new Map();

  albumsData.forEach((al) => {
    if (!al.label || al.artistNames.length === 0) return;
    const artist = al.artistNames[0];
    const canon  = canonLabel(al.label);
    if (artist === al.label || artist === canon) return;

    if (!map.has(canon)) {
      map.set(canon, { artists: new Set(), releases: 0, listens: 0 });
    }

    const st = map.get(canon);
    st.artists.add(artist);
    st.releases += 1;

    const ls = parseInt(al.listens, 10) || 0;
    st.listens += ls;
  });

  const FORCE_INCLUDE = new Set(["VG STAR"]);

  const labels = Array.from(map.entries())
    .filter(([canon, st]) => st.artists.size >= 3 || (FORCE_INCLUDE.has(canon) && st.artists.size > 0))
    .map(([canon, st]) => ({
      name: canon,
      releases: st.releases,
      artists: st.artists.size,
      listens: st.listens
        }))
    .sort((a, b) => (b.listens - a.listens) || a.name.localeCompare(b.name, "uk"));

  const select = document.getElementById("label-select");
  const optsContainer = select.querySelector(".options-container");
  optsContainer.innerHTML = `
  <div class="option-fixed">
    <div class="option option-all-labels" data-value="">Усі лейбли</div>
    <input type="text" class="option-search" placeholder="Пошук лейблів…">
  </div>
  <div class="option-list"></div>
`;

  const listContainer = optsContainer.querySelector(".option-list");
  labels.forEach((lbl) => {
    const o = document.createElement("div");
    o.className = "option";
    o.dataset.value    = lbl.name;
    o.dataset.releases = String(lbl.releases);
    o.dataset.artists  = String(lbl.artists);
    o.dataset.listens  = String(lbl.listens);
    o.textContent  = lbl.name;
    listContainer.appendChild(o);
  });

  initCustomSelect(select);
}

function initCustomSelect(select) {
  const selected = select.querySelector(".selected");
  const optionsContainer = select.querySelector(".options-container");
  const listContainer = optionsContainer.querySelector(".option-list");
  const fixedContainer = optionsContainer.querySelector(".option-fixed");
  const searchInput = fixedContainer.querySelector(".option-search");

  const clearLabelSearch = () => {
    if (select.id === 'label-select' && searchInput && searchInput.value) {
      searchInput.value = '';
      searchInput.dispatchEvent(new Event('input', { bubbles: true }));
    }
  };

    let labelSortMode = 'listens';
let sortbar;
if (select.id === 'label-select') {
  sortbar = document.createElement('div');
  sortbar.className = 'label-sortbar';
  sortbar.innerHTML = `
    <span class="label-sortbar-title">Сортувати лейбли:</span>

        <button type="button" data-mode="name" aria-label="За назвою">
      <i class="fas fa-solid fa-sort-alpha-down fa-fw"></i>
    </button>

    <button type="button" data-mode="releases" aria-label="За кількістю релізів">
      <i class="fas fa-solid fa-layer-group fa-fw"></i>
    </button>

    <button type="button" data-mode="artists" aria-label="За кількістю артистів">
      <i class="fas fa-solid fa-users fa-fw"></i>
    </button>

    <button type="button" data-mode="listens" class="active" aria-label="За сумою прослуховувань">
      <i class="fas fa-solid fa-headphones fa-fw"></i>
    </button>
  `;
  fixedContainer.insertBefore(sortbar, fixedContainer.firstChild);

  try {
    const buttons = sortbar.querySelectorAll('button[data-mode]');
    buttons.forEach((btn) => {
      btn.removeAttribute('title');
      const text = btn.getAttribute('aria-label') || '';

      attachTooltip(btn, text);
    });
  } catch (_) {}
  
    sortbar.addEventListener('click', (e) => {
      const btn = e.target.closest('button');
      if (!btn) return;
      const mode = btn.getAttribute('data-mode');
      if (!mode) return;
      labelSortMode = mode;
      sortbar.querySelectorAll('button').forEach(b => b.classList.toggle('active', b === btn));
      applySortAndFilter();
    });
  }

  let noResults = listContainer.querySelector('.no-results');
  if (!noResults) {
    noResults = document.createElement('div');
    noResults.className = 'no-results';
    noResults.textContent = 'Такого лейбла не знайдено';
    listContainer.appendChild(noResults);
  }

  const clearBtn = document.createElement('button');
  clearBtn.type = 'button';
  clearBtn.className = 'option-clear';
  clearBtn.setAttribute('aria-label','Очистити');
  clearBtn.textContent = '✖';
  fixedContainer.appendChild(clearBtn);

  const toggleClear = () => { clearBtn.classList.toggle('visible', !!searchInput.value); };
  toggleClear();
  searchInput.addEventListener('input', toggleClear);

  function placeClear(){
    const ip = searchInput;
    const p  = fixedContainer;
    const h  = 16;
    const ipTop = ip.offsetTop;
    const ipH   = ip.offsetHeight || 32;
    clearBtn.style.top = (ipTop + (ipH - h)/2) + 'px';
  }
  placeClear();

  try { new ResizeObserver(placeClear).observe(searchInput); } catch(e){}
  window.addEventListener('resize', placeClear, { passive: true });
  fixedContainer.addEventListener('transitionend', placeClear, true);

  clearBtn.addEventListener('mousedown', e => e.preventDefault());
  clearBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    searchInput.value = '';
    searchInput.dispatchEvent(new Event('input', { bubbles: true }));
    searchInput.focus();
    placeClear();
    applySortAndFilter();
  });

  function applySortAndFilter() {
    if (select.id !== 'label-select') return;

    const q = (searchInput?.value || '').trim().toLowerCase();
    const items = Array.from(listContainer.querySelectorAll('.option'));

    let visible = items.filter(opt => opt.textContent.toLowerCase().includes(q));

    if (labelSortMode === 'name') {
      visible.sort((a,b) => a.textContent.localeCompare(b.textContent, 'uk'));
    } else if (labelSortMode === 'releases') {
      visible.sort((a,b) => (parseInt(b.dataset.releases,10)||0) - (parseInt(a.dataset.releases,10)||0)
                     || a.textContent.localeCompare(b.textContent,'uk'));
    } else if (labelSortMode === 'artists') {
      visible.sort((a,b) => (parseInt(b.dataset.artists,10)||0) - (parseInt(a.dataset.artists,10)||0)
                     || a.textContent.localeCompare(b.textContent,'uk'));
    } else if (labelSortMode === 'listens') {
      visible.sort((a,b) => (parseInt(b.dataset.listens,10)||0) - (parseInt(a.dataset.listens,10)||0)
                     || a.textContent.localeCompare(b.textContent,'uk'));
    }

    items.forEach(el => el.style.display = 'none');
    visible.forEach(el => { el.style.display = ''; listContainer.appendChild(el); });

    noResults.style.display = visible.length ? 'none' : 'flex';
  }

  selected.addEventListener("click", (e) => {
    e.stopPropagation();

    document.querySelectorAll(".custom-select").forEach((otherSelect) => {
      if (otherSelect !== select) {
        const oc = otherSelect.querySelector(".options-container");
        if (oc && oc.style.display === "flex") {
          oc.style.display = "none";
          otherSelect.classList.remove("open");
          if (otherSelect.id === 'label-select') {
            const si = otherSelect.querySelector('.option-search');
            if (si && si.value) { si.value=''; si.dispatchEvent(new Event('input',{bubbles:true})); }
          }
        }
      }
    });

    const isOpen = optionsContainer.style.display === "flex";
    if (!isOpen) {
      const r = select.getBoundingClientRect();
      optionsContainer.style.display = "flex";
      const h = optionsContainer.scrollHeight;
      optionsContainer.style.display = "none";
      if (r.bottom + h > window.innerHeight) select.classList.add("upward");
      else select.classList.remove("upward");
    }
    optionsContainer.style.display = isOpen ? "none" : "flex";
    if (isOpen) clearLabelSearch();
    select.classList.toggle("open", !isOpen);

    if (!isOpen && select.id === 'label-select') applySortAndFilter();
  });

  optionsContainer.querySelectorAll(".option").forEach((option) => {
    option.addEventListener("click", () => {
      selected.textContent = option.textContent;
      selected.dataset.value = option.dataset.value;
      optionsContainer.style.display = "none";
      clearLabelSearch();
      select.classList.remove("open");

      if (select.id === "label-select") {
        labelFilter = option.dataset.value;
      } else if (select.id === "sort-order") {
        sortOrder = option.dataset.value;
      }

      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });
  });

  document.addEventListener("click", (e) => {
    if (!select.contains(e.target)) {
      optionsContainer.style.display = "none";
      clearLabelSearch();
      select.classList.remove("open");
    }
  });

  searchInput.addEventListener("input", () => {
    if (select.id === 'label-select') applySortAndFilter();
    else {
      const q = searchInput.value.trim().toLowerCase();
      listContainer.querySelectorAll(".option").forEach((opt) => {
        opt.style.display = opt.textContent.toLowerCase().includes(q) ? "" : "none";
      });
    }
  });
}

function loadFiltersAfterRender() {
  const filterData = JSON.parse(localStorage.getItem("albumFilters"));
  if (!filterData) return;

  document.querySelectorAll(".genre-checkbox").forEach((ch) => {
    ch.checked = false;
    ch.disabled = false;
    const lb = ch.nextElementSibling;
    lb.style.textDecoration = "none";
    lb.style.color = "#f3f3f3";
  });
  if (Array.isArray(filterData.selectedGenres)) {
    filterData.selectedGenres.forEach((g) => {
      const cb = document.getElementById(`genre-${encodeURIComponent(g)}`);
      if (cb) cb.checked = true;
    });
  }
  if (Array.isArray(filterData.excludedGenres)) {
    filterData.excludedGenres.forEach((g) => {
      const cb = document.getElementById(`genre-${encodeURIComponent(g)}`);
      if (cb) {
        cb.disabled = true;
        const cross = cb.parentNode.querySelector(".exclude-genre");
        cross.textContent = "↻";
        cross.classList.add("repeat-symbol");
        const lb = cb.nextElementSibling;
        lb.style.textDecoration = "line-through";
        lb.style.color = "gray";
      }
    });
  }

  document.querySelectorAll(".language-checkbox").forEach((ch) => {
    ch.checked = false;
    ch.disabled = false;
    const lb = ch.nextElementSibling;
    lb.style.textDecoration = "none";
    lb.style.color = "#f3f3f3";
  });
  if (Array.isArray(filterData.selectedLanguages)) {
    filterData.selectedLanguages.forEach((l) => {
      const cb = document.getElementById(`language-${encodeURIComponent(l)}`);
      if (cb) cb.checked = true;
    });
  }
  if (Array.isArray(filterData.excludedLanguages)) {
    filterData.excludedLanguages.forEach((l) => {
      const cb = document.getElementById(`language-${encodeURIComponent(l)}`);
      if (cb) {
        cb.disabled = true;
        const cross = cb.parentNode.querySelector(".exclude-language");
        cross.textContent = "↻";
        cross.classList.add("language-repeat-symbol");
        const lb = cb.nextElementSibling;
        lb.style.textDecoration = "line-through";
        lb.style.color = "gray";
      }
    });
  }

  document.querySelectorAll(".release-type-checkbox").forEach((ch) => {
    ch.checked = false;
  });
  if (Array.isArray(filterData.selectedReleaseTypes)) {
    filterData.selectedReleaseTypes.forEach((rt) => {
      const cb = document.getElementById(`release-type-${rt}`);
      if (cb) cb.checked = true;
    });
  }

  if (filterData.sortOrder) {
    const select = document.getElementById("sort-order");
    const selected = select.querySelector(".selected");
    const options = select.querySelectorAll(".option");

    const foundOption = Array.from(options).find(
      (opt) => opt.dataset.value === filterData.sortOrder,
    );
    if (foundOption) {
      selected.textContent = foundOption.textContent;
      selected.dataset.value = foundOption.dataset.value;
      sortOrder = filterData.sortOrder;
    }
  }

  if (typeof filterData.hideListened === "boolean") {
    document.getElementById("hide-listened").checked = filterData.hideListened;
    hideListened = filterData.hideListened;

    if (typeof filterData.nuamRecommended === "boolean") {
      document.getElementById("nuam-recommended-checkbox").checked =
        filterData.nuamRecommended;
    }

    const durationSelect = document.getElementById("duration-filter");
    const selDuration = durationSelect.querySelector(".selected");
    const valueDur = filterData.duration || "";
    const optDuration = durationSelect.querySelector(
      `.option[data-value="${valueDur}"]`,
    );

    if (optDuration) {
      selDuration.textContent = optDuration.textContent;
      selDuration.dataset.value = optDuration.dataset.value;

      const durStart = document.getElementById("duration-start");
      const durEnd = document.getElementById("duration-end");
      const durWrapper = document.getElementById("duration-range");
      durStart.value = durStart.min;
      durEnd.value = durEnd.max;
      durWrapper.style.setProperty("--start", "0%");
      durWrapper.style.setProperty("--end", "100%");
    } else if (valueDur === "range") {
  const start = document.getElementById("duration-start");
  const end = document.getElementById("duration-end");

  const minVal = +start.min;
  const maxVal = +end.max;

  let s = +filterData.durationStart;
  let e = +filterData.durationEnd;
  if (Number.isNaN(s)) s = minVal;
  if (Number.isNaN(e)) e = maxVal;
  if (s < minVal) s = minVal;
  if (e > maxVal) e = maxVal;

  start.value = s;
  end.value = e;

  let text;
  if (s === minVal && e !== maxVal) text = `До ${e} хв`;
  else if (s !== minVal && e === maxVal) text = `Від ${s} хв`;
  else text = `${s}–${e} хв`;

  selDuration.textContent = text;
  selDuration.dataset.value = "range";

  const wrapper = document.getElementById("duration-range");
  wrapper.style.setProperty("--start", ((s - minVal) / (maxVal - minVal)) * 100 + "%");
  wrapper.style.setProperty("--end", ((e - minVal) / (maxVal - minVal)) * 100 + "%");
}
 else if (valueDur) {
      const [ds, de] = valueDur.split("-").map(Number);
      const start = document.getElementById("duration-start");
      const end = document.getElementById("duration-end");
      start.value = ds;
      end.value = de;

      const minVal = +start.min,
        maxVal = +start.max;
      let text;
      if (ds === minVal && de !== maxVal) text = `До ${de} хв`;
      else if (ds !== minVal && de === maxVal) text = `Від ${ds} хв`;
      else text = `${ds}–${de} хв`;

      selDuration.textContent = text;
      selDuration.dataset.value = valueDur;

      const wrapper = document.getElementById("duration-range");
      wrapper.style.setProperty(
        "--start",
        ((ds - minVal) / (maxVal - minVal)) * 100 + "%",
      );
      wrapper.style.setProperty(
        "--end",
        ((de - minVal) / (maxVal - minVal)) * 100 + "%",
      );
    } else {
      const defOpt = durationSelect.querySelector(`.option[data-value=""]`);
      selDuration.textContent = defOpt.textContent;
      selDuration.dataset.value = "";
    }

    const trackSelect = document.getElementById("track-count-filter");
    const selTrack = trackSelect.querySelector(".selected");
    const valueTrack = filterData.trackCount || "";
    const optTrack = trackSelect.querySelector(
      `.option[data-value="${valueTrack}"]`,
    );

    if (optTrack) {
      selTrack.textContent = optTrack.textContent;
      selTrack.dataset.value = optTrack.dataset.value;

      const tcStart = document.getElementById("track-count-start");
      const tcEnd = document.getElementById("track-count-end");
      const tcWrapper = document.getElementById("track-count-range");
      tcStart.value = tcStart.min;
      tcEnd.value = tcEnd.max;
      tcWrapper.style.setProperty("--start", "0%");
      tcWrapper.style.setProperty("--end", "100%");
    } else if (valueTrack === "range") {
  const startEl = document.getElementById("track-count-start");
  const endEl = document.getElementById("track-count-end");
  const wrapper = document.getElementById("track-count-range");

  const minT = +startEl.min;
  const maxT = +startEl.max;

  let s = +filterData.trackStart;
  let e = +filterData.trackEnd;
  if (Number.isNaN(s)) s = minT;
  if (Number.isNaN(e)) e = maxT;
  if (s < minT) s = minT;
  if (e > maxT) e = maxT;

  startEl.value = s;
  endEl.value = e;

  let txt;
  if (s === minT && e !== maxT) txt = `До ${e} треків`;
  else if (s !== minT && e === maxT) txt = `Від ${s} треків`;
  else txt = `${s}–${e} треків`;

  selTrack.textContent = txt;
  selTrack.dataset.value = "range";

  wrapper.style.setProperty("--start", ((s - minT) / (maxT - minT)) * 100 + "%");
  wrapper.style.setProperty("--end", ((e - minT) / (maxT - minT)) * 100 + "%");
}
 else if (valueTrack) {
      const [ds, de] = valueTrack.split("-").map(Number);
      document.getElementById("track-count-start").value = ds;
      document.getElementById("track-count-end").value = de;

      let txt;
      const minT = +document.getElementById("track-count-start").min;
      const maxT = +document.getElementById("track-count-start").max;
      if (ds === minT && de !== maxT) txt = `До ${de} треків`;
      else if (ds !== minT && de === maxT) txt = `Від ${ds} треків`;
      else txt = `${ds}–${de} треків`;

      selTrack.textContent = txt;
      selTrack.dataset.value = valueTrack;

      const wrapper = document.getElementById("track-count-range");
      wrapper.style.setProperty(
        "--start",
        ((ds - minT) / (maxT - minT)) * 100 + "%",
      );
      wrapper.style.setProperty(
        "--end",
        ((de - minT) / (maxT - minT)) * 100 + "%",
      );
    } else {
      const defOpt = trackSelect.querySelector(`.option[data-value=""]`);
      selTrack.textContent = defOpt.textContent;
      selTrack.dataset.value = "";
    }

    const periodSelect = document.getElementById("release-period-filter");
    const pSel = periodSelect.querySelector(".selected");
    const startSlider = document.getElementById("release-period-start");
    const endSlider = document.getElementById("release-period-end");
    const wrapper = document.getElementById("release-period-range");

    if (filterData.period === "range") {
      const dates = albumsData.map((a) => new Date(a.date));
      const minD = new Date(Math.min(...dates));
      const sDate = new Date(filterData.periodStart);
      const eDate = new Date(filterData.periodEnd);
      const maxW = parseInt(startSlider.max, 10);
      const ws = Math.min(
        Math.max(Math.round((sDate - minD) / (7 * 24 * 60 * 60 * 1000)), 0),
        maxW,
      );
      const we = Math.min(
        Math.max(Math.round((eDate - minD) / (7 * 24 * 60 * 60 * 1000)), 0),
        maxW,
      );
      startSlider.value = ws;
      endSlider.value = we;

      if (typeof updateReleaseRangeTip === "function") {
        updateReleaseRangeTip(true);
      } else {
        const dates = albumsData.map((a) => new Date(a.date));
        const minDate = new Date(Math.min(...dates));
        const maxW = +startSlider.max;
        const s = +startSlider.value,
          e = +endSlider.value;
        const d1 = new Date(minDate.getTime() + s * 7 * 24 * 60 * 60 * 1000);
        const d2 = new Date(minDate.getTime() + e * 7 * 24 * 60 * 60 * 1000);

        pSel.textContent = `${filterData.periodStart} – ${filterData.periodEnd}`;
        pSel.dataset.value = "range";
      }
    } else {
      const opt = periodSelect.querySelector(
        `.option[data-value="${filterData.period || ""}"]`,
      );
      if (opt) {
        pSel.textContent = opt.textContent;
        pSel.dataset.value = opt.dataset.value;
      }

      startSlider.value = startSlider.min;
      endSlider.value = endSlider.max;

      wrapper.style.setProperty("--start", "0%");
      wrapper.style.setProperty("--end", "100%");
    }

    const allListens = albumsData.map((a) => a.listens || 0);
    const posListens = allListens.filter((x) => x > 0).sort((a, b) => a - b);
    const BINS = 100,
      N = posListens.length;
    const steps = [0];
    for (let i = 1; i <= BINS; i++) {
      const idx = Math.floor(((i - 1) * (N - 1)) / (BINS - 1));
      steps.push(posListens[idx]);
    }

    const listenSelect = document.getElementById("listen-count-filter");
    const selListen = listenSelect.querySelector(".selected");
    const optListen = listenSelect.querySelector(
      `.option[data-value="${filterData.listenCount}"]`,
    );

    if (!filterData.listenCount) {
      selListen.textContent = "Будь-яка кількість";
      selListen.removeAttribute("data-value");

      const lsInput = document.getElementById("listen-count-start");
      const leInput = document.getElementById("listen-count-end");
      const lsWrapper = document.getElementById("listen-count-range");

      lsInput.value = lsInput.min;
      leInput.value = leInput.max;
      lsWrapper.style.setProperty("--start", "0%");
      lsWrapper.style.setProperty("--end", "100%");
    } else if (optListen) {
      selListen.textContent = optListen.textContent;
      selListen.dataset.value = optListen.dataset.value;
    } else {
      const lsVal = filterData.listenStart;
      const leVal = filterData.listenEnd;

      let lsIdx = steps.findIndex((s) => s >= lsVal);
      if (lsIdx === -1) lsIdx = steps.length - 1;
      let leIdx = steps.findIndex((s) => s >= leVal);
      if (leIdx === -1) leIdx = steps.length - 1;

      document.getElementById("listen-count-start").value = lsIdx;
      document.getElementById("listen-count-end").value = leIdx;

      let text;
      if (lsIdx === 0 && leIdx === steps.length - 1) {
        text = "Будь-яка кількість";
      } else if (lsIdx === 0) {
        text = `До ${formatListens(leVal)}`;
      } else if (leIdx === steps.length - 1) {
        text = `Від ${formatListens(lsVal)}`;
      } else {
        text = `${formatListens(lsVal)}–${formatListens(leVal)}`;
      }
      selListen.textContent = text;
      selListen.dataset.value = "range";

      const maxI = steps.length - 1;
      const wrapper = document.getElementById("listen-count-range");
      wrapper.style.setProperty("--start", (lsIdx / maxI) * 100 + "%");
      wrapper.style.setProperty("--end", (leIdx / maxI) * 100 + "%");
    }

    if (filterData.labelFilter !== undefined) {
      const selectLabel = document.getElementById("label-select");
      const selectedLabelDiv = selectLabel.querySelector(".selected");
      const optionsContainer = selectLabel.querySelector(".options-container");
      const opt = optionsContainer.querySelector(
        `.option[data-value="${filterData.labelFilter}"]`,
      );
      if (opt) {
        selectedLabelDiv.textContent = opt.textContent;
        selectedLabelDiv.dataset.value = opt.dataset.value;
        labelFilter = filterData.labelFilter;
      } else {
        selectedLabelDiv.textContent = "Усі лейбли";
        selectedLabelDiv.dataset.value = "";
        labelFilter = "";
      }
    }
  }

  ["mode-any", "mode-all", "mode-only"].forEach((id) => {
    const b = document.getElementById(id);
    if (b) {
      b.classList.remove("active");
      b.setAttribute("aria-pressed", "false");
    }
  });

  const mode =
    filterData.genreMode || (filterData.matchAllGenres ? "all" : "any");
  const only = !!filterData.genreOnlySelected;

  const anyBtn = document.getElementById("mode-any");
  const allBtn = document.getElementById("mode-all");
  const onlyBtn = document.getElementById("mode-only");

  if (mode === "all") {
    allBtn.classList.add("active");
    allBtn.setAttribute("aria-pressed", "true");
  } else {
    anyBtn.classList.add("active");
    anyBtn.setAttribute("aria-pressed", "true");
  }

  if (only) {
    onlyBtn.classList.add("active");
    onlyBtn.setAttribute("aria-pressed", "true");
  }

  if (!isPresetLoading) {
    applyFilters();
  }
}

function saveFiltersToCache() {
  const selectedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:checked"),
  ).map((cb) => cb.value);
  const excludedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:disabled"),
  ).map((cb) => cb.value);
  const selectedLanguages = Array.from(
    document.querySelectorAll(".language-checkbox:checked"),
  ).map((cb) => cb.value);
  const excludedLanguages = Array.from(
    document.querySelectorAll(".language-checkbox:disabled"),
  ).map((cb) => cb.value);
  const selectedReleaseTypes = Array.from(
    document.querySelectorAll(".release-type-checkbox:checked"),
  ).map((cb) => cb.value);

  let sortOrder = document
    .getElementById("sort-order")
    .querySelector(".selected").dataset.value;
  if (!sortOrder) sortOrder = "desc";

  const hideListened = document.getElementById("hide-listened").checked;
  const nuamRecommended = document.getElementById(
    "nuam-recommended-checkbox",
  ).checked;

  const genreMode = document
    .getElementById("mode-all")
    .classList.contains("active")
    ? "all"
    : "any";
  const genreOnlySelected = document
    .getElementById("mode-only")
    .classList.contains("active");

  const rawDuration =
    document.getElementById("duration-filter").querySelector(".selected")
      .dataset.value || "";
  const rawTrackCount =
    document.getElementById("track-count-filter").querySelector(".selected")
      .dataset.value || "";
  const rawListenCount =
    document.getElementById("listen-count-filter").querySelector(".selected")
      .dataset.value || "";
  const labelFilter =
    document.getElementById("label-select").querySelector(".selected").dataset
      .value || "";

  const duration =
    rawDuration === "range"
      ? `${+document.getElementById("duration-start").value}-${+document.getElementById("duration-end").value}`
      : rawDuration;

  const trackCount =
    rawTrackCount === "range"
      ? `${+document.getElementById("track-count-start").value}-${+document.getElementById("track-count-end").value}`
      : rawTrackCount;

  const sel = document.querySelector("#release-period-filter .selected");
  let period = "",
    periodStart = "",
    periodEnd = "";
  if (sel.dataset.value === "range") {
    period = "range";
    const weekOptions = JSON.parse(
      localStorage.getItem("release-week-options") || "[]",
    );
    periodStart =
      weekOptions[+document.getElementById("release-period-start").value] || "";
    periodEnd =
      weekOptions[+document.getElementById("release-period-end").value] || "";
  } else {
    period = sel.dataset.value || "";
  }

  const durationStart = +document.getElementById("duration-start").value;
  const durationEnd = +document.getElementById("duration-end").value;
  const trackStart = +document.getElementById("track-count-start").value;
  const trackEnd = +document.getElementById("track-count-end").value;

  const allListens = albumsData.map((a) => a.listens || 0);
  const posListens = allListens.filter((x) => x > 0).sort((a, b) => a - b);

  if (posListens.length === 0) posListens.push(0);

  const BINS = 100;
  const N = posListens.length;
  const steps = [0];
  for (let i = 1; i <= BINS; i++) {
    const idx = Math.floor(((i - 1) * (N - 1)) / (BINS - 1));
    steps.push(posListens[idx]);
  }

  const lsIdx = +document.getElementById("listen-count-start").value;
  const leIdx = +document.getElementById("listen-count-end").value;
  const listenStart = Math.round(steps[lsIdx]);
  const listenEnd = Math.round(steps[leIdx]);

  const listenCount =
    rawListenCount === "range" ? `${listenStart}-${listenEnd}` : rawListenCount;

  const filterData = {
    selectedGenres,
    excludedGenres,
    selectedLanguages,
    excludedLanguages,
    selectedReleaseTypes,
    sortOrder,
    hideListened,
    nuamRecommended,
    duration,
    durationStart,
    durationEnd,
    trackCount,
    trackStart,
    trackEnd,
    period,
    periodStart,
    periodEnd,
    listenCount,
    listenStart,
    listenEnd,
    labelFilter,
    genreMode,
    genreOnlySelected,
  };

  localStorage.setItem("albumFilters", JSON.stringify(filterData));
}

function attachGlobalEventListeners() {
  document
    .getElementById("genre-checkboxes")
    .addEventListener("change", (e) => {
      if (e.target.classList.contains("genre-checkbox")) {
        clearActivePreset();
        if (!isPresetLoading) {
          preserveScroll(() => smoothApplyFilters());
          saveFiltersToCache();
        }
      }
    });

  document.getElementById("genre-checkboxes").addEventListener("click", (e) => {
    if (e.target.classList.contains("exclude-genre")) {
      clearActivePreset();
      const genre = e.target.getAttribute("data-genre");
      const cb = document.getElementById(`genre-${encodeURIComponent(genre)}`);
      const lb = cb.nextElementSibling;
      toggleExcludeGenre(genre, cb, lb, e.target);
      saveFiltersToCache();
    }
  });

  (function () {
    const anyBtn = document.getElementById("mode-any");
    const allBtn = document.getElementById("mode-all");
    const onlyBtn = document.getElementById("mode-only");

    if (anyBtn) attachTooltip(anyBtn, "Будь-який з вибраних");
    if (allBtn) attachTooltip(allBtn, "Усі вибрані");
    if (onlyBtn) attachTooltip(onlyBtn, "Лише вибрані");
  })();

  const modeAnyBtn = document.getElementById("mode-any");
  const modeAllBtn = document.getElementById("mode-all");
  const modeOnlyBtn = document.getElementById("mode-only");

  function setModeActive(btn, active) {
    btn.classList.toggle("active", active);
    btn.setAttribute("aria-pressed", active ? "true" : "false");
  }
  function ensureBaseMode() {
    const anyOn = modeAnyBtn.classList.contains("active");
    const allOn = modeAllBtn.classList.contains("active");
    if (!anyOn && !allOn) setModeActive(modeAnyBtn, true);
  }
  window.readGenreModes = function () {
    return {
      any: modeAnyBtn.classList.contains("active"),
      all: modeAllBtn.classList.contains("active"),
      only: modeOnlyBtn.classList.contains("active"),
    };
  };

  modeAnyBtn.addEventListener("click", () => {
    setModeActive(modeAnyBtn, !modeAnyBtn.classList.contains("active"));
    setModeActive(modeAllBtn, false);
    ensureBaseMode();
    preserveScroll(() => smoothApplyFilters());
    saveFiltersToCache();
  });
  modeAllBtn.addEventListener("click", () => {
    setModeActive(modeAllBtn, !modeAllBtn.classList.contains("active"));
    setModeActive(modeAnyBtn, false);
    ensureBaseMode();
    preserveScroll(() => smoothApplyFilters());
    saveFiltersToCache();
  });
  modeOnlyBtn.addEventListener("click", () => {
    setModeActive(modeOnlyBtn, !modeOnlyBtn.classList.contains("active"));
    preserveScroll(() => smoothApplyFilters());
    saveFiltersToCache();
  });

  document
    .getElementById("language-checkboxes")
    .addEventListener("change", (e) => {
      if (e.target.classList.contains("language-checkbox")) {
        clearActivePreset();
        if (!isPresetLoading) {
          preserveScroll(() => smoothApplyFilters());
          saveFiltersToCache();
        }
      }
    });

  document
    .getElementById("language-checkboxes")
    .addEventListener("click", (e) => {
      if (e.target.classList.contains("exclude-language")) {
        clearActivePreset();
        const lang = e.target.getAttribute("data-language");
        const cb = document.getElementById(
          `language-${encodeURIComponent(lang)}`,
        );
        const lb = cb.nextElementSibling;
        toggleExcludeLanguage(lang, cb, lb, e.target);
        saveFiltersToCache();
      }
    });

  document
    .getElementById("release-type-checkboxes")
    .addEventListener("change", (e) => {
      if (e.target.classList.contains("release-type-checkbox")) {
        clearActivePreset();
        if (!isPresetLoading) {
          preserveScroll(() => smoothApplyFilters());
          saveFiltersToCache();
        }
      }
    });

  document
    .getElementById("nuam-recommended-checkbox")
    .addEventListener("change", () => {
      clearActivePreset();
      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });

  document
    .getElementById("release-period-filter")
    .addEventListener("change", () => {
      const sel = document.querySelector("#release-period-filter .selected");

      if (sel.dataset.value === "range") return;

      clearActivePreset();
      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });

  document.getElementById("hide-listened").addEventListener("change", (e) => {
    clearActivePreset();
    hideListened = e.target.checked;
    if (!isPresetLoading) {
      preserveScroll(() => smoothApplyFilters());
      saveFiltersToCache();
    }
  });

  document.getElementById("select-all-genres").addEventListener("click", () => {
    document.querySelectorAll(".genre-checkbox").forEach((cb) => {
      if (!cb.disabled) cb.checked = true;
    });
    if (!isPresetLoading) {
      preserveScroll(() => smoothApplyFilters());
      saveFiltersToCache();
    }
  });

  document
    .getElementById("deselect-all-genres")
    .addEventListener("click", () => {
      document.querySelectorAll(".genre-checkbox").forEach((cb) => {
        if (!cb.disabled) cb.checked = false;
      });
      if (!isPresetLoading) {
        preserveScroll(() => smoothApplyFilters());
        saveFiltersToCache();
      }
    });

  document
    .getElementById("blacklist-button")
    .addEventListener("click", function () {
      showBlacklist(true);
    });

  document
    .getElementById("show-listened-albums")
    .addEventListener("click", function (event) {
      event.preventDefault();
      showBlacklist(false);
    });

  window.addEventListener("scroll", throttle(handleScroll, 200));

  document.getElementById("import-data").addEventListener("click", () => {
    const importTextarea = document.getElementById("import-textarea");
    const msg = document.getElementById("import-message");
    const importDataString = importTextarea.value.trim();
    if (!importDataString) {
      msg.textContent = "Вставте дані для завантаження";
      msg.className = "error";
      setTimeout(() => {
        msg.textContent = "";
        msg.className = "";
      }, 4000);
      return;
    }
    try {
      const importData = JSON.parse(importDataString);

      if (importData.blacklistArtists) {
        localStorage.setItem(
          "blacklistedArtists",
          JSON.stringify(importData.blacklistArtists),
        );
      }
      if (importData.blacklistLabels) {
        localStorage.setItem(
          "blacklistedLabels",
          JSON.stringify(importData.blacklistLabels),
        );
      }
      if (importData.listenedAlbums) {
        localStorage.setItem(
          "listenedAlbums",
          JSON.stringify(importData.listenedAlbums),
        );
      }
      if (importData.albumFilters) {
        localStorage.setItem(
          "albumFilters",
          JSON.stringify(importData.albumFilters),
        );
      }
      if (importData.favoriteAlbums) {
        localStorage.setItem(
          "favoriteAlbums",
          JSON.stringify(importData.favoriteAlbums),
        );
      }
      if (Array.isArray(importData.presets)) {
        savePresetsToStorage(importData.presets);
        if (typeof loadPresetsFromStorage === "function") {
          loadPresetsFromStorage();
        }
      }

      msg.textContent = "Дані завантажені. Перезавантажте сторінку.";
      msg.className = "success";
      setTimeout(() => {
        msg.textContent = "";
        msg.className = "";
      }, 5000);
    } catch (error) {
      msg.textContent = "Помилка при завантаженні. Формат JSON некоректний.";
      msg.className = "error";
      setTimeout(() => {
        msg.textContent = "";
        msg.className = "";
      }, 4000);
    }
  });

  window.addEventListener("scroll", () => {
    const scrollTopButton = document.getElementById("scrollTopButton");
    if (window.scrollY > 200) {
      scrollTopButton.style.display = "flex";
      scrollTopButton.style.opacity = "1";
    } else {
      scrollTopButton.style.opacity = "0";
      setTimeout(() => {
        if (window.scrollY <= 200) {
          scrollTopButton.style.display = "none";
        }
      }, 300);
    }
  });

  document.getElementById("favorites-button").addEventListener("click", () => {
    const modal = document.getElementById("blacklist-modal");
    modal.style.display = "block";
    document.getElementById("favorites-tab").click();
  });

  document
    .querySelector("#blacklist-modal .close")
    .addEventListener("click", () => {
      document.getElementById("blacklist-modal").style.display = "none";
    });

  (function () {
  const SAFE_INPUTS = '.option-search, #preset-name-input, #preset-desc-input, #edit-name-input, #edit-desc-input';
  let suppressNextClick = false;

  document.addEventListener('mousedown', function (e) {
    const t = e.target;
    suppressNextClick = !!(t && t.closest && t.closest(SAFE_INPUTS));
  }, true);

  document.addEventListener('click', function (e) {
    if (suppressNextClick) {
      suppressNextClick = false;
      e.stopPropagation();
      if (typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
    }
  }, true);
})();
  
  window.addEventListener("click", (event) => {
    const modal = document.getElementById("blacklist-modal");
    if (event.target === modal) {
      modal.style.display = "none";
    }
  });
 document.getElementById("scrollTopButton").addEventListener("click", () => {
    window.scrollTo({
      top: 0,
      behavior: "smooth",
    });
  });

  const logoWrapper = document.querySelector(".logo-wrapper");
  const filtersButton = document.getElementById("filters-button");
  const searchButton = document.getElementById("search-button");
  const searchContainer = document.getElementById("search-container");
  const searchInput = document.getElementById("search-input");
  const searchClose = document.getElementById("search-close");
  
(function initLogosNoDup(){
  const root = document.documentElement;

  const GROUPS = [
    { sel: '#app-logo',                                 cssVar: '--mask-logo-main' },
    { sel: '.logo-dropdown .logo-row:nth-child(1) img', cssVar: '--mask-logo-1'   },
    { sel: '.logo-dropdown .logo-row:nth-child(2) img', cssVar: '--mask-logo-2'   },
    { sel: '.logo-dropdown .logo-row:nth-child(3) img', cssVar: '--mask-logo-3'   },
  ];

  const urlToTargets = new Map();
  GROUPS.forEach(({ sel, cssVar }) => {
    document.querySelectorAll(sel).forEach((img) => {
      const url = img.getAttribute('data-src') || img.getAttribute('src');
      if (!url) return;
      if (!urlToTargets.has(url)) urlToTargets.set(url, { cssVars: new Set(), imgs: new Set() });
      urlToTargets.get(url).imgs.add(img);
      urlToTargets.get(url).cssVars.add(cssVar);
    });
  });

  function preload(url, cb){
    const im = new Image();
    im.decoding = 'async';
    im.onload = () => cb(url);
    im.onerror = () => cb(url);
    im.src = url;
  }

  function applyFor(url){
    const t = urlToTargets.get(url);
    if (!t) return;

    t.imgs.forEach((img) => {
      if (!img.getAttribute('src')) img.setAttribute('src', url);
      else                          img.src = url;
    });

    t.cssVars.forEach((v) => root.style.setProperty(v, `url("${url}")`));
  }

  function start(){
    if (urlToTargets.size === 0){
      document.querySelectorAll('.logo-wrapper').forEach(w => w.classList.add('logos-ready'));
      return;
    }
    let pending = urlToTargets.size;
    urlToTargets.forEach((_, url) => {
      preload(url, (readyUrl) => {
        applyFor(readyUrl);
        pending -= 1;
        if (pending === 0){
          document.querySelectorAll('.logo-wrapper').forEach(w => w.classList.add('logos-ready'));
        }
      });
    });
  }

  if (document.readyState === 'complete') start();
  else window.addEventListener('load', start, { once: true });
})();

{
  const TIP = 'Збережіть встановлені вами фільтри, щоб пізніше до них повернутися';
  filtersButton.setAttribute('aria-label', TIP);
  filtersButton.removeAttribute('data-tooltip');
  filtersButton.removeAttribute('title');
  if (typeof attachTooltip === 'function') {
    attachTooltip(filtersButton, TIP, '230px');
  }
}
  
  window.albumSearchMode =
    localStorage.getItem("albumSearchMode") || "artist-album";

  (function initAlbumSearchModeToggle() {
    const wrap = document.getElementById("search-mode-toggle");
    if (!wrap) return;

    const buttons = Array.from(wrap.querySelectorAll("button"));
    const setActive = (mode) => {
      if (mode === "artist-album") {
        buttons.forEach((b) => b.classList.add("active"));
      } else {
        buttons.forEach((b) =>
          b.classList.toggle("active", b.dataset.mode === mode),
        );
      }
    };

    setActive(window.albumSearchMode);

    wrap.addEventListener("click", (e) => {
      const btn = e.target.closest("button[data-mode]");
      if (!btn) return;
      const mode = btn.dataset.mode;
      window.albumSearchMode = mode;
      localStorage.setItem("albumSearchMode", mode);
      setActive(mode);

      const inp = document.getElementById("search-input");
      const qLocal = (inp && typeof inp.value === "string") ? inp.value.trim() : "";
      const qState = (typeof searchQuery === "string") ? searchQuery.trim() : "";
      const hasQuery = (qLocal !== "") || (qState !== "");

      if (hasQuery && typeof smoothApplyFilters === "function") smoothApplyFilters();
    });
  })();

  (function replaceSearchModeButtonTextWithIcons() {
    const wrap = document.getElementById("search-mode-toggle");
    if (!wrap) return;

    const MAP = {
      artist: {
        html: '<i class="fa-solid fa-user"></i>',
        tip: "Шукати тільки за артистами",
      },
      "artist-album": {
        html: '<i class="fa-solid fa-arrows-left-right"></i>',
        tip: "Шукати за артистами або альбомами",
      },
      album: {
        html: '<i class="fa-solid fa-compact-disc"></i>',
        tip: "Шукати тільки за альбомами",
      },
    };

    Object.entries(MAP).forEach(([mode, cfg]) => {
      const btn = wrap.querySelector(`button[data-mode="${mode}"]`);
      if (!btn) return;

      const textBlock =
        btn.querySelector(".label, .btn-text, .text, span, div") ||
        btn.firstElementChild ||
        null;

      if (textBlock) {
        textBlock.innerHTML = cfg.html;
      } else {
        btn.innerHTML = cfg.html;
      }

      btn.setAttribute("data-tooltip", cfg.tip);
      btn.setAttribute("aria-label", cfg.tip);
      btn.title = "";
    });
  })();

  (function initSearchModeTooltips() {
    const wrap = document.getElementById("search-mode-toggle");
    if (!wrap || typeof attachTooltip !== "function") return;

    const btnArtist = wrap.querySelector('button[data-mode="artist"]');
    const btnBoth = wrap.querySelector('button[data-mode="artist-album"]');
    const btnAlbum = wrap.querySelector('button[data-mode="album"]');

    attachTooltip(btnArtist, "Шукати тільки за артистами");
    attachTooltip(btnBoth, "Шукати за артистами або альбомами", "300px");
    attachTooltip(btnAlbum, "Шукати тільки за альбомами");
  })();

  const filtersContainer = document.getElementById("filters-container");
  const filtersClose = document.getElementById("filters-close");

  searchButton.addEventListener("click", () => {
    logoWrapper.style.display = "none";
    searchButton.style.display = "none";
    filtersButton.style.display = "none";
    searchContainer.style.display = "flex";
    searchInput.focus();
  });

  searchClose.addEventListener("click", () => {
  const hadQuery =
    (searchInput.value && searchInput.value.trim() !== "") ||
    (typeof searchQuery === "string" && searchQuery.trim() !== "");

  logoWrapper.style.display = "inline-block";
  searchButton.style.display = "inline-block";
  filtersButton.style.display = "inline-block";
  searchContainer.style.display = "none";

  searchInput.value = "";
  searchQuery = "";

  if (hadQuery && typeof smoothApplyFilters === "function") {
    smoothApplyFilters();
  }
});

  filtersButton.addEventListener("click", () => {
    logoWrapper.style.display = "none";
    searchButton.style.display = "none";
    filtersButton.style.display = "none";
    filtersContainer.style.display = "flex";
  });

  filtersClose.addEventListener("click", () => {
    logoWrapper.style.display = "inline-block";
    searchButton.style.display = "inline-block";
    filtersButton.style.display = "inline-block";
    filtersContainer.style.display = "none";
  });

  document.getElementById("search-input").addEventListener("input", (e) => {
    searchQuery = e.target.value.trim().toLowerCase();
    smoothApplyFilters();
  });
}

function toggleExcludeGenre(genre, checkbox, label, genreCross) {
  if (checkbox.disabled) {
    checkbox.disabled = false;
    genreCross.textContent = "✖";
    genreCross.classList.remove("repeat-symbol");
    label.style.textDecoration = "none";
    label.style.color = "#f3f3f3";
  } else {
    checkbox.checked = false;
    checkbox.disabled = true;
    genreCross.textContent = "↻";
    genreCross.classList.add("repeat-symbol");
    label.style.textDecoration = "line-through";
    label.style.color = "gray";
  }
  preserveScroll(() => smoothApplyFilters());
}

function toggleExcludeLanguage(language, checkbox, label, langCross) {
  if (checkbox.disabled) {
    checkbox.disabled = false;
    langCross.textContent = "✖";
    langCross.classList.remove("language-repeat-symbol", "repeat-symbol");
    label.style.textDecoration = "none";
    label.style.color = "#f3f3f3";
  } else {
    checkbox.checked = false;
    checkbox.disabled = true;
    langCross.textContent = "↻";
    langCross.classList.add("language-repeat-symbol");
    label.style.textDecoration = "line-through";
    label.style.color = "gray";
  }
  preserveScroll(() => smoothApplyFilters());
}

function getFilteredAlbums() {
  const selectedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:checked"),
  ).map((cb) => cb.value);
  const excludedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:disabled"),
  ).map((cb) => cb.value);
  const selectedLangs = Array.from(
    document.querySelectorAll(".language-checkbox:checked"),
  ).map((cb) => cb.value);
  const excludedLangs = Array.from(
    document.querySelectorAll(".language-checkbox:disabled"),
  ).map((cb) => cb.value);
  const selectedReleaseTypes = Array.from(
    document.querySelectorAll(".release-type-checkbox:checked"),
  ).map((cb) => cb.value);

  return albumsData.filter((al) => {
    if (hideListened && al.listened) return false;

    const {
      any: modeAny,
      all: modeAll,
      only: modeOnly,
    } = window.readGenreModes
      ? window.readGenreModes()
      : { any: true, all: false, only: false };
    const hasAny =
      selectedGenres.length === 0 ||
      al.genres.some((g) => selectedGenres.includes(g));
    const hasAll =
      selectedGenres.length === 0 ||
      selectedGenres.every((g) => al.genres.includes(g));
    const onlyOk =
      !modeOnly ||
      selectedGenres.length === 0 ||
      al.genres.every((g) => selectedGenres.includes(g));
    const base = selectedGenres.length === 0 ? true : modeAll ? hasAll : hasAny;
    const matchGenres = base && onlyOk;

    const notExcludedGenres =
      excludedGenres.length === 0 ||
      !al.genres.some((g) => excludedGenres.includes(g));

    const matchLangs =
      selectedLangs.length === 0 ||
      (al.languages.length === 0
        ? selectedLangs.includes("без голосу")
        : al.languages.some((l) => selectedLangs.includes(l)));
    const notExcludedLangs =
      excludedLangs.length === 0 ||
      (al.languages.length === 0
        ? !excludedLangs.includes("без голосу")
        : !al.languages.some((l) => excludedLangs.includes(l)));

    const matchRelease =
      selectedReleaseTypes.length === 0 ||
      selectedReleaseTypes.includes(al.type);
    const notBlacklistedArtist =
      window.tempIgnoreBlacklist ||
      !al.artistIDs.some((id) => blacklistedArtists.has(id));
    const notBlacklistedLabel =
      window.tempIgnoreBlacklist || !blacklistedLabels.has(al.label);

    return (
      matchGenres &&
      notExcludedGenres &&
      matchLangs &&
      notExcludedLangs &&
      matchRelease &&
      notBlacklistedArtist &&
      notBlacklistedLabel
    );
  });
}

function applyFilters(renderImmediately = false) {
  filteredAlbums = [...albumsData];

  const selectedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:checked"),
  ).map((cb) => cb.value);
  const {
    any: modeAny,
    all: modeAll,
    only: modeOnly,
  } = window.readGenreModes
    ? window.readGenreModes()
    : { any: true, all: false, only: false };

  if (selectedGenres.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) => {
      const hasAny = al.genres.some((g) => selectedGenres.includes(g));
      const hasAll = selectedGenres.every((g) => al.genres.includes(g));
      const onlyOk =
        !modeOnly || al.genres.every((g) => selectedGenres.includes(g));
      const base = modeAll ? hasAll : hasAny;
      return base && onlyOk;
    });
  }

  const excludedGenres = Array.from(
    document.querySelectorAll(".genre-checkbox:disabled"),
  ).map((cb) => cb.value);
  if (excludedGenres.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) => {
      return !al.genres.some((g) => excludedGenres.includes(g));
    });
  }

  const selectedLangs = Array.from(
    document.querySelectorAll(".language-checkbox:checked"),
  ).map((cb) => cb.value);
  if (selectedLangs.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) => {
      if (al.languages.length === 0) {
        return selectedLangs.includes("без голосу");
      } else {
        return al.languages.some((l) => selectedLangs.includes(l));
      }
    });
  }

  const excludedLangs = Array.from(
    document.querySelectorAll(".language-checkbox:disabled"),
  ).map((cb) => cb.value);
  if (excludedLangs.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) => {
      if (al.languages.length === 0) {
        return !excludedLangs.includes("без голосу");
      } else {
        return !al.languages.some((l) => excludedLangs.includes(l));
      }
    });
  }

  const selectedReleaseTypes = Array.from(
    document.querySelectorAll(".release-type-checkbox:checked"),
  ).map((cb) => cb.value);
  if (selectedReleaseTypes.length > 0) {
    filteredAlbums = filteredAlbums.filter((al) =>
      selectedReleaseTypes.includes(al.type),
    );
  }

  const onlyRecommended = document.getElementById(
    "nuam-recommended-checkbox",
  ).checked;
  if (onlyRecommended) {
    filteredAlbums = filteredAlbums.filter((al) => al.good);
  }

  if (!window.tempIgnoreBlacklist) {
    filteredAlbums = filteredAlbums.filter(
      (al) => !al.artistIDs.some((id) => blacklistedArtists.has(id)),
    );
    filteredAlbums = filteredAlbums.filter(
      (al) => !blacklistedLabels.has(al.label),
    );
  }

  if (hideListened) {
    filteredAlbums = filteredAlbums.filter((al) => !al.listened);
  }

  if (sortOrder === "listens-desc") {
    filteredAlbums.sort((a, b) => b.listens - a.listens);
  } else if (sortOrder === "listens-asc") {
    filteredAlbums.sort((a, b) => a.listens - b.listens);
  } else if (sortOrder === "popularity-growth") {
    filteredAlbums = filteredAlbums.filter(
      (al) => (al.listens || 0) > 0 && (al.popularity || 0) > 0,
    );
    filteredAlbums.sort((a, b) => {
      const pa = a.popularity ?? -Infinity;
      const pb = b.popularity ?? -Infinity;
      if (pb !== pa) return pb - pa;
      const da = new Date(a.date),
        db = new Date(b.date);
      if (db - da !== 0) return db - da;
      if (b.listens !== a.listens) return b.listens - a.listens;
      return String(a.nameAlbum).localeCompare(String(b.nameAlbum));
    });
  } else if (sortOrder === "random") {
    for (let i = filteredAlbums.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [filteredAlbums[i], filteredAlbums[j]] = [
        filteredAlbums[j],
        filteredAlbums[i],
      ];
    }
  } else if (sortOrder === "duration-desc") {
    filteredAlbums.sort((a, b) => {
      const [hA, mA] = (a.duration || "00:00:00").split(":").map(Number);
      const [hB, mB] = (b.duration || "00:00:00").split(":").map(Number);
      return hB * 60 + mB - (hA * 60 + mA);
    });
  } else if (sortOrder === "duration-asc") {
    filteredAlbums.sort((a, b) => {
      const [hA, mA] = (a.duration || "00:00:00").split(":").map(Number);
      const [hB, mB] = (b.duration || "00:00:00").split(":").map(Number);
      return hA * 60 + mA - (hB * 60 + mB);
    });
  } else if (sortOrder === "tracks-desc") {
    filteredAlbums.sort((a, b) => b.tracksIDs.length - a.tracksIDs.length);
  } else if (sortOrder === "tracks-asc") {
    filteredAlbums.sort((a, b) => a.tracksIDs.length - b.tracksIDs.length);
  } else {
    filteredAlbums.sort((a, b) => {
      const da = new Date(a.date),
        db = new Date(b.date);
      return sortOrder === "asc" ? da - db : db - da;
    });
  }

  const selectedDuration =
    document.getElementById("duration-filter").querySelector(".selected")
      .dataset.value || "";

  if (selectedDuration === "range") {
    const s = +document.getElementById("duration-start").value;
    const e = +document.getElementById("duration-end").value;
    filteredAlbums = filteredAlbums.filter((al) => {
      const [h, m] = (al.duration || "00:00:00")
        .split(":")
        .map((x) => parseInt(x, 10) || 0);
      const total = h * 60 + m;
      return total >= Math.min(s, e) && total <= Math.max(s, e);
    });
  } else if (
    /^\d+-\d+$/.test(selectedDuration) ||
    /^\d+-$/.test(selectedDuration) ||
    /^-\d+$/.test(selectedDuration)
  ) {
    const [minStr, maxStr] = selectedDuration.split("-");
    const min = minStr ? parseInt(minStr, 10) : 0;
    const max = maxStr ? parseInt(maxStr, 10) : Infinity;
    filteredAlbums = filteredAlbums.filter((al) => {
      const [h, m] = (al.duration || "00:00:00")
        .split(":")
        .map((x) => parseInt(x, 10) || 0);
      const total = h * 60 + m;
      return total >= min && total <= max;
    });
  } else if (selectedDuration) {
    filteredAlbums = filteredAlbums.filter((al) => {
      const [h, m] = (al.duration || "00:00:00")
        .split(":")
        .map((x) => parseInt(x, 10) || 0);
      const total = h * 60 + m;
      if (selectedDuration === "short") return total < 30;
      if (selectedDuration === "medium") return total >= 30 && total < 60;
      if (selectedDuration === "long") return total >= 60 && total < 120;
      if (selectedDuration === "very-long") return total >= 120;
      return true;
    });
  }

  const selectedTrackCount =
    document.getElementById("track-count-filter").querySelector(".selected")
      .dataset.value || "";

  if (selectedTrackCount === "range") {
    const s = +document.getElementById("track-count-start").value;
    const e = +document.getElementById("track-count-end").value;
    filteredAlbums = filteredAlbums.filter((al) => {
      const t = al.tracksIDs.length;
      return t >= Math.min(s, e) && t <= Math.max(s, e);
    });
  } else if (
    /^\d+-\d+$/.test(selectedTrackCount) ||
    /^\d+-$/.test(selectedTrackCount) ||
    /^-\d+$/.test(selectedTrackCount)
  ) {
    const [minStr, maxStr] = selectedTrackCount.split("-");
    const min = minStr ? parseInt(minStr, 10) : 0;
    const max = maxStr ? parseInt(maxStr, 10) : Infinity;
    filteredAlbums = filteredAlbums.filter((al) => {
      const t = al.tracksIDs.length;
      return t >= min && t <= max;
    });
  } else if (selectedTrackCount) {
    const minTracks = parseInt(selectedTrackCount, 10);
    filteredAlbums = filteredAlbums.filter(
      (al) => al.tracksIDs.length >= minTracks,
    );
  }

  const selEl = document.querySelector("#release-period-filter .selected");
  if (selEl.dataset.value !== "range") {
    const selectedPeriod = selEl.dataset.value;
    if (selectedPeriod) {
      const days = parseInt(selectedPeriod, 10);
      const now = new Date();
      const threshold = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
      filteredAlbums = filteredAlbums.filter(
        (al) => new Date(al.date) >= threshold,
      );
    }
  }

  {
    const ws = +document.getElementById("release-period-start").value;
    const we = +document.getElementById("release-period-end").value;
    const dates = albumsData.map((a) => new Date(a.date));
    const minDate = new Date(Math.min(...dates));
    const d1 = new Date(minDate.getTime() + ws * 7 * 24 * 60 * 60 * 1000);
    const d2 = new Date(minDate.getTime() + we * 7 * 24 * 60 * 60 * 1000);
    const startDate = d1 < d2 ? d1 : d2;
    const endDate = d1 < d2 ? d2 : d1;
    filteredAlbums = filteredAlbums.filter((al) => {
      const d = new Date(al.date);
      return d >= startDate && d <= endDate;
    });
  }

  const selListen =
    document.getElementById("listen-count-filter").querySelector(".selected")
      .dataset.value || "";

  if (selListen === "range") {
    const i1 = +document.getElementById("listen-count-start").value;
    const i2 = +document.getElementById("listen-count-end").value;

    const allListens = albumsData.map((a) => a.listens || 0);
    const posListens = allListens.filter((x) => x > 0).sort((a, b) => a - b);
    if (posListens.length === 0) posListens.push(0);

    const BINS = 100;
    const N = posListens.length;
    const steps = [0];
    for (let k = 1; k <= BINS; k++) {
      const idx = Math.floor(((k - 1) * (N - 1)) / (BINS - 1));
      steps.push(posListens[idx]);
    }

    const startIdx = Math.min(i1, i2);
    const endIdx = Math.max(i1, i2);
    const sVal = Math.round(steps[startIdx]);
    const eVal = Math.round(steps[endIdx]);

    filteredAlbums = filteredAlbums.filter(
      (al) => al.listens >= sVal && al.listens <= eVal,
    );
  } else if (selListen) {
    const [minStr, maxStr] = selListen.split("-");
    const min = minStr ? parseInt(minStr, 10) : 0;
    const max = maxStr ? parseInt(maxStr, 10) : Infinity;
    filteredAlbums = filteredAlbums.filter(
      (al) => al.listens >= min && al.listens <= max,
    );
  }

  const preSearch = filteredAlbums.slice();

  if (searchQuery) {
    const mode = window.albumSearchMode || "artist-album";
    const searchMatches = albumsData.filter((al) => {
      const albumHit = String(al.nameAlbum || "")
        .toLowerCase()
        .includes(searchQuery);
      const artistHit =
        Array.isArray(al.artistNames) &&
        al.artistNames.some((n) =>
          String(n || "")
            .toLowerCase()
            .includes(searchQuery),
        );
      if (mode === "artist") return artistHit;
      if (mode === "album") return albumHit;
      return albumHit || artistHit;
    });

    const primary = filteredAlbums.filter((al) => searchMatches.includes(al));
    const hiddenByFilters = searchMatches.filter((al) => !primary.includes(al));
    if (hiddenByFilters.length) {
      primary.push({ __separatorType: "search" });
      primary.push(...hiddenByFilters);
    }

    filteredAlbums = primary;
  }

  if (labelFilter) {
  filteredAlbums = filteredAlbums.filter((al) => canonLabel(al.label) === labelFilter);
}

  if (labelFilter) {
  const totalByLabel = albumsData.filter((a) => canonLabel(a.label) === labelFilter);
  const hiddenByLabel = totalByLabel.filter(
    (a) => !filteredAlbums.includes(a),
  );

    if (sortOrder === "listens-desc") {
      hiddenByLabel.sort((a, b) => b.listens - a.listens);
    } else if (sortOrder === "popularity-growth") {
      for (let i = hiddenByLabel.length - 1; i >= 0; i--) {
        const al = hiddenByLabel[i];
        if (!((al.listens || 0) > 0 && (al.popularity || 0) > 0)) {
          hiddenByLabel.splice(i, 1);
        }
      }
      hiddenByLabel.sort((a, b) => {
        const pa = a.popularity ?? -Infinity;
        const pb = b.popularity ?? -Infinity;
        if (pb !== pa) return pb - pa;
        const da = new Date(a.date),
          db = new Date(b.date);
        if (db - da !== 0) return db - da;
        if (b.listens !== a.listens) return b.listens - a.listens;
        return String(a.nameAlbum).localeCompare(String(b.nameAlbum));
      });
    } else {
      hiddenByLabel.sort((a, b) => {
        const da = new Date(a.date),
          db = new Date(b.date);
        return sortOrder === "asc" ? da - db : db - da;
      });
    }

    if (hiddenByLabel.length) {
      filteredAlbums.push({ __separatorType: "label" });

      filteredAlbums.push(...hiddenByLabel);
    }
  }

  const forceAll = Boolean(labelFilter) || renderImmediately;
  currentIndex = 0;

  renderAlbums(filteredAlbums, true, forceAll);

updateAlbumCount();

const lazyMsg = document.getElementById("lazy-loading");
isEmptyResult = filteredAlbums.length === 0;
lazyMsg.textContent = isEmptyResult
  ? "Немає альбомів за вказаними вами параметрами"
  : "";
  
}

function updateRenderedAlbums(filteredAlbums) {
  const container = document.getElementById("albums-container");
  const filteredIDs = new Set(filteredAlbums.map((a) => a.albumID));

  document.querySelectorAll(".album").forEach((albumDiv) => {
    const id = albumDiv.dataset.albumId;
    if (!filteredIDs.has(id)) {
      albumDiv.style.transition = "opacity 0.3s";
      albumDiv.style.opacity = "0";
      setTimeout(() => albumDiv.remove(), 300);
    }
  });

  currentIndex = [...container.querySelectorAll(".album")].length;
}

function handleScroll() {
  if (isFiltering) return;

  const atBottom = window.innerHeight + window.scrollY >= document.body.offsetHeight - 100;
  const lazyEl = document.getElementById("lazy-loading");

  if (atBottom && currentIndex < filteredAlbums.length) {
    renderAlbums(filteredAlbums);
  } else if (atBottom && currentIndex >= filteredAlbums.length && !isEmptyResult) {
    if (lazyEl) lazyEl.textContent = "Більше немає альбомів для завантаження";
  }
}



function forceLazyLoadCheck() {
  const container = document.getElementById("albums-container");

  const containerBottom = container.getBoundingClientRect().bottom;
  const viewportHeight = window.innerHeight;

  if (
    containerBottom <= viewportHeight + 100 &&
    currentIndex < filteredAlbums.length
  ) {
    renderAlbums(filteredAlbums);
  } else if (currentIndex >= filteredAlbums.length) {
  const el = document.getElementById("lazy-loading");
  el.textContent = isEmptyResult
    ? "Немає альбомів за вказаними вами параметрами"
    : "";
}


}

function throttle(func, limit) {
  let lastFunc;
  let lastRan;
  return function () {
    const context = this,
      args = arguments;
    if (!lastRan) {
      func.apply(context, args);
      lastRan = Date.now();
    } else {
      clearTimeout(lastFunc);
      lastFunc = setTimeout(
        function () {
          if (Date.now() - lastRan >= limit) {
            func.apply(context, args);
            lastRan = Date.now();
          }
        },
        limit - (Date.now() - lastRan),
      );
    }
  };
}

function renderAlbums(data, reset = false, forceAll = false) {
  const container = document.getElementById("albums-container");
  if (reset) container.innerHTML = "";

  const endIndex = forceAll
    ? data.length
    : Math.min(currentIndex + batchSize, data.length);

  for (let i = currentIndex; i < endIndex; i++) {
    const album = data[i];

    if (album.__separatorType) {
      const sepText =
        album.__separatorType === "label"
          ? "Альбоми лейбла, що не відповідають обраним вами фільтрам"
          : "Знайдені альбоми, що не відповідають обраним вами фільтрам";
      const sep = document.createElement("div");
      sep.classList.add("separator");

      const line1 = document.createElement("div");
      line1.classList.add("line");

      const text = document.createElement("div");
      text.classList.add("sep-text");
      text.textContent = sepText;

      const line2 = document.createElement("div");
      line2.classList.add("line");

      sep.append(line1, text, line2);
      container.appendChild(sep);
      continue;
    }

    const albumDiv = document.createElement("div");
    albumDiv.classList.add("album");
    albumDiv.dataset.albumId = album.albumID;
    if (album.listened) albumDiv.classList.add("album-listened");

    const coverUrl = `https://i.scdn.co/image/ab67616d0000b273${album.cover}`;
    const albumLink = `https://open.spotify.com/album/${album.albumID}`;
    const langText =
      album.languages.length === 0
        ? "Без голосу"
        : album.languages.map((l) => languageLabels[l] || l).join(", ");
    const joinedGenres = album.genres.length
      ? album.genres.map((g) => friendlyGenreLabel(g)).join(", ")
      : "Немає даних";

    albumDiv.innerHTML = `
      <div class="album-overlay"></div>
      <div class="album-cover-wrapper">
        <img src="${coverUrl}" alt="${album.nameAlbum}" class="album-cover">
      </div>

      <div class="album-details">
        <div class="alb-head">
          ${releaseIcon(album.type)}
          <div class="alb-head-txt">
            <h3 style="display: flex; align-items: center; gap: 6px;">
  <a href="${albumLink}" target="_blank" style="display: flex; align-items: center; gap: 6px;">
    ${album.nameAlbum}
    <span class="spotify-icon">
      <span class="icon-default">
        <svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" fill="none">
          <circle cx="24" cy="24" r="21.5" stroke="#f3f3f3" stroke-width="2"/>
          <path d="M33.86 33.51c-.39.63-1.21.83-1.84.44-5.05-3.08-11.4-3.78-18.89-2.07-.72.16-1.44-.29-1.6-1.01-.17-.72.29-1.44 1.01-1.6 8.19-1.87 15.21-1.07 20.88 2.4.63.39.83 1.21.44 1.84Zm2.63-5.85c-.49.79-1.52 1.04-2.31.55-5.78-3.55-14.59-4.58-21.42-2.51-.89.27-1.82-.23-2.09-1.12-.27-.89.23-1.82 1.12-2.09 7.81-2.37 17.52-1.22 24.15 2.86.79.49 1.04 1.52.55 2.3Zm.23-6.1c-6.93-4.12-18.36-4.49-24.98-2.49-1.06.32-2.19-.28-2.51-1.34-.32-1.06.28-2.19 1.34-2.51 7.59-2.31 20.22-1.86 28.2 2.88.96.57 1.27 1.8.7 2.76-.56.96-1.8 1.27-2.75.7Z" fill="#f3f3f3"/>
        </svg>
      </span>
      <span class="icon-hover">
        <svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
        <path fill="#00DA5A" fill-opacity="0.7" d="M238.16,481.36 C230.48,476.8 217.64,476.32 210.32,478.6 C209.12,478.96 207.92,478.24 207.56,477.16 C207.2,475.96 207.92,474.76 209,474.4 C217.52,471.88 231.56,472.36 240.44,477.64 C241.52,478.24 241.88,479.68 241.28,480.76 C240.68,481.6 239.24,481.96 238.16,481.36 M237.92,488.08 C237.32,488.92 236.24,489.28 235.4,488.68 C228.92,484.72 219.08,483.52 211.52,485.92 C210.56,486.16 209.48,485.68 209.24,484.72 C209,483.76 209.48,482.68 210.44,482.44 C219.2,479.8 230,481.12 237.44,485.68 C238.16,486.04 238.52,487.24 237.92,488.08 M235.04,494.68 C234.56,495.4 233.72,495.64 233,495.16 C227.36,491.68 220.28,490.96 211.88,492.88 C211.04,493.12 210.32,492.52 210.08,491.8 C209.84,490.96 210.44,490.24 211.16,490 C220.28,487.96 228.2,488.8 234.44,492.64 C235.28,493 235.4,493.96 235.04,494.68 M224,460 C210.8,460 200,470.8 200,484 C200,497.2 210.8,508 224,508 C237.2,508 248,497.2 248,484 C248,470.8 237.32,460 224,460" transform="translate(-200 -460)"/>
      </svg>
      </span>
    </span>
  </a>

  <span class="album-links">
    <a href="https://music.youtube.com/search?q=${encodeURIComponent(album.artistNames.join(", ") + " - " + album.nameAlbum)}" target="_blank" class="yt-icon">
      <span class="icon-default">
        <svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" fill="none">
  <circle cx="24" cy="24" r="14" stroke="#f3f3f3" stroke-width="2"/>
  <circle cx="24" cy="24" r="21.5" stroke="#f3f3f3" stroke-width="2"/>
  <path d="M31,24L19,31V17Z" fill="#f3f3f3"/>
</svg>
      </span>
      <span class="icon-hover">
        <svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <path fill="#FF0000" fill-opacity="0.7" d="M50,2.5C23.766,2.5,2.5,23.823,2.5,50.126c2.502,63.175,92.507,63.157,95-0.001C97.5,23.823,76.233,2.5,50,2.5z
            M50,77.399c-15.036,0-27.27-12.233-27.27-27.27c0.74-18.662,14.654-27.134,27.269-27.134c0.001,0,0.001,0,0.002,0
            c12.616,0.001,26.531,8.473,27.267,27.073C77.27,65.167,65.036,77.399,50,77.399z"/>
          <path fill="#FF0000" d="M50.002,26.103c-15.946-0.001-23.704,12.486-24.165,24.088C25.838,63.453,36.677,74.292,50,74.292
            S74.162,63.453,74.162,50.13C73.705,38.591,65.948,26.105,50.002,26.103z"/>
          <path fill="#FFFFFF" d="M41.055,52.528c-0.001,2.575,0.001,7.867,0,10.46c0,0,21.802-13.417,21.802-13.417L41.055,37.272V52.528z"/>
        </svg>
      </span>
    </a>

    <a href="https://music.apple.com/ua/search?term=${encodeURIComponent(album.artistNames.join(", ") + " - " + album.nameAlbum)}" target="_blank" class="apple-icon">
      <span class="icon-default">
        <svg viewBox="0 0 192 192" xmlns="http://www.w3.org/2000/svg" fill="none">
  <path stroke="#f3f3f3" stroke-width="12" d="m68 60 80-14M68 60v91m0-91V40.722a8 8 0 0 1 6.621-7.88l64-11.2c4.895-.857 9.379 2.91 9.379 7.88V46m0 0v89m-98.477.234-8.48 1.483A15.761 15.761 0 0 0 28 152.242c0 9.791 8.833 17.212 18.477 15.524l8.48-1.483A15.761 15.761 0 0 0 68 150.758c0-9.791-8.833-17.212-18.477-15.524Zm80-16-8.479 1.483A15.761 15.761 0 0 0 108 136.242c0 9.791 8.833 17.212 18.477 15.524l8.479-1.483A15.761 15.761 0 0 0 148 134.758c0-9.791-8.833-17.212-18.477-15.524Z"/>
</svg>
      </span>
      <span class="icon-hover">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="Apple Music" role="img" viewBox="0 0 512 512" fill="#000000" fill-opacity="0.7">
          <rect width="512" height="512" rx="15%" fill="url(#g)"></rect>
          <linearGradient id="g" x1=".5" y1=".99" x2=".5" y2=".02">
            <stop offset="0" stop-color="#FA233B"></stop>
            <stop offset="1" stop-color="#FB5C74"></stop>
          </linearGradient>
          <path fill="#ffffff" d="M199 359V199q0-9 10-11l138-28q11-2 12 10v122q0 15-45 20c-57 9-48 105 30 79 30-11 35-40 35-69V88s0-20-17-15l-170 35s-13 2-13 18v203q0 15-45 20c-57 9-48 105 30 79 30-11 35-40 35-69"/>
        </svg>
      </span>
    </a>
  </span>
</h3>

            <p class="alb-artist">${renderArtists(i, album)}</p>
            <p class="alb-genres">${joinedGenres}</p>
          </div>
        </div>

        <hr class="alb-sep">

        <div class="alb-meta">
          <p><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="#f3f3f3" d="M9 2a8 8 0 0 1 7.934 6.965l2.25 3.539c.148.233.118.58-.225.728L17 14.07V17a2 2 0 0 1-2 2h-1.999L13 22H4v-3.694c0-1.18-.436-2.297-1.244-3.305A8 8 0 0 1 9 2m12.154 16.102l-1.665-1.11A8.96 8.96 0 0 0 21 12a8.96 8.96 0 0 0-1.51-4.993l1.664-1.11A10.95 10.95 0 0 1 23 12c0 2.258-.68 4.356-1.846 6.102"/></svg> ${langText}</p>

          <p><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"><path fill="#f3f3f3" d="M7.75 2.5a.75.75 0 0 0-1.5 0v1.58c-1.44.115-2.384.397-3.078 1.092c-.695.694-.977 1.639-1.093 3.078h19.842c-.116-1.44-.398-2.384-1.093-3.078c-.694-.695-1.639-.977-3.078-1.093V2.5a.75.75 0 0 0-1.5 0v1.513C15.585 4 14.839 4 14 4h-4c-.839 0-1.585 0-2.25.013z"/><path fill="#f3f3f3" fill-rule="evenodd" d="M2 12c0-.839 0-1.585.013-2.25h19.974C22 10.415 22 11.161 22 12v2c0 3.771 0 5.657-1.172 6.828S17.771 22 14 22h-4c-3.771 0-5.657 0-6.828-1.172S2 17.771 2 14zm15 2a1 1 0 1 0 0-2a1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2a1 1 0 0 0 0 2m-4-5a1 1 0 1 1-2 0a1 1 0 0 1 2 0m0 4a1 1 0 1 1-2 0a1 1 0 0 1 2 0m-6-3a1 1 0 1 0 0-2a1 1 0 0 0 0 2m0 4a1 1 0 1 0 0-2a1 1 0 0 0 0 2" clip-rule="evenodd"/></svg> ${album.date}</p>

          <p><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16"><path fill="#f3f3f3" d="M2 1a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v7.256A4.5 4.5 0 0 0 12.5 8a4.5 4.5 0 0 0-3.59 1.787A.5.5 0 0 0 9 9.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .39-.187A4.5 4.5 0 0 0 8.027 12H6.5a.5.5 0 0 0-.5.5V16H3a1 1 0 0 1-1-1zm2 1.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5m3 0v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5m3.5-.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zM4 5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5M7.5 5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zm2.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5h-1a.5.5 0 0 0-.5.5M4.5 8a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5z"/><circle cx="12.5" cy="12.5" r="3.5" fill="#f3f3f3"/><path fill="#282626" d="M20.82 6.49v1a3 3 0 0 1-.32 1.34a3 3 0 0 1-.87 1.07a3.1 3.1 0 0 1-1.25.57q-.301.06-.61.06q-.391 0-.77-.09l-4.24-1.2v8.22a4.79 4.79 0 1 1-1.5-3.47V2.46a.6.6 0 0 1 0-.2v-.08a.76.76 0 0 1 .54-.44h.44l6.3 1.79a3 3 0 0 1 2.22 2.93z" transform="translate(9.5 9.5) scale(0.25)"/></svg>
  <span class="label-wrapper">
    ${album.label || "-"}
    <span id="label-cross-${i}" class="blacklist-cross" data-type="label" data-name="${album.label}" style="cursor:pointer;">✖</span>
  </span>
</p>

          <p><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 48 48"><defs><mask id="ipSTime0"><g fill="none" stroke-linejoin="round" stroke-width="4"><path fill="#fff" stroke="#fff" d="M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Z"/><path stroke="#000" stroke-linecap="round" d="M24.008 12v12.01l8.479 8.48"/></g></mask></defs><path fill="#f3f3f3" d="M0 0h48v48H0z" mask="url(#ipSTime0)"/></svg> ${album.duration}</p>
        </div>

        <div class="alb-footer">
          <button class="mark-listened-btn" onclick="markAlbumAsListened('${album.albumID}', this.closest('.album'))">
            ${album.listened ? "Позначити як не прослуханий" : "Позначити як прослуханий"}
          </button>
          <span id="listens-${i}" class="alb-listens"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 20 20"><path fill="#f3f3f3" d="M5.312 4.566C4.19 5.685-.715 12.681 3.523 16.918c4.236 4.238 11.23-.668 12.354-1.789c1.121-1.119-.335-4.395-3.252-7.312c-2.919-2.919-6.191-4.376-7.313-3.251m9.264 9.59c-.332.328-2.895-.457-5.364-2.928c-2.467-2.469-3.256-5.033-2.924-5.363c.328-.332 2.894.457 5.36 2.926c2.471 2.467 3.258 5.033 2.928 5.365m.858-8.174l1.904-1.906a.999.999 0 1 0-1.414-1.414L14.02 4.568a.999.999 0 1 0 1.414 1.414M11.124 3.8a1 1 0 0 0 1.36-.388l1.087-1.926a1 1 0 0 0-1.748-.972L10.736 2.44a1 1 0 0 0 .388 1.36m8.748 3.016a1 1 0 0 0-1.36-.388l-1.94 1.061a1 1 0 1 0 .972 1.748l1.94-1.061a1 1 0 0 0 .388-1.36"/></svg> ${formatListens(album.listens)}
</span>
        </div>
      </div>

      <div class="tracks" id="tracks-${i}"></div>
    `;

    const favButton = document.createElement("div");
    favButton.classList.add("favorite-button");
    favButton.innerHTML = `
  <div class="favorite-icon">
    <svg viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg" width="24" height="24">
      <path fill="#84AAFB" d="M34,9c-4.2,0-7.9,2.1-10,5.4C21.9,11.1,18.2,9,14,9C7.4,9,2,14.4,2,21c0,11.9,22,24,22,24s22-12,22-24C46,14.4,40.6,9,34,9z"/>
    </svg>
  </div>
`;

    const checkmark = document.createElement("div");
    checkmark.classList.add("favorite-checkmark");
    checkmark.textContent = "✓";
    checkmark.style.display = favoriteAlbums[album.albumID] ? "block" : "none";
    favButton.appendChild(checkmark);

    attachTooltip(
      favButton,
      favoriteAlbums[album.albumID]
        ? "Прибрати альбом з обраного"
        : "Додати альбом до обраного",
    );

    favButton.addEventListener("click", (e) => {
      e.stopPropagation();

      favButton.classList.add("clicked");
      setTimeout(() => favButton.classList.remove("clicked"), 150);

      if (favoriteAlbums[album.albumID]) {
        delete favoriteAlbums[album.albumID];
        checkmark.style.display = "none";
      } else {
        favoriteAlbums[album.albumID] = true;
        checkmark.style.display = "block";
      }

      localStorage.setItem("favoriteAlbums", JSON.stringify(favoriteAlbums));
      updateFavoritesModal();

      removeTooltip(favButton);
      attachTooltip(
        favButton,
        favoriteAlbums[album.albumID]
          ? "Прибрати альбом з обраного"
          : "Додати альбом до обраного",
      );
    });

    albumDiv.appendChild(favButton);

    const spotifyIcon = albumDiv.querySelector(".spotify-icon");
    if (spotifyIcon) attachTooltip(spotifyIcon, "Відкрити в Spotify");

    const ytIcon = albumDiv.querySelector(".yt-icon");
    if (ytIcon) attachTooltip(ytIcon, "Шукати в YouTube Music");

    const appleIcon = albumDiv.querySelector(".apple-icon");
    if (appleIcon) attachTooltip(appleIcon, "Шукати в Apple Music");

    if (album.good) {
      const starBox = document.createElement("div");
      starBox.className = "star-box";
      starBox.innerHTML = '<i class="fas fa-star star-icon"></i>';
      attachTooltip(
        starBox,
        "NUAM рекомендує цей альбом до прослуховування",
        "180px",
      );
      albumDiv.appendChild(starBox);
    }

    const nextAlbum = [...container.children].find((div) => {
      const idx = filteredAlbums.findIndex(
        (a) => a.albumID === div.dataset.albumId,
      );
      return idx > i;
    });

    if (nextAlbum) {
      container.insertBefore(albumDiv, nextAlbum);
    } else {
      container.appendChild(albumDiv);
    }
    albumDiv.querySelector("img").addEventListener("click", function () {
  const thumb = this;
  const imgSrc = thumb.src;
  const opened = document.querySelector(".enlarged-img");
  const modalOverlay = document.getElementById("preview-overlay");

  if (opened) {
    opened.remove();
    modalOverlay.classList.add("hidden");
    document.body.classList.remove("no-scroll");
    const prevTop = parseInt(document.body.style.top || "0") * -1;
    document.body.style.top = "";
    window.scrollTo(0, prevTop);
    return;
  }

  const scrollY = window.scrollY;

  const r = thumb.getBoundingClientRect();
  const startX = r.left;
  const startY = r.top;
  const startW = r.width;
  const startH = r.height;
  const aspect = startW / startH;

  const vw = window.innerWidth, vh = window.innerHeight;
  let targetW = Math.min(640, vw * 0.9);
  let targetH = targetW / aspect;
  if (targetH > vh * 0.9) { targetH = vh * 0.9; targetW = targetH * aspect; }
  const targetX = (vw - targetW) / 2;
  const targetY = (vh - targetH) / 2;

  const enlargedImg = document.createElement("img");
  enlargedImg.src = imgSrc;
  enlargedImg.classList.add("enlarged-img");

  Object.assign(enlargedImg.style, {
    position: "fixed",
    left: "0", top: "0",
    width: startW + "px",
    height: startH + "px",
    transformOrigin: "top left",
    transform: `translate(${startX}px, ${startY}px) scale(1,1)`,
    borderRadius: "0px",
    opacity: "1",
    transition: "transform .35s cubic-bezier(.2,.9,.2,1), opacity .2s ease, border-radius .35s ease"
  });

  document.body.appendChild(enlargedImg);

  modalOverlay.classList.remove("hidden");
  document.body.classList.add("no-scroll");
  document.body.style.top = `-${scrollY}px`;

  requestAnimationFrame(() => {
    const sx = targetW / startW;
    const sy = targetH / startH;
    enlargedImg.style.transform = `translate(${targetX}px, ${targetY}px) scale(${sx}, ${sy})`;
  });

  const closeImg = () => {
    const rr = thumb.getBoundingClientRect();
    const endX = rr.left;
    const endY = rr.top;

const thumbRadius = getComputedStyle(thumb).borderRadius || "8px";
enlargedImg.style.borderRadius = thumbRadius;

enlargedImg.style.transform = `translate(${endX}px, ${endY}px) scale(1,1)`;
modalOverlay.classList.add("hidden");

const cleanup = () => {
  enlargedImg.removeEventListener("transitionend", cleanup);
  requestAnimationFrame(() => {
    enlargedImg.remove();
    document.body.classList.remove("no-scroll");
    document.body.style.top = "";
    window.scrollTo(0, scrollY);
  });
};
enlargedImg.addEventListener("transitionend", cleanup, { once: true });
  };

  enlargedImg.addEventListener("click", closeImg, { once: true });
  modalOverlay.addEventListener("click", closeImg, { once: true });
});

    const tracksContainer = document.getElementById(`tracks-${i}`);

    const playAll = document.createElement("a");
    playAll.classList.add("track-circle", "play-all-toggle");
    playAll.innerHTML = '<i class="fas fa-play"></i>';
    playAll.dataset.albumId = album.albumID;

    attachTooltip(playAll, "Відтворити всі треки альбому");

    tracksContainer.appendChild(playAll);

    playAll.addEventListener("click", async () => {
      if (autoPlayingAlbum && autoPlayingAlbum !== album.albumID) {
        const prevBtn = document.querySelector(
          `.play-all-toggle[data-album-id="${autoPlayingAlbum}"]`,
        );
        if (prevBtn) prevBtn.innerHTML = '<i class="fas fa-play"></i>';

        if (prevBtn) {
          removeTooltip(prevBtn);
          attachTooltip(prevBtn, "Відтворити всі треки альбому");
        }

        if (currentHighlightedCircle) {
          currentHighlightedCircle.classList.remove("highlight");
          currentHighlightedCircle = null;
        }

        previewPlayer.pause();
        previewPlayer.currentTime = 0;

        const prevTracks = document.querySelector(
          `.album[data-album-id="${autoPlayingAlbum}"] .tracks`,
        );
        if (prevTracks) {
          prevTracks
            .querySelectorAll(".track-circle .progress-fill")
            .forEach((el) => (el.style.width = "0%"));
        }

        previewPlayer.ontimeupdate = null;
      }

      if (autoPlayingAlbum === album.albumID) {
        autoPlayingAlbum = null;
        playAll.innerHTML = '<i class="fas fa-play"></i>';

        removeTooltip(playAll);
        attachTooltip(playAll, "Відтворити всі треки альбому");

        togglePreview(true);

        if (currentHighlightedCircle) {
          currentHighlightedCircle.classList.remove("highlight");
          currentHighlightedCircle = null;
        }
        previewPlayer.pause();
        previewPlayer.currentTime = 0;
        previewActivated = false;
        const toggleBtn = document.getElementById("toggle-preview-button");
        if (toggleBtn) {
          toggleBtn.innerHTML = '<i class="fas fa-volume-mute"></i>';
        }

        return;
      }

      autoPlayingAlbum = album.albumID;

      togglePreview(false);

      autoPlayIndex = 0;
      playAll.innerHTML = '<i class="fas fa-stop"></i>';

      removeTooltip(playAll);
      attachTooltip(playAll, "Зупинити відтворення");

      if (!album.tracksInfo) {
        await loadAlbumTracksWithRetry(album);
      }

      function playNext() {
        const container = document.querySelector(
          `.album[data-album-id="${album.albumID}"] .tracks`,
        );
        const btn = document.querySelector(
          `.play-all-toggle[data-album-id="${album.albumID}"]`,
        );
        if (autoPlayingAlbum !== album.albumID) return;

        if (autoPlayIndex >= album.tracksIDs.length) {
          autoPlayingAlbum = null;
          if (btn) btn.innerHTML = '<i class="fas fa-play"></i>';
          if (currentHighlightedCircle) {
            currentHighlightedCircle.classList.remove("highlight");
            currentHighlightedCircle = null;
          }
          return;
        }

        container
          .querySelectorAll(".track-circle .progress-fill")
          .forEach((el) => (el.style.width = "0%"));

        const i = autoPlayIndex;
        const tid = album.tracksIDs[i];
        const hash = album.tracksMP3[i];
        const url = `https://p.scdn.co/mp3-preview/${hash}`;
        const circ = container.querySelector(
          `.track-circle[data-track-id="${tid}"]`,
        );

        if (currentHighlightedCircle)
          currentHighlightedCircle.classList.remove("highlight");
        if (circ) {
          circ.classList.add("highlight");
          currentHighlightedCircle = circ;
        }

        const token = ++playToken;

        previewPlayer.onended = null;
        previewPlayer.onerror = null;
        previewPlayer.ontimeupdate = null;

        const fillEl = circ && circ.querySelector(".progress-fill");
        if (fillEl) {
          previewPlayer.ontimeupdate = () => {
            const dur = previewPlayer.duration || 1;
            fillEl.style.width = (previewPlayer.currentTime / dur) * 100 + "%";
          };
        }

        const probe = new Audio();
        probe.preload = "auto";
        probe.src = url;

        probe.onerror = () => {
          if (token !== playToken || autoPlayingAlbum !== album.albumID) return;
          if (fillEl) fillEl.style.width = "0%";
          markUnavailableCircle(circ);
          autoPlayIndex = i + 1;
          playNext();
        };

        const startPlayback = () => {
          if (token !== playToken || autoPlayingAlbum !== album.albumID) return;

          previewPlayer.src = url;

          previewPlayer.onended = () => {
            if (token !== playToken) return;
            if (fillEl) fillEl.style.width = "0%";
            previewPlayer.ontimeupdate = null;
            autoPlayIndex = i + 1;
            playNext();
          };

          previewPlayer.onerror = () => {
            if (token !== playToken) return;
            if (fillEl) fillEl.style.width = "0%";
            previewPlayer.ontimeupdate = null;
            autoPlayIndex = i + 1;
            playNext();
          };

          previewPlayer.play().catch(() => {});
        };

        probe.oncanplaythrough = startPlayback;
        probe.oncanplay = startPlayback;
      }

      playNext();
      playAll.playNext = playNext;
    });

    album.tracksIDs.forEach((trackID, idx) => {
      const mp3hash = album.tracksMP3[idx] || "";
      if (!trackID || !mp3hash) return;

      const circle = document.createElement("a");
      circle.classList.add("track-circle");
      circle.href = `https://open.spotify.com/track/${trackID}`;
      circle.target = "_blank";
      circle.innerHTML = '<i class="fas fa-music"></i>';

      const fill = document.createElement("div");
      fill.className = "progress-fill";
      circle.appendChild(fill);

      circle.dataset.trackId = trackID;
      circle.dataset.albumId = album.albumID;

      circle.addEventListener("mouseenter", async (e) => {
        if (circle.dataset.unavail === "1") {
          if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
          return;
        }

        if (autoPlayingAlbum !== null) {
          const info = album.tracksInfo && album.tracksInfo[trackID];
          if (info) {
            showSimpleTooltip(
              e.clientX,
              e.clientY,
              `${info.artists.join(", ")} — ${info.name}`,
            );
          }
          return;
        }

        if (!previewActivated) return;

        showSimpleTooltip(e.clientX, e.clientY, "Завантажуємо назву…");
        if (!window._spotifyToken) {
          window._spotifyToken = await getAccessToken();
        }
        if (!album.tracksInfo) {
          await loadAlbumTracksWithRetry(album);
        }
        const info = album.tracksInfo[trackID];
        if (info) {
          showSimpleTooltip(
            e.clientX,
            e.clientY,
            `${info.artists.join(", ")} — ${info.name}`,
          );
        }
      });

      circle.addEventListener("mousemove", (e) => {
        if (circle.dataset.unavail === "1") return;
        moveSimpleTooltip(e.clientX, e.clientY);
      });

      circle.addEventListener("mouseleave", () => {
        hideSimpleTooltip();
        if (previewActivated) {
          previewPlayer.pause();
          previewPlayer.currentTime = 0;
          previewPlayer.removeAttribute("src");
          previewPlayer.load();
        }
      });

      circle.dataset.albumId = album.albumID;
      attachTrackBehavior(circle, `https://p.scdn.co/mp3-preview/${mp3hash}`);

      circle.addEventListener("click", async (evt) => {
        evt.preventDefault();

        document
          .querySelectorAll(".track-circle .progress-fill")
          .forEach((el) => (el.style.width = "0%"));
        previewPlayer.ontimeupdate = null;

        if (autoPlayingAlbum && autoPlayingAlbum !== album.albumID) {
          const prevAlbumId = autoPlayingAlbum;
          autoPlayingAlbum = null;

          const prevBtn = document.querySelector(
            `.album[data-album-id="${prevAlbumId}"] .play-all-toggle`,
          );
          if (prevBtn) {
            prevBtn.innerHTML = '<i class="fas fa-play"></i>';
          }

          if (currentHighlightedCircle) {
            currentHighlightedCircle.classList.remove("highlight");
            currentHighlightedCircle = null;
          }

          previewPlayer.pause();
          previewPlayer.currentTime = 0;
        }

        if (autoPlayingAlbum === album.albumID) {
          const clickedIndex = album.tracksIDs.indexOf(trackID);
          if (clickedIndex >= 0) {
            autoPlayIndex = clickedIndex;

            const hash = album.tracksMP3[autoPlayIndex];
            previewPlayer.src = `https://p.scdn.co/mp3-preview/${hash}`;
            previewPlayer.currentTime = 0;
            previewPlayer.play().catch(() => {});

            if (currentHighlightedCircle) {
              currentHighlightedCircle.classList.remove("highlight");
            }
            const newCirc = tracksContainer.querySelector(
              `.track-circle[data-track-id="${trackID}"]`,
            );
            if (newCirc) {
              newCirc.classList.add("highlight");
              currentHighlightedCircle = newCirc;
            }

            previewPlayer.ontimeupdate = () => {
              const dur = previewPlayer.duration || 1;
              const pct = (previewPlayer.currentTime / dur) * 100;
              const fillEl = newCirc.querySelector(".progress-fill");
              if (fillEl) fillEl.style.width = pct + "%";
            };
          }
          return;
        }

        if (!previewActivated) {
          togglePreview(true);
        }

        previewPlayer.src = `https://p.scdn.co/mp3-preview/${mp3hash}`;
        previewPlayer.currentTime = 0;
        try {
          await previewPlayer.play();
        } catch (e) {
          console.warn("У базі немає уривка цього треку:", e);
        }

        hideSimpleTooltip();
        showSimpleTooltip(evt.clientX, evt.clientY, "Завантажуємо назву…");

        if (!window._spotifyToken) {
          window._spotifyToken = await getAccessToken();
        }
        if (!album.tracksInfo) {
          await loadAlbumTracksWithRetry(album);
        }
        const info = album.tracksInfo[trackID];
        if (info) {
          showSimpleTooltip(
            evt.clientX,
            evt.clientY,
            `${info.artists.join(", ")} — ${info.name}`,
          );
        }
      });

      tracksContainer.appendChild(circle);
    });

    const listensEl = document.getElementById(`listens-${i}`);
    if (album.listens === 0) {
      attachTooltip(
        listensEl,
        "Жоден трек не набрав понад 1000 прослуховувань",
        "170px",
      );
    } else {
      attachTooltip(
        listensEl,
        "Загальна кількість прослуховувань всіх треків релізу",
        "160px",
      );
    }

    const labelCrossEl = document.getElementById(`label-cross-${i}`);
    if (labelCrossEl) {
      attachTooltip(
        labelCrossEl,
        "Не показувати альбоми цього лейбла",
        "160px",
      );
      labelCrossEl.addEventListener("click", function () {
        removeTooltip(labelCrossEl);
        blacklistedLabels.add(album.label);
        localStorage.setItem(
          "blacklistedLabels",
          JSON.stringify([...blacklistedLabels]),
        );
        smoothApplyFilters();
      });
    }

    albumDiv
      .querySelectorAll('.blacklist-cross[data-type="artist"]')
      .forEach((cross) => {
        attachTooltip(cross, "Не показувати альбоми цього артиста", "160px");
        cross.addEventListener("click", () => {
          const artistId = cross.dataset.name;
          removeTooltip(cross);
          blacklistedArtists.add(artistId);
          localStorage.setItem(
            "blacklistedArtists",
            JSON.stringify([...blacklistedArtists]),
          );
          smoothApplyFilters();
        });
      });
  }

  if (autoPlayingAlbum) {
    const playingDiv = document.querySelector(
      `.album[data-album-id="${autoPlayingAlbum}"]`,
    );
    if (playingDiv) {
      const btn = playingDiv.querySelector(".play-all-toggle");
      if (btn) {
        btn.innerHTML = '<i class="fas fa-stop"></i>';
        removeTooltip(btn);
        attachTooltip(btn, "Зупинити відтворення");
      }

      const trackID = albumsData.find((a) => a.albumID === autoPlayingAlbum)
        .tracksIDs[autoPlayIndex];
      const circ = playingDiv.querySelector(
        `.track-circle[data-track-id="${trackID}"]`,
      );
      if (circ) {
        circ.classList.add("highlight");
        currentHighlightedCircle = circ;

        const fill = circ.querySelector(".progress-fill");
        if (fill) {
          previewPlayer.ontimeupdate = () => {
            const dur = previewPlayer.duration || 1;
            fill.style.width = (previewPlayer.currentTime / dur) * 100 + "%";
          };
        }
      }
    }
  }

  currentIndex = endIndex;
const lazyEl = document.getElementById("lazy-loading");
if (currentIndex < data.length) {
  lazyEl.textContent = "Завантаження альбомів…";
} else if (!isEmptyResult) {
  lazyEl.textContent = "";
}
}

function renderArtists(index, album) {
  const fragment = document.createDocumentFragment();

  album.artistNames.forEach((artist, i) => {
    const wrapper = document.createElement("span");
    wrapper.style.whiteSpace = "nowrap";

    if (artist === "Various Artists") {
      wrapper.appendChild(document.createTextNode(artist));
    } else {
      const artistLink = document.createElement("a");
      artistLink.textContent = artist;
      artistLink.href = `https://open.spotify.com/artist/${album.artistIDs[i] || ""}`;
      artistLink.target = "_blank";
      artistLink.style.color = "#f3f3f3";
      artistLink.style.textDecoration = "none";
      artistLink.style.fontWeight = "bold";
      wrapper.appendChild(artistLink);

      const crossSpan = document.createElement("span");
      crossSpan.id = `artist-cross-${index}-${i}`;
      crossSpan.classList.add("blacklist-cross");
      crossSpan.dataset.type = "artist";
      crossSpan.dataset.name = album.artistIDs[i];
      crossSpan.style.cursor = "pointer";
      crossSpan.textContent = " ✖";
      wrapper.appendChild(crossSpan);
    }

    fragment.appendChild(wrapper);

    if (i < album.artistNames.length - 1) {
      const comma = document.createElement("span");
      comma.textContent = ", ";
      fragment.appendChild(comma);
    }
  });

  const div = document.createElement("div");
  div.appendChild(fragment);
  return div.innerHTML;
}

function hideAlbum(albumID) {
  const albumDiv = document.querySelector(`.album[data-album-id="${albumID}"]`);
  if (albumDiv) {
    albumDiv.style.transition = "opacity 0.3s";
    albumDiv.style.opacity = "0";
    setTimeout(() => {
      albumDiv.remove();
      updateAlbumCount();
    }, 300);
  }
}

function showAlbum(album) {
  const container = document.getElementById("albums-container");
  const albumDiv = document.createElement("div");
  albumDiv.classList.add("album");
  albumDiv.style.opacity = "0";
  albumDiv.dataset.albumId = album.albumID;
  albumDiv.innerHTML = `
    <div class="album-overlay"></div>
    <img src="https://i.scdn.co/image/ab67616d0000b273${album.cover}" alt="${album.nameAlbum}">
    <div class="album-details">
      <div class="alb-head">
        ${releaseIcon(album.type)}
        <div class="alb-head-txt">
          <h3><a href="https://open.spotify.com/album/${album.albumID}" target="_blank">${album.nameAlbum}</a></h3>
          <p class="alb-artist">${renderArtists(0, album)}</p>
          <p class="alb-genres">${album.genres.map(friendlyGenreLabel).join(", ") || "Немає даних"}</p>
        </div>
      </div>
      <hr class="alb-sep">
      <div class="alb-meta">
        <p>${album.date}</p>
        <p>${album.label || "-"}</p>
        <p>${album.duration || "-"}</p>
      </div>
    </div>
  `;
  container.appendChild(albumDiv);

  requestAnimationFrame(() => {
    albumDiv.style.transition = "opacity 0.3s";
    albumDiv.style.opacity = "1";
  });
}

function renderReleaseType(t) {
  if (t === "album") return "повноформатний альбом";
  if (t === "ep") return "міні-альбом";
  if (t === "compilation") return "компіляція";
  return t;
}

function attachTrackBehavior(circle, trackPreviewUrl) {
  const tipText =
    "Натисніть для відтворення уривка. Далі наводьте курсор на треки.";
  circle.addEventListener("mouseenter", (e) => {
    if (circle.dataset.unavail === "1") {
      if (typeof hideSimpleTooltip === "function") hideSimpleTooltip();
      return;
    }

    if (autoPlayingAlbum === circle.dataset.albumId) {
      const albumObj = albumsData.find(
        (a) => a.albumID === circle.dataset.albumId,
      );
      const info =
        albumObj &&
        albumObj.tracksInfo &&
        albumObj.tracksInfo[circle.dataset.trackId];
      if (info) {
        showSimpleTooltip(
          e.clientX,
          e.clientY,
          `${info.artists.join(", ")} — ${info.name}`,
        );
      }
      return;
    }

    if (!previewActivated) {
      showSimpleTooltip(e.clientX, e.clientY, tipText);
    } else {
      const token = Symbol();
      circle._hoverToken = token;

      const probe = new Audio();
      probe.preload = "auto";
      probe.src = trackPreviewUrl;

      const start = () => {
        if (circle._hoverToken !== token) return;
        previewPlayer.src = trackPreviewUrl;
        previewPlayer.onerror = () => {
          if (circle._hoverToken !== token) return;
          markUnavailableCircle(circle);
        };
        previewPlayer.play().catch(() => {});
      };

      probe.onerror = () => {
        if (circle._hoverToken !== token) return;
        markUnavailableCircle(circle);
      };

      probe.oncanplay = start;
      probe.oncanplaythrough = start;
    }
  });

  circle.addEventListener("mousemove", (e) => {
    if (!previewActivated || circle.dataset.unavail === "1") return;
    moveSimpleTooltip(e.clientX, e.clientY);
  });

  circle.addEventListener("mouseleave", () => {
    circle._hoverToken = null;

    hideSimpleTooltip();
    if (previewActivated) {
      previewPlayer.pause();
      previewPlayer.currentTime = 0;
      previewPlayer.removeAttribute("src");
      previewPlayer.load();
    }
  });
}

function markAlbumAsListened(albumID, albumElement, fromModal = false) {
  const album = albumsData.find((a) => a.albumID === albumID);
  if (!album) return;

  if (fromModal) {
    delete listenedAlbums[albumID];
    album.listened = false;
  } else {
    album.listened = !album.listened;
    if (album.listened) {
      listenedAlbums[albumID] = true;
    } else {
      delete listenedAlbums[albumID];
    }
  }

  saveListenedAlbums();
  updateListenedAlbumsModal();

  if (albumElement) {
    const markButton = albumElement.querySelector(".mark-listened-btn");
    markButton.textContent = album.listened
      ? "Позначити як не прослуханий"
      : "Позначити як прослуханий";

    albumElement.classList.toggle("album-listened", album.listened);

    if (hideListened && album.listened) {
      albumElement.style.transition = "opacity 0.3s";
      albumElement.style.opacity = "0";
      setTimeout(() => {
        albumElement.remove();
        forceLazyLoadCheck();
      }, 300);
    } else if (!album.listened && hideListened) {
      const reFiltered = getFilteredAlbums();
      const index = reFiltered.findIndex((a) => a.albumID === albumID);
      if (index === -1) return;

      if (sortOrder === "listens-desc") {
        reFiltered.sort((a, b) => b.listens - a.listens);
      } else {
        reFiltered.sort((a, b) => {
          const da = new Date(a.date);
          const db = new Date(b.date);
          return sortOrder === "asc" ? da - db : db - da;
        });
      }

      const container = document.getElementById("albums-container");
      const allDom = [...container.querySelectorAll(".album")];
      const nextDom = allDom.find((div) => {
        const idx = reFiltered.findIndex(
          (a) => a.albumID === div.dataset.albumId,
        );
        return idx > index;
      });

      const dummy = document.createElement("div");
      container.insertBefore(dummy, nextDom || null);
      const prevIndex = currentIndex;
      currentIndex = index;
      renderAlbums(reFiltered.slice(index, index + 1), false);
      dummy.remove();
      currentIndex = prevIndex;
    }
    return;
  }
  preserveScroll(() => applyFilters());
}

function saveListenedAlbums() {
  for (const key in listenedAlbums) {
    if (!listenedAlbums[key]) {
      delete listenedAlbums[key];
    }
  }
  localStorage.setItem("listenedAlbums", JSON.stringify(listenedAlbums));
}

function showBlacklist(isBlacklist = true) {
  const modal = document.getElementById("blacklist-modal");
  const closeBtn = modal.querySelector(".close");
  modal.style.display = "block";
  closeBtn.onclick = () => {
    modal.style.display = "none";
  };
  window.onclick = (ev) => {
    if (ev.target == modal) {
      modal.style.display = "none";
    }
  };
  if (isBlacklist) {
    document.getElementById("blacklist-tab").click();
  } else {
    document.getElementById("listened-albums-tab").click();
  }
}

(() => {
  const el = document.getElementById("temp-disable-blacklist");
  if (!el) return;

  const blTempContainer = document.querySelector(
    "#blacklist-content .bl-temp-toggle",
  );
  if (blTempContainer) {
    attachTooltip(
      blTempContainer,
      "Будуть показані всі релізи, без урахування артистів і лейблів з чорного списку. Це налаштування буде скинуто після перезавантаження сторінки.",
      "360px",
    );
  }

  el.addEventListener("change", (e) => {
    window.tempIgnoreBlacklist = e.target.checked;
    smoothApplyFilters();
  });
})();

function openTab(evt, tabName) {
  const tablinks = document.querySelectorAll(".tablink");
  const tabcontents = document.querySelectorAll(".tabcontent");
  tabcontents.forEach((tb) => tb.classList.remove("active"));
  tablinks.forEach((ln) => ln.classList.remove("active"));
  document.getElementById(tabName).classList.add("active");
  evt.currentTarget.classList.add("active");

  if (tabName === "blacklist-content") {
    updateBlacklist();
  } else if (tabName === "listened-albums-content") {
    updateListenedAlbumsModal();
  } else if (tabName === "export-content") {
    const dataTextarea = document.getElementById("data-textarea");
    dataTextarea.value = generateExportData();
  } else if (tabName === "favorites-content") {
    updateFavoritesModal();
  }
}

function updateBlacklist() {
  const artistsList = document.getElementById("blacklisted-artists");
  const labelsList = document.getElementById("blacklisted-labels");
  artistsList.innerHTML = "";
  labelsList.innerHTML = "";

  if (blacklistedArtists.size === 0) {
    const msg = document.createElement("p");
    msg.textContent = "Тут будуть вилучені вами артисти.";
    msg.style.textAlign = "center";
    msg.style.color = "#f3f3f3";
    artistsList.appendChild(msg);
  } else {
    blacklistedArtists.forEach((artistID) => {
      const artistName =
        albumsData.find((a) => a.artistIDs?.includes(artistID))?.artistNames?.[
          albumsData
            .find((a) => a.artistIDs?.includes(artistID))
            ?.artistIDs.indexOf(artistID)
        ] || "Unknown Artist";

      const li = document.createElement("li");
      const sp = document.createElement("span");
      if (artistName !== "Various Artists") {
        const link = document.createElement("a");
        link.href = `https://open.spotify.com/artist/${artistID}`;
        link.target = "_blank";
        link.textContent = artistName;
        link.style.color = "#f3f3f3";
        link.style.textDecoration = "none";
        link.addEventListener(
          "mouseover",
          () => (link.style.textDecoration = "underline"),
        );
        link.addEventListener(
          "mouseout",
          () => (link.style.textDecoration = "none"),
        );
        sp.appendChild(link);
      } else {
        sp.textContent = artistName;
      }
      sp.style.color = "#f3f3f3";

      const removeIcon = document.createElement("span");
      removeIcon.textContent = "✖";
      removeIcon.classList.add("blacklist-cross");
      removeIcon.addEventListener("click", () => {
        blacklistedArtists.delete(artistID);

        localStorage.setItem(
          "blacklistedArtists",
          JSON.stringify(Array.from(blacklistedArtists)),
        );
        updateBlacklist();

        const albumsContainer = document.getElementById("albums-container");
        smoothApplyFilters();
        forceLazyLoadCheck();
      });

      li.appendChild(sp);
      li.appendChild(removeIcon);
      artistsList.appendChild(li);
    });
  }

  if (blacklistedLabels.size === 0) {
    const msg2 = document.createElement("p");
    msg2.textContent = "Тут будуть вилучені вами лейбли.";
    msg2.style.textAlign = "center";
    msg2.style.color = "#f3f3f3";
    labelsList.appendChild(msg2);
  } else {
    blacklistedLabels.forEach((label) => {
      const li = document.createElement("li");
      const sp = document.createElement("span");
      sp.textContent = label;
      sp.style.color = "#f3f3f3";

      const removeIcon = document.createElement("span");
      removeIcon.textContent = "✖";
      removeIcon.classList.add("blacklist-cross");
      removeIcon.addEventListener("click", () => {
        blacklistedLabels.delete(label);
        localStorage.setItem(
          "blacklistedLabels",
          JSON.stringify(Array.from(blacklistedLabels)),
        );
        updateBlacklist();

        const albumsContainer = document.getElementById("albums-container");
        smoothApplyFilters();
        forceLazyLoadCheck();
      });

      li.appendChild(sp);
      li.appendChild(removeIcon);
      labelsList.appendChild(li);
    });
  }
}

function updateListenedAlbumsModal() {
  const list = document.getElementById("listened-albums-list");
  list.innerHTML = "";

  const listenedArr = albumsData.filter((al) => al.listened);
  if (listenedArr.length === 0) {
    const msg = document.createElement("p");
    msg.textContent = "Тут буде список відслуханих вами альбомів.";
    msg.style.gridColumn = "1 / -1";
    msg.style.textAlign = "center";
    msg.style.color = "#f3f3f3";
    list.appendChild(msg);
  } else {
    listenedArr.forEach((al) => {
      const li = document.createElement("li");
      const a = document.createElement("a");
      const link = `https://open.spotify.com/album/${al.albumID}`;
      a.href = link;
      a.target = "_blank";
      a.textContent = `${al.artistNames.join(", ")} – ${al.nameAlbum}`;
      a.style.cursor = "pointer";

      const removeIcon = document.createElement("span");
      removeIcon.textContent = "✖";
      removeIcon.classList.add("blacklist-cross");
      removeIcon.style.cursor = "pointer";
      removeIcon.style.marginLeft = "10px";
      removeIcon.addEventListener("click", () => {
        markAlbumAsListened(al.albumID, null, true);
        li.remove();
        forceLazyLoadCheck();
      });

      li.appendChild(a);
      li.appendChild(removeIcon);
      list.appendChild(li);
    });
  }
}

function generateExportData() {
  const obj = {
    blacklistArtists: Array.from(blacklistedArtists),
    blacklistLabels: Array.from(blacklistedLabels),
    listenedAlbums: JSON.parse(localStorage.getItem("listenedAlbums")) || {},
    favoriteAlbums: JSON.parse(localStorage.getItem("favoriteAlbums")) || {},
    albumFilters: JSON.parse(localStorage.getItem("albumFilters")) || {},
    presets: getStoredPresets(),
  };
  return JSON.stringify(obj, null, 2);
}

function removeTooltip(el) {
  if (!el) return;
  try {
    if (el._tooltipCleanup) {
      el._tooltipCleanup();
      el._tooltipCleanup = null;
    }
    if (el._tooltip) {
      el._tooltip.remove();
      el._tooltip = null;
    }
  } catch (_) {}
}

function positionTooltip(x, y, tip) {
  const rect = tip.getBoundingClientRect();
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  let tx = x + 10;
  let ty = y + 10;
  if (tx + rect.width > vw) tx = x - rect.width - 10;
  if (ty + rect.height > vh) ty = y - rect.height - 10;
  tip.style.top = `${ty}px`;
  tip.style.left = `${tx}px`;
}

function preserveScroll(callback) {
  const container = document.getElementById("albums-container");
  const anchor = [...container.children].find(
    (el) => el.getBoundingClientRect().top >= 0,
  );
  const anchorId = anchor?.dataset?.albumId;
  const offset = anchor?.getBoundingClientRect().top || 0;

  callback();

  requestAnimationFrame(() => {
    if (anchorId) {
      const newAnchor = container.querySelector(
        `[data-album-id="${anchorId}"]`,
      );
      if (newAnchor) {
        const newOffset = newAnchor.getBoundingClientRect().top;
        const scrollY = window.scrollY + (newOffset - offset);
        window.scrollTo(0, scrollY);
      }
    }
  });
}

function positionTooltip(x, y, tip) {
  const rect = tip.getBoundingClientRect();
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  let tx = x + 10;
  let ty = y + 10;
  if (tx + rect.width > vw) tx = x - rect.width - 10;
  if (ty + rect.height > vh) ty = y - rect.height - 10;
  tip.style.left = `${tx}px`;
  tip.style.top = `${ty}px`;
}

function attachTooltip(el, text, width) {
  if (!el) return;
  el._tooltipText = text;
  if (width !== undefined) el._tooltipWidth = width;
  if (el._tooltipInited) return;
  el._tooltipInited = true;

  function getScrollableAncestors(node) {
    const arr = [window];
    let n = node.parentNode;
    while (n && n !== document) {
      if (n instanceof Element) {
        const cs = getComputedStyle(n);
        if (
          /(auto|scroll|overlay)/.test(
            cs.overflow + cs.overflowX + cs.overflowY,
          )
        ) {
          arr.push(n);
        }
      }
      n = n.parentNode;
    }
    return arr;
  }

  function hideTip() {
    try {
      if (el._tooltipCleanup) {
        el._tooltipCleanup();
        el._tooltipCleanup = null;
      }
      if (el._tooltip) {
        el._tooltip.remove();
        el._tooltip = null;
      }
    } catch (_) {}
  }

  el.addEventListener("mouseenter", (ev) => {
    if (!el._tooltip) {
      const tip = document.createElement("div");
      tip.className = "tooltip";
      tip.style.position = "fixed";
      tip.style.background = "#28262675";
      tip.style.color = "#f3f3f3";
      tip.style.padding = "5px 10px";
      tip.style.borderRadius = "8px";
      tip.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.3)";
      tip.style.fontSize = "12px";
      tip.style.zIndex = "9999";
      tip.style.pointerEvents = "none";
      tip.style.backdropFilter = "blur(8px) saturate(140%)";
      tip.style.webkitBackdropFilter = "blur(8px) saturate(140%)";

      document.body.appendChild(tip);
      el._tooltip = tip;
    }

    const tip = el._tooltip;
    tip.textContent = el._tooltipText;
    tip.style.maxWidth = el._tooltipWidth || "220px";
    tip.style.visibility = "visible";
    positionTooltip(ev.clientX, ev.clientY, tip);

    const scrollTargets = getScrollableAncestors(el);
    const onScroll = () => hideTip();
    const onPointerDown = () => hideTip();
    const onWheel = () => hideTip();
    const onResize = () => hideTip();
    const onKey = (e) => {
      if (e.key === "Escape") hideTip();
    };
    const onMoveOut = (e) => {
      if (!e.composedPath().includes(el)) hideTip();
    };

    for (const t of scrollTargets) {
      t.addEventListener("scroll", onScroll, { capture: true, passive: true });
    }
    document.addEventListener("pointerdown", onPointerDown, true);
    document.addEventListener("wheel", onWheel, {
      passive: true,
      capture: true,
    });
    window.addEventListener("resize", onResize, true);
    document.addEventListener("keydown", onKey, true);
    document.addEventListener("pointermove", onMoveOut, true);

    let raf = 0;
    const watchHover = () => {
      raf = requestAnimationFrame(() => {
        if (!el.matches(":hover")) hideTip();
        else watchHover();
      });
    };
    watchHover();

    el._tooltipCleanup = () => {
      for (const t of scrollTargets)
        t.removeEventListener("scroll", onScroll, true);
      document.removeEventListener("pointerdown", onPointerDown, true);
      document.removeEventListener("wheel", onWheel, true);
      window.removeEventListener("resize", onResize, true);
      document.removeEventListener("keydown", onKey, true);
      document.removeEventListener("pointermove", onMoveOut, true);
      cancelAnimationFrame(raf);
    };
  });

  el.addEventListener("mousemove", (ev) => {
    const tip = el._tooltip;
    if (tip && tip.style.visibility === "visible") {
      positionTooltip(ev.clientX, ev.clientY, tip);
    }
  });

  el.addEventListener("mouseleave", hideTip);
  el.addEventListener("blur", hideTip);
}

function removeTooltip(el) {
  if (!el) return;
  try {
    if (el._tooltipCleanup) {
      el._tooltipCleanup();
      el._tooltipCleanup = null;
    }
    if (el._tooltip) {
      el._tooltip.remove();
      el._tooltip = null;
    }
  } catch (_) {}
}

let simpleTooltip = null;
let simpleTooltipCleanup = null;

function showSimpleTooltip(x, y, text) {
  if (!simpleTooltip) {
    simpleTooltip = document.createElement("div");
    simpleTooltip.style.position = "fixed";
    simpleTooltip.style.background = "#28262675";
    simpleTooltip.style.color = "#f3f3f3";
    simpleTooltip.style.padding = "5px 10px";
    simpleTooltip.style.borderRadius = "8px";
    simpleTooltip.style.boxShadow = "0 4px 6px rgba(0, 0, 0, 0.3)";
    simpleTooltip.style.fontSize = "12px";
    simpleTooltip.style.whiteSpace = "normal";
    simpleTooltip.style.maxWidth = "200px";
    simpleTooltip.style.zIndex = "9999";
    simpleTooltip.style.pointerEvents = "none";
    simpleTooltip.style.backdropFilter = "blur(8px) saturate(140%)";
    simpleTooltip.style.webkitBackdropFilter = "blur(8px) saturate(140%)";
    document.body.appendChild(simpleTooltip);
  }

  if (simpleTooltipCleanup) simpleTooltipCleanup();

  simpleTooltip.textContent = text;
  simpleTooltip.style.visibility = "visible";
  positionTooltip(x, y, simpleTooltip);

  const onScroll = () => hideSimpleTooltip();
  const onPointerDown = () => hideSimpleTooltip();
  const onWheel = () => hideSimpleTooltip();
  const onResize = () => hideSimpleTooltip();
  const onKey = (e) => {
    if (e.key === "Escape") hideSimpleTooltip();
  };

  window.addEventListener("scroll", onScroll, { capture: true, passive: true });
  document.addEventListener("pointerdown", onPointerDown, true);
  document.addEventListener("wheel", onWheel, { passive: true, capture: true });
  window.addEventListener("resize", onResize, true);
  document.addEventListener("keydown", onKey, true);

  simpleTooltipCleanup = () => {
    window.removeEventListener("scroll", onScroll, true);
    document.removeEventListener("pointerdown", onPointerDown, true);
    document.removeEventListener("wheel", onWheel, true);
    window.removeEventListener("resize", onResize, true);
    document.removeEventListener("keydown", onKey, true);
    simpleTooltipCleanup = null;
  };
}

function moveSimpleTooltip(x, y) {
  if (simpleTooltip && simpleTooltip.style.visibility === "visible") {
    positionTooltip(x, y, simpleTooltip);
  }
}

function hideSimpleTooltip() {
  if (simpleTooltip) {
    simpleTooltip.style.visibility = "hidden";
  }
  if (simpleTooltipCleanup) {
    simpleTooltipCleanup();
  }
}

function smoothApplyFilters() {
  clearActivePreset();
  isFiltering = true;
  const container = document.getElementById("albums-container");

  window.removeEventListener("scroll", handleScroll);
  container.style.transition = "opacity 0.2s";
  container.style.opacity = "0.3";

  setTimeout(() => {
    preserveScroll(() => applyFilters());

    requestAnimationFrame(() => {
      container.style.opacity = "1";
      isFiltering = false;
      window.addEventListener("scroll", throttle(handleScroll, 200));
    });
  }, 50);
}

function updateFavoritesModal() {
  const list = document.getElementById("favorites-albums-list");
  list.innerHTML = "";
  const favArr = albumsData.filter((al) => favoriteAlbums[al.albumID]);
  if (favArr.length === 0) {
    const msg = document.createElement("p");
    msg.textContent = "Тут буде список ваших улюблених альбомів.";
    msg.style.gridColumn = "1 / -1";
    msg.style.textAlign = "center";
    msg.style.color = "#f3f3f3";
    list.appendChild(msg);
  } else {
    favArr.forEach((al) => {
      const li = document.createElement("li");

      const img = document.createElement("img");
      img.src = `https://i.scdn.co/image/ab67616d0000b273${al.cover}`;
      img.alt = al.nameAlbum;

      const a = document.createElement("a");
      a.href = `https://open.spotify.com/album/${al.albumID}`;
      a.target = "_blank";
      a.textContent = `${al.artistNames.join(", ")} – ${al.nameAlbum}`;
      a.style.color = "#f3f3f3";

const removeIcon = document.createElement("span");
removeIcon.textContent = "✖";
removeIcon.classList.add("blacklist-cross");
removeIcon.style.cursor = "pointer";
removeIcon.addEventListener("click", () => {
  delete favoriteAlbums[al.albumID];
  localStorage.setItem("favoriteAlbums", JSON.stringify(favoriteAlbums));
  updateFavoritesModal();
});

const iconsCol = document.createElement("div");
iconsCol.style.display = "flex";
iconsCol.style.flexDirection = "column";
iconsCol.style.alignItems = "center";
iconsCol.style.justifyContent = "center";
iconsCol.style.gap = "6px";
iconsCol.style.marginLeft = "auto";

const mkBox = () => {
  const box = document.createElement("div");
  box.style.width = "20px";
  box.style.height = "20px";
  box.style.display = "inline-flex";
  box.style.alignItems = "center";
  box.style.justifyContent = "center";
  box.style.position = "relative";
  return box;
};

const removeBox = mkBox();
removeBox.appendChild(removeIcon);

const copyBox = mkBox();
copyBox.style.cursor = "pointer";

const icoCopy = document.createElement("i");
icoCopy.className = "fa-regular fa-copy";
icoCopy.style.fontSize = "16px";
icoCopy.style.color = "#bababa";
icoCopy.style.transition = "color .2s, opacity .2s";
icoCopy.style.position = "absolute";
icoCopy.style.left = "50%";
icoCopy.style.top = "50%";
icoCopy.style.transform = "translate(-50%,-50%)";

const icoCheck = document.createElement("i");
icoCheck.className = "fa-solid fa-check";
icoCheck.style.fontSize = "16px";
icoCheck.style.color = "#3cc16e";
icoCheck.style.opacity = "0";
icoCheck.style.transition = "opacity .2s";
icoCheck.style.position = "absolute";
icoCheck.style.left = "50%";
icoCheck.style.top = "50%";
icoCheck.style.transform = "translate(-50%,-50%)";

copyBox.appendChild(icoCopy);
copyBox.appendChild(icoCheck);

copyBox.addEventListener("mouseenter", () => {
  if (icoCheck.style.opacity === "0") icoCopy.style.color = "#f3f3f3";
});
copyBox.addEventListener("mouseleave", () => {
  if (icoCheck.style.opacity === "0") icoCopy.style.color = "#bababa";
});

const copyTitle = async () => {
  const txt = a.textContent || "";
  let ok = false;
  try {
    if (navigator.clipboard && navigator.clipboard.writeText) {
      await navigator.clipboard.writeText(txt);
      ok = true;
    }
  } catch(e){}
  if (!ok) {
    const ta = document.createElement("textarea");
    ta.value = txt;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.opacity = "0";
    ta.style.pointerEvents = "none";
    ta.style.setProperty("user-select", "text", "important");
    ta.style.setProperty("-webkit-user-select", "text", "important");
    document.body.appendChild(ta);
    ta.select();
    try { ok = document.execCommand("copy"); } catch(e){}
    document.body.removeChild(ta);
  }

  icoCopy.style.opacity = "0";
  icoCheck.style.opacity = "1";
  setTimeout(() => {
    icoCheck.style.opacity = "0";
    icoCopy.style.opacity = "1";
    icoCopy.style.color = "#bababa";
  }, 1000);
};

copyBox.addEventListener("click", (e) => {
  e.preventDefault();
  e.stopPropagation();
  copyTitle();
});

iconsCol.appendChild(removeBox);
iconsCol.appendChild(copyBox); 

li.appendChild(img);
li.appendChild(a);
li.appendChild(iconsCol);
list.appendChild(li);
    });
  }
}

function updateAlbumCount() {
  const el = document.getElementById("album-count");
  if (!el || !Array.isArray(filteredAlbums)) return;

  const sepIndex = filteredAlbums.findIndex((a) => a && a.__separatorType);

  const count = sepIndex === -1 ? filteredAlbums.length : sepIndex;

  el.textContent = String(count);
}

const toggleEditBtn = document.getElementById("toggle-edit-presets");
const presetsWrapper = document.querySelector(".presets-wrapper");
let sortable;

function attachPresetControls() {
  presetsWrapper.querySelectorAll(".preset-item").forEach((btn) => {
    if (!btn.querySelector(".drag-handle")) {
      const handle = document.createElement("div");
      handle.className = "drag-handle";
      btn.appendChild(handle);
    }

    if (!btn.querySelector(".delete-handle")) {
      const del = document.createElement("span");
      del.className = "delete-handle";
      del.textContent = "×";
      btn.appendChild(del);
      del.addEventListener("click", (e) => {
        e.stopPropagation();
        showDeleteConfirm(btn);
      });
    }

    if (!btn.querySelector(".edit-name-handle")) {
      const edit = document.createElement("span");
      edit.className = "edit-name-handle";
      edit.textContent = "✎";
      btn.appendChild(edit);
      edit.addEventListener("click", (e) => {
        e.stopPropagation();
        showRenameModal(btn);
      });
    }
  });
}

toggleEditBtn.addEventListener("click", () => {
  const isEditing = presetsWrapper.classList.toggle("editing");

  toggleEditBtn.classList.toggle("active", isEditing);
  if (isEditing) {
    attachPresetControls();
    sortable = Sortable.create(presetsWrapper, {
      animation: 150,
      handle: ".drag-handle",
      onEnd: () => {
        const newArr = Array.from(presetsWrapper.children).map((b) =>
          JSON.parse(b.dataset.presetJson),
        );
        savePresetsToStorage(newArr);
      },
    });
  } else {
    sortable.destroy();
    presetsWrapper
      .querySelectorAll(".drag-handle, .delete-handle, .edit-name-handle")
      .forEach((el) => el.remove());
  }
});

function showDeleteConfirm(btn) {
  const overlay = document.createElement("div");
  overlay.style =
    "" +
    "position:fixed;top:0;left:0;width:100%;height:100%;" +
    "display:flex;align-items:center;justify-content:center;z-index:2000;" +
    "background: rgba(53, 53, 60, 0.55);" +
    "backdrop-filter: blur(8px) saturate(140%);" +
    "-webkit-backdrop-filter: blur(8px) saturate(140%);" +
    "background-image: var(--grain-bg);" +
    "background-size: 160px 160px;" +
    "background-blend-mode: overlay;";

  const dlg = document.createElement("div");
  dlg.style =
    "" +
    "background:#282626;padding:20px;border-radius:8px;" +
    "color:#f3f3f3;text-align:center;";

  dlg.addEventListener("click", (e) => e.stopPropagation());

  const txt = document.createElement("p");
  txt.textContent = "Видалити фільтр?";
  txt.style = "padding:0px 20px 20px 20px;margin:auto;";

  const btnKeep = document.createElement("button");
  btnKeep.textContent = "Залишити";
  btnKeep.className = "modal-action keep-btn";
  btnKeep.style = "margin:0 10px;";

  const btnDel = document.createElement("button");
  btnDel.textContent = "Видалити";
  btnDel.className = "modal-action delete-btn";
  btnDel.style = "margin:0 10px;";

  function close() {
    document.removeEventListener("keydown", onKey);
    if (overlay.parentNode) document.body.removeChild(overlay);
    document.body.style.overflow = prevOverflow;
  }

  overlay.addEventListener("click", close);
  btnKeep.addEventListener("click", close);

  btnDel.addEventListener("click", () => {
    const cfg = JSON.parse(btn.dataset.presetJson);
    const arr = getStoredPresets().filter((p) => p.name !== cfg.name);
    savePresetsToStorage(arr);
    loadPresetsFromStorage();
    updateRestorePresetUI();
    close();
  });

  dlg.append(txt, btnKeep, btnDel);
  overlay.appendChild(dlg);

  const prevOverflow = document.body.style.overflow || "";
  document.body.style.overflow = "hidden";
  document.body.appendChild(overlay);

  const onKey = (e) => {
    if (e.key === "Escape") close();
  };
  document.addEventListener("keydown", onKey);
}

function showRenameModal(btn) {
  const modal = document.getElementById("edit-name-modal");
  const input = modal.querySelector("#edit-name-input");
  const msg = modal.querySelector("#edit-name-message");
  const save = modal.querySelector("#edit-name-save");
  const descInput = modal.querySelector("#edit-desc-input");

  const cfg = JSON.parse(btn.dataset.presetJson);
  const oldName = cfg.name;
  input.value = oldName;
  msg.textContent = "";
  if (descInput) descInput.value = cfg.desc || "";

  modal.style.display = "block";
  document.body.style.overflow = "hidden";
  input.focus();

  save.onclick = () => {
    const newName = input.value.trim();
    if (!newName) {
      msg.textContent = "Вкажіть назву фільтра";
      msg.className = "error";
      setTimeout(() => (msg.textContent = ""), 3000);
      return;
    }

    const presets = getStoredPresets();
    const idx = presets.findIndex((p) => p.name === oldName);
    if (idx >= 0) presets[idx].name = newName;
    const newDesc = (descInput?.value || "").trim().slice(0, 250);
    if (idx >= 0) presets[idx].desc = newDesc || undefined;

    savePresetsToStorage(presets);
    loadPresetsFromStorage();

    modal.style.display = "none";
    document.body.style.overflow = "auto";
  };
}

(() => {
  const modal = document.getElementById("edit-name-modal");
  const content = modal.querySelector(".modal-content");
  modal.querySelector(".close").addEventListener("click", () => {
    modal.style.display = "none";
    document.body.style.overflow = "auto";
  });

  modal.addEventListener("click", (e) => {
    if (!content.contains(e.target)) {
      modal.style.display = "none";
      document.body.style.overflow = "auto";
    }
  });
})();

document.getElementById("stats-button").addEventListener("click", () => {
  if (typeof createStatsModal === "function") createStatsModal();
  if (typeof openStatsModal === "function") openStatsModal();
});

window.createAboutModal = function () {
  if (document.getElementById("about-modal")) return;

  const src = document.getElementById("nuam-about-modal");
  const titleText = src?.querySelector("#nuam-about-title")?.textContent || "Про проєкт";
  const bodyHtml  = src?.querySelector(".nuam-modal__body")?.innerHTML || "";

  const overlay = document.createElement("div");
  overlay.id = "about-modal";
  overlay.className = "modal hidden";

  overlay.innerHTML = `
    <div class="modal-content">
      <span class="close" id="about-close">&times;</span>
      <h3 style="color:#f3f3f3; margin:0 0 20px;">${titleText}</h3>
      <div class="modal-body" style="overflow:auto; color:#f3f3f3; font-size:16px; margin: -10px 0px -10px 0px;">
        ${bodyHtml}
      </div>
    </div>
  `;

  document.body.appendChild(overlay);

  const content = overlay.querySelector(".modal-content");
  const closeX  = overlay.querySelector("#about-close");

  closeX.addEventListener("click", () => {
    overlay.classList.add("hidden");
    document.body.style.overflow = "auto";
  });

  overlay.addEventListener("click", (e) => {
    if (!content.contains(e.target)) {
      overlay.classList.add("hidden");
      document.body.style.overflow = "auto";
    }
  });
};

window.openAboutModal = function () {
  const el = document.getElementById("about-modal");
  if (!el) return;
  el.classList.remove("hidden");
  document.body.style.overflow = "hidden";
};

document.getElementById("ld-about-btn")?.addEventListener("click", () => {
  if (typeof createAboutModal === "function") createAboutModal();
  if (typeof openAboutModal === "function") openAboutModal();
});
    
async function copyExportData() {
  const text = document.getElementById("data-textarea")?.value ?? "";

  try {
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return true;
    }
  } catch (_) {}

  try {
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.opacity = "0";
    ta.style.pointerEvents = "none";
    document.body.appendChild(ta);
    ta.select();
    const ok = document.execCommand("copy");
    document.body.removeChild(ta);
    return ok;
  } catch (_) {
    return false;
  }
}

(function attachExportCopy() {
  const oldBtn = document.getElementById("export-data");
  if (!oldBtn) return;
  const btn = oldBtn.cloneNode(true);
  oldBtn.replaceWith(btn);

  const msgEl = document.getElementById("export-message");

  btn.addEventListener("click", async (e) => {
    e.preventDefault();
    const ok = await copyExportData();
    if (msgEl) {
      msgEl.textContent = ok ? "Скопійовано!" : "Копіювання заблоковано";
      msgEl.className = ok ? "success" : "error";
      setTimeout(
        () => {
          msgEl.textContent = " ";
          msgEl.className = "";
        },
        ok ? 2000 : 4000,
      );
    }
  });
})();

(function isolateWheel() {
  const ROOT = document.scrollingElement || document.documentElement;

  function isScrollable(el) {
    if (!(el instanceof Element)) return false;
    const cs = getComputedStyle(el);
    const canY =
      (cs.overflowY === "auto" ||
        cs.overflowY === "scroll" ||
        cs.overflowY === "overlay") &&
      el.scrollHeight > el.clientHeight + 1;
    const canX =
      (cs.overflowX === "auto" ||
        cs.overflowX === "scroll" ||
        cs.overflowX === "overlay") &&
      el.scrollWidth > el.clientWidth + 1;
    return canY || canX;
  }

  function closestScrollable(start) {
    let el = start;
    while (el && el !== document && el !== ROOT) {
      if (isScrollable(el)) return el;
      el = el.parentNode;
    }
    return null;
  }

  function willScroll(el, dx, dy) {
    if (!el) return false;
    const atTop = el.scrollTop <= 0;
    const atBottom = el.scrollTop + el.clientHeight >= el.scrollHeight - 1;
    if (dy < 0 && atTop) return false;
    if (dy > 0 && atBottom) return false;

    const atLeft = el.scrollLeft <= 0;
    const atRight = el.scrollLeft + el.clientWidth >= el.scrollWidth - 1;
    if (dx < 0 && atLeft) return false;
    if (dx > 0 && atRight) return false;

    return true;
  }

  function isInside(selector, node) {
    while (node && node !== document) {
      if (node instanceof Element && node.matches(selector)) return true;
      node = node.parentNode;
    }
    return false;
  }

  document.addEventListener(
    "wheel",
    function (e) {
      if (e.ctrlKey) return;
      const path = e.composedPath ? e.composedPath() : null;
      const target = path ? path[0] : e.target;

      const scroller = closestScrollable(target);

      if (!scroller) {
        if (isInside(".controls, .modal", target)) e.preventDefault();
        return;
      }

      if (!willScroll(scroller, e.deltaX, e.deltaY)) {
        e.preventDefault();
      }
    },
    { passive: false, capture: true },
  );
})();

  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.14.0/Sortable.min.js"></script>

</body>
</html>
