<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NUAM Albums</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/js/all.min.js" crossorigin="anonymous"></script>
  <style>
    @font-face {
         font-family: 'CustomFont';
         src: url('https://static.wixstatic.com/ufonts/c77f36_8e332f6e48954416a7131ece2e2fab0f/woff2/file.woff2') format('woff2');
    }
     html, body {
            font-family: 'CustomFont', Arial, sans-serif;
      background-color: #282626;
      margin: 0;
      padding: 0;
    }

    h1 {
      margin-top: 20px;
      color: #f3f3f3;
    }

    h4 {
      text-align: center;
      margin-top: 20px;
      color: #f3f3f3;
    }
    
    body::-webkit-scrollbar {
  width: 10px;
}

body::-webkit-scrollbar-track {
  background: #282626;
}

body::-webkit-scrollbar-thumb {
  background-color: #383838;
  border-radius: 7px;
  border: 2px solid #282626;
}

body::-webkit-scrollbar-thumb:hover {
  background-color: #383838;
}

body::-webkit-scrollbar-button {
  display: none;
}
    
    body.no-scroll {
  overflow: hidden;
}
    
    .checkbox-container::-webkit-scrollbar {
    width: 14px;
}

.checkbox-container::-webkit-scrollbar-track {
    background: transparent;
}
    
    .checkbox-container::-webkit-scrollbar-thumb {
    background-color: #282626;
    border-radius: 7px;
    border: 3px solid #383838;
}
    
input[type="checkbox"] {
  width: 20px;
  height: 20px;
  cursor: pointer;
  appearance: none;
  border: 1px solid #84AAFB;
  border-radius: 4px;
  background-color: #383838;
  display: inline-block;
  position: relative;
  vertical-align: middle;
  margin-right: 8px;
}

input[type="checkbox"]:checked {
  background-color: #84AAFB;
  border-color: #84AAFB;
}

input[type="checkbox"]:checked::after {
  content: '\2713';
  color: #282626;
  font-size: 12px;
  font-weight: bold;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
 
    #genre-checkboxes {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  padding-bottom: 10px;
}

    .controls {
  display: flex;
  margin: 0;
  padding: 20px;
  gap: 20px;
  position: sticky;
  top: 0;
  z-index: 1000;
  background-color: #282626;
  box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
  user-select: none !important;
}


    .filter-section {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    align-items: flex-start;
}

    .checkbox-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  max-height: 200px;
  overflow-y: auto;
  padding: 10px;
  border-radius: 7px;
  background-color: #383838;
  position: relative;
  max-width: 650px;
}

    .checkbox-container:nth-of-type(2) {
  width: 180px !important;
  max-width: 180px;
}
    
    .checkbox-container:nth-of-type(3) {
  width: 220px !important;
  max-width: 220px;
}
    
.checkbox-container label {
  display: inline-flex;
  align-items: center;
  gap: 10px;
  color: #f3f3f3;
}

    .checkbox-container .section-title {
  position: sticky;
  top: 0;
  z-index: 1;
  padding: 10px;
}

    .genre-name {
  font-weight: bold;
  font-size: 14px;
}

.genre-count {
  color: gray;
  font-size: 12px;
}

.language-name {
  font-weight: bold;
  font-size: 14px;
}
    
.language-count {
  color: gray;
  font-size: 12px;
}

    .release-type-filter-item {
      font-weight: bold;
      font-size: 14px;
    }
    
    .sort-and-blacklist {
  }

  .sort-section {
    display: flex;
    align-items: center;
    gap: 10px;
    color: #f3f3f3;
  }

  .hide-listened-section {
    display: flex;
    align-items: center;
    gap: 10px;
    color: #f3f3f3;
    padding-top: 20px;
  }

    .blacklist-artists::-webkit-scrollbar,
.blacklist-labels::-webkit-scrollbar {
  width: 10px;
  border-radius: 7px;
}

.blacklist-artists::-webkit-scrollbar-track,
.blacklist-labels::-webkit-scrollbar-track {
  background: #282626;
  border-radius: 7px;
}

.blacklist-artists::-webkit-scrollbar-thumb,
.blacklist-labels::-webkit-scrollbar-thumb {
  background: #383838;
  border-radius: 7px;
  border: 3px solid #282626;
}

    .blacklist-container {
  display: flex;
  gap: 20px;
}
    
    .blacklist-artists,
.blacklist-labels {
  flex: 1;
  max-height: 300px;
  overflow-y: auto;
  background-color: #282626;
  padding: 10px;
  border-radius: 7px;
}

.blacklist-artists h4,
.blacklist-labels h4 {
  position: sticky;
  top: 0;
  background-color: #383838;
  padding: 10px;
  margin: 0;
  border-radius: 7px;
  z-index: 1;
}

.blacklist-artists ul,
.blacklist-labels ul {
  list-style-type: none;
  padding: 0;
  margin-top: 20px;
  color: #f3f3f3;
}

.blacklist-artists li,
.blacklist-labels li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 0;
}
    
  .blacklist-section {
    margin: 20px 0;
  }

    .listened-albums-container {
  max-height: 300px;
  overflow-y: auto;
  background-color: #383838;
  padding: 10px;
  border-radius: 7px;
}

.listened-albums-container ul {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 10px;
  list-style-type: none;
  padding: 0;
  margin: 0;
  color: #f3f3f3;
}

.listened-albums-container li {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 10px;
  background-color: #282626;
  border-radius: 5px;
}

.listened-albums-container a {
  color: #f3f3f3;
  text-decoration: none;
}

.listened-albums-container a:hover {
  text-decoration: underline;
}

.listened-albums-container .blacklist-cross {
  cursor: pointer;
  color: #e74c3c;
  font-size: 16px;
}

.listened-albums-container .blacklist-cross:hover {
  color: #c0392b;
}

.listened-albums-container::-webkit-scrollbar {
  width: 10px;
}

.listened-albums-container::-webkit-scrollbar-track {
  background: #383838;
}

.listened-albums-container::-webkit-scrollbar-thumb {
  background: #282626;
  border-radius: 7px;
}

  label, select, button {
    color: #f3f3f3;
  }
    
    .button-group {
  display: flex;
  gap: 10px;
  margin-top: auto;
  position: sticky;
  bottom: 0;
  background-color: #383838;
  padding: 0;
}

    select {
    background-color: #383838;
    border: 1px solid #84AAFB;
    border-radius: 7px;
    padding: 5px;
  }
    
    button {
      padding: 10px 20px;
      background-color: #84AAFB;
      color: #282626;
      border: 1px solid #84AAFB;
      border-radius: 7px;
      cursor: pointer;
      transition: border 0.3s ease;
    }

    button:hover {
      border: 1px solid #f3f3f3;
    }

    #albums-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      padding: 20px;
      user-select: none !important;
    }

    .album {
  background-color: #383838;
  border-radius: 7px;
  overflow: visible;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  position: relative;
  display: flex;
  flex-direction: column;
}

.album img {
  width: 100%;
  height: auto;
  cursor: pointer;
  transition: transform 0.3s ease, z-index 0.3s ease;
  border-radius: 7px;
}

.album img:hover {
  transform: scale(1.02);
  z-index: 10;
}

    .album-details {
      padding: 15px;
      flex-grow: 1;
      background-color: #383838;
    }
    
    .album-details h3 {
      margin: 0 0 10px 0;
      color: #f3f3f3;
    }

    .album-details p {
      margin: 5px 0;
      color: #f3f3f3;
    }

    .album-details a {
      color: #f3f3f3;
      text-decoration: none;
      font-weight: bold;
    }

    .album-details a:hover {
      text-decoration: underline;
    }

    .tracks {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: auto;
      padding: 0 15px 15px 15px;
    }

    .track-circle {
      width: 40px;
      height: 40px;
      background-color: #eee;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      text-decoration: none;
      transition: background-color 0.3s ease;
    }

    .track-circle:hover {
      background-color: #ddd;
    }

    .track-circle i {
      font-size: 20px;
      color: #555;
    }

    .lazy-loading {
      text-align: center;
      margin: 20px 0;
      color: #f3f3f3;
      user-select: none !important;
    }

    audio {
      display: none;
    }

    .album-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(40, 38, 38, 0.7);
  display: none;
  pointer-events: none;
  z-index: 1;
}

.album-listened .album-overlay {
  display: block;
}

.album-listened img:hover {
  background-color: rgba(40, 38, 38, 0.7);
}

    .mark-listened-btn {
      margin: 10px 15px;
      cursor: pointer;
      padding: 5px 10px;
      background-color: #84AAFB;
      color: #282626;
      border: 1px solid #84AAFB;
      border-radius: 7px;
      align-self: flex-start;
      transition: border 0.3s ease;
      z-index: 9;
    }

    .mark-listened-btn:hover {
      border: 1px solid #f3f3f3;
    }

    .enlarged-img {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 640px;
  z-index: 1000;
  cursor: pointer;
  box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
}

    .modal-overlay {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  z-index: 1000;
}
    
    .modal {
  display: none; 
  position: fixed; 
  z-index: 1; 
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
      z-index: 1000;
}

.modal-content {
  background-color: #383838;
  margin: 15% auto;
  padding: 20px;
  border-radius: 7px;
  width: 80%;
  user-select: none !important;
}

    .modal-content h3 {
  color: #f3f3f3;
}
     
.tabcontent {
  display: none;
}

.tabcontent.active {
  display: block;
}

.tablink {
  background-color: #282626;
  color: #f3f3f3;
  padding: 10px 20px;
  border: 1px solid #f3f3f3;
  cursor: pointer;
  transition: border-color 0.3s ease, background-color 0.3s ease;
  font-weight: bold;
  margin-bottom: 20px;
  margin-right: 10px;
}

.tablink.active {
  background-color: #84AAFB;
  border: 1px solid #84AAFB;
  color: #282626;
}

    .tablink.active:hover {
  background-color: #84AAFB;
}
    
.tablink:hover {
  background-color: #282626;
  border: 1px solid #84AAFB;
}

.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}

.close:hover,
.close:focus {
  color: #f3f3f3;
  text-decoration: none;
  cursor: pointer;
}

    .album-details .blacklist-cross {
  display: none;
}

.album-details:hover .blacklist-cross {
  display: inline;
}
    
    .blacklist-cross {
      cursor: pointer;
      color: #e74c3c;
      margin-left: 10px;
      font-size: 12px;
      font-weight: bold;
    }

    .blacklist-cross:hover {
      color: #c0392b;
    }
    
    .export-import-container {
  display: flex;
  gap: 20px;
  justify-content: space-between;
}

.export-section, .import-section {
  flex: 1;
}

textarea {
  width: 100%;
  height: 150px;
  padding: 10px;
  border: 1px solid #f3f3f3;
  border-radius: 7px;
  background-color: #282626;
  resize: none;
  color: #f3f3f3;
}

#export-data, #import-data {
  margin-top: 10px;
  padding: 10px 20px;
  font-size: 14px;
  cursor: pointer;
  background-color: #4CAF50;
  color: white;
  border: none;
  border-radius: 5px;
}

#export-data:hover, #import-data:hover {
  background-color: #388e3c;
}
    
    .exclude-genre {
  color: #e74c3c;
   margin-left: 5px;
      font-size: 12px;
      font-weight: bold;
}
    
    .exclude-genre:hover {
  color: #c0392b;
}
    
    .genre-filter-item .exclude-genre {
  visibility: hidden;
}

.genre-filter-item:hover .exclude-genre {
  visibility: visible;
}
    
    .repeat-symbol {
  color: #90EE90;
}

.repeat-symbol:hover {
  color: #7dc77d;
}
    
    .language-filter-item .exclude-language {
  display: none;
}

.language-filter-item:hover .exclude-language {
  display: inline;
}

.exclude-language {
  cursor: pointer;
  color: #e74c3c;
  margin-left: 10px;
  font-size: 12px;
  font-weight: bold;
}

.exclude-language:hover {
  color: #c0392b;
}
    
.language-repeat-symbol {
  color: #90EE90;
}

.language-repeat-symbol:hover {
  color: #7dc77d;
}
 
    .star-icon {
  background-color: #282626;
  border-radius: 7px;
  padding: 8px;
  box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.3);
}

.section-title {
    background-color: #282626;
    color: #f3f3f3;
    padding: 10px 15px;
    font-size: 18px;
    font-weight: bold;
    border-radius: 7px;
    margin-bottom: 10px;
    display: block;
    text-align: center;
    width: 100%;
    box-sizing: border-box;
}

body.no-scroll {
  position: fixed;
  width: 100%;
  overflow-y: scroll;
}

    .track-circle {
  position: relative;
}

.track-tooltip {
  display: none;
  position: absolute;
  bottom: 50px;
  left: 50%;
  transform: translateX(-50%);
  background-color: #333;
  color: #f3f3f3;
  padding: 5px 10px;
  border-radius: 7px;
  font-size: 12px;
  white-space: normal;
  min-width: 160px;
  text-align: center;
  z-index: 100;
}
    
    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
        align-items: center;
      }

      .controls button,
      .controls select,
      .controls label {
        width: 100%;
        max-width: 300px;
      }
    }
  </style>
</head>
<body>

  <div class="controls">
    <div class="filter-section">
        <div class="checkbox-container">
            <label class="section-title">Жанри:</label>
            <div class="checkbox-grid" id="genre-checkboxes"></div>
            <div class="button-group">
                <button id="select-all-genres">Вибрати всі</button>
                <button id="deselect-all-genres">Зняти всі</button>
            </div>
        </div>

        <div class="checkbox-container">
            <label class="section-title">Мови:</label>
            <div class="checkbox-grid" id="language-checkboxes"></div>
        </div>
      
      <div class="checkbox-container">
    <label class="section-title">Тип релізу:</label>
    <div class="checkbox-grid" id="release-type-checkboxes"></div>
  </div>
</div>

      <div class="sort-and-blacklist">
        <div class="sort-section">
          <label for="sort-order">Сортування:</label>
          <select id="sort-order">
            <option value="desc">Спочатку нові</option>
            <option value="asc">Спочатку старі</option>
            <option value="listens-desc">Більше прослуховувань</option>
          </select>
        </div>

        <div class="hide-listened-section">
          <label for="hide-listened">
            <input type="checkbox" id="hide-listened"> Приховати <span id="show-listened-albums" style="cursor: pointer; text-decoration: underline;">прослухані альбоми</span>
          </label>
        </div>

        <div class="blacklist-section">
          <button id="blacklist-button">Чорний список</button>
        </div>

        <label>Альбомів з урахуванням фільтрів: <span id="album-count">0</span></label>
      </div>
    </div>
    
  <div id="albums-container"></div>
  <div class="lazy-loading" id="lazy-loading">Завантаження альбомів...</div>

<div id="blacklist-modal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    
    <div class="tabs">
      <button class="tablink active" id="blacklist-tab" onclick="openTab(event, 'blacklist-content')">Чорний список</button>
      <button class="tablink" id="listened-albums-tab" onclick="openTab(event, 'listened-albums-content')">Прослухані альбоми</button>
      <button class="tablink" id="export-tab" onclick="openTab(event, 'export-content')">Перенесення даних</button>
    </div>
    
    <div id="blacklist-content" class="tabcontent active">
  <div class="blacklist-container">
    <div class="blacklist-artists">
      <h4>Артисти</h4>
      <ul id="blacklisted-artists"></ul>
    </div>
    <div class="blacklist-labels">
      <h4>Лейбли</h4>
      <ul id="blacklisted-labels"></ul>
    </div>
  </div>
</div>

    <div id="listened-albums-content" class="tabcontent">
  <div class="listened-albums-container">
    <ul id="listened-albums-list"></ul>
  </div>
</div>

    <div id="export-content" class="tabcontent">
      <div class="export-import-container">
        <div class="export-section">
          <label for="data-textarea">Дані для експорту:</label>
          <textarea id="data-textarea" readonly></textarea>
        </div>
        <div class="import-section">
          <label for="import-textarea">Вставте сюди дані для імпорту:</label>
          <textarea id="import-textarea" placeholder="Вставте сюди дані"></textarea>
        </div>
      </div>
      <button id="export-data">Копіювати дані</button>
      <button id="import-data">Завантажити дані</button>
    </div>
  </div>
</div>

  <div class="modal-overlay"></div>
  
  <script>
const sheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQF8E3B7sRWEdfGxrRwQqtNvf4scBZexST0LGUbR7cXss53wcZw6UCZFHA9ChflUcDOJDTL1F1pJ3M8/pub?gid=1080612412&single=true&output=csv";
const genreSheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQF8E3B7sRWEdfGxrRwQqtNvf4scBZexST0LGUbR7cXss53wcZw6UCZFHA9ChflUcDOJDTL1F1pJ3M8/pub?gid=1188820798&single=true&output=csv";
const listenCountsUrl = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTAGLlApqsn47ofP8EU8kn9CjY8YabOQmBfm_Th_R60QO5b49nGe75DYfK4oIWHs4mHZ0jCPuanUIc-/pub?gid=0&single=true&output=csv';
const artistUrlSheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQF8E3B7sRWEdfGxrRwQqtNvf4scBZexST0LGUbR7cXss53wcZw6UCZFHA9ChflUcDOJDTL1F1pJ3M8/pub?gid=0&single=true&output=csv";
const bestAlbumsUrl = "https://docs.google.com/spreadsheets/d/1_PavIrMhHpUHXG7uDrT83yznb2nrJfSd-9G8Hnm9ywM/pub?gid=623505348&single=true&output=csv";

let listenCountsData = {};
let albumsData = [];
let artistIdsSet = new Set();
let albumsMap = new Map();
let trackToGenres = new Map();
let currentIndex = 0;
let sortOrder = 'desc';
let hideListened = false;
let audioActivated = false;

    function normalizeAlbumLink(url) {
  try {
    const urlObj = new URL(url);
    return urlObj.origin + urlObj.pathname;
  } catch(e) {
    console.error('Некоректний URL альбому:', url);
    return null;
  }
}

    const languageLabels = {
  'ukr': 'українська',
  'eng': 'англійська',
  'other lang': 'інші мови',
  'rus': 'російська',
  'без голосу': 'без голосу'
};
    
const batchSize = 10;
const listenedAlbums = JSON.parse(localStorage.getItem('listenedAlbums')) || {};

function fetchArtistUrlsData() {
  return new Promise((resolve) => {
    Papa.parse(artistUrlSheetUrl, {
      download: true,
      header: true,
      complete: function (results) {
        results.data.forEach(row => {
          [row.URL1, row.URL2, row.URL3, row.URL4, row.URL5, row.URL6].forEach(url => {
            if (url) {
              const artistId = extractArtistId(url);
              if (artistId) artistIdsSet.add(artistId);
            }
          });
        });
        resolve();
      }
    });
  });
}

function extractArtistId(url) {
  try {
    const urlObj = new URL(url);
    const pathname = urlObj.pathname;
    const parts = pathname.split('/');
    const index = parts.indexOf('artist');
    if (index !== -1 && parts[index + 1]) {
      return parts[index + 1];
    }
  } catch (e) {
    console.error('Invalid URL:', url);
  }
  return null;
}
    
function fetchAlbumsData() {
  return Promise.all([
    new Promise((resolve) => {
      Papa.parse(sheetUrl, {
        download: true,
        header: true,
        complete: function (results) {
          resolve(results.data);
        },
        error: function(error) {
          console.error('Помилка під час завантаження main sheet:', error);
          resolve([]);
        }
      });
    }),
    new Promise((resolve) => {
      Papa.parse(genreSheetUrl, {
        download: true,
        complete: function (results) {
          resolve(results.data);
        },
        error: function(error) {
          console.error('Помилка під час завантаження genre sheet:', error);
          resolve([]);
        }
      });
    }),
    new Promise((resolve) => {
      Papa.parse(listenCountsUrl, {
        download: true,
        header: true,
        complete: function (results) {
          listenCountsData = processListenCounts(results.data);
          resolve();
        },
        error: function(error) {
          console.error('Помилка під час завантаження listen counts:', error);
          resolve();
        }
      });
    })
  ]).then(([albumData, genreData]) => {
    processGenreData(genreData);
    processAlbumData(albumData);
    return fetchBestAlbumsData();
  }).then(() => {
    populateFilters();
  });
}

function loadFiltersAfterRender() {
  const filterData = JSON.parse(localStorage.getItem('albumFilters'));

  if (filterData) {
    const allGenreCheckboxes = document.querySelectorAll('.genre-checkbox');
    allGenreCheckboxes.forEach(checkbox => {
      checkbox.checked = false;
      checkbox.disabled = false;
      const label = checkbox.nextElementSibling;
      label.style.textDecoration = 'none';
      label.style.color = '#f3f3f3';
    });

    if (Array.isArray(filterData.selectedGenres)) {
      filterData.selectedGenres.forEach(genre => {
        const checkbox = document.getElementById(`genre-${encodeURIComponent(genre)}`);
        if (checkbox) {
          checkbox.checked = true;
        }
      });
    }

    if (Array.isArray(filterData.excludedGenres)) {
      filterData.excludedGenres.forEach(genre => {
        const checkbox = document.getElementById(`genre-${encodeURIComponent(genre)}`);
        if (checkbox) {
          checkbox.disabled = true;
          const genreCross = checkbox.parentNode.querySelector('.exclude-genre');
          genreCross.textContent = '↻';
          genreCross.classList.add('repeat-symbol');
          genreCross.classList.add('exclude-genre');
          const label = checkbox.nextElementSibling;
          label.style.textDecoration = 'line-through';
          label.style.color = 'gray';
        }
      });
    }

    const allLanguageCheckboxes = document.querySelectorAll('.language-checkbox');
    allLanguageCheckboxes.forEach(checkbox => {
      checkbox.checked = false;
      checkbox.disabled = false;
      const label = checkbox.nextElementSibling;
      label.style.textDecoration = 'none';
      label.style.color = '#f3f3f3';
    });

    if (Array.isArray(filterData.selectedLanguages)) {
      filterData.selectedLanguages.forEach(language => {
        const checkbox = document.getElementById(`language-${encodeURIComponent(language)}`);
        if (checkbox) {
          checkbox.checked = true;
        }
      });
    }

    if (Array.isArray(filterData.excludedLanguages)) {
      filterData.excludedLanguages.forEach(language => {
        const checkbox = document.getElementById(`language-${encodeURIComponent(language)}`);
        if (checkbox) {
          checkbox.disabled = true;
          const languageCross = checkbox.parentNode.querySelector('.exclude-language');
          languageCross.textContent = '↻';
          languageCross.classList.add('language-repeat-symbol');
          languageCross.classList.add('exclude-language');
          const label = checkbox.nextElementSibling;
          label.style.textDecoration = 'line-through';
          label.style.color = 'gray';
        }
      });
    }

    const allReleaseTypeCheckboxes = document.querySelectorAll('.release-type-checkbox');
    allReleaseTypeCheckboxes.forEach(checkbox => {
      checkbox.checked = false;
    });

    if (Array.isArray(filterData.selectedReleaseTypes)) {
      filterData.selectedReleaseTypes.forEach(type => {
        const checkbox = document.getElementById(`release-type-${type}`);
        if (checkbox) {
          checkbox.checked = true;
        }
      });
    }

    if (filterData.sortOrder) {
      document.getElementById('sort-order').value = filterData.sortOrder;
      sortOrder = filterData.sortOrder;
    }

    if (typeof filterData.hideListened === 'boolean') {
      document.getElementById('hide-listened').checked = filterData.hideListened;
      hideListened = filterData.hideListened;
    }

    applyFilters();
  }
}

function attachEventListeners() {
  document.getElementById('genre-checkboxes').addEventListener('change', (e) => {
    if (e.target && e.target.classList.contains('genre-checkbox')) {
      applyFilters();
      saveFiltersToCache();
    }
  });

  document.getElementById('language-checkboxes').addEventListener('change', (e) => {
    if (e.target && e.target.classList.contains('language-checkbox')) {
      applyFilters();
      saveFiltersToCache();
    }
  });

  document.getElementById('sort-order').addEventListener('change', (e) => {
    sortOrder = e.target.value;
    applyFilters();
    saveFiltersToCache();
  });

  document.getElementById('hide-listened').addEventListener('change', (e) => {
    hideListened = e.target.checked;
    applyFilters();
    saveFiltersToCache();
  });

  document.getElementById('genre-checkboxes').addEventListener('click', (e) => {
    if (e.target && e.target.classList.contains('exclude-genre')) {
      const genre = e.target.getAttribute('data-genre');
      const checkbox = document.getElementById(`genre-${encodeURIComponent(genre)}`);
      const label = checkbox.nextElementSibling;
      toggleExcludeGenre(genre, checkbox, label, e.target);

      saveFiltersToCache();
    }
  });

  document.getElementById('language-checkboxes').addEventListener('click', (e) => {
    if (e.target && e.target.classList.contains('exclude-language')) {
      const language = e.target.getAttribute('data-language');
      const checkbox = document.getElementById(`language-${encodeURIComponent(language)}`);
      const label = checkbox.nextElementSibling;
      toggleExcludeLanguage(language, checkbox, label, e.target);
      saveFiltersToCache();
    }
  });
}

function saveFiltersToCache() {
  const selectedGenres = Array.from(document.querySelectorAll('.genre-checkbox:checked'))
    .map(checkbox => checkbox.value);
  const excludedGenres = Array.from(document.querySelectorAll('.genre-checkbox:disabled'))
    .map(checkbox => checkbox.value);

  const selectedLanguages = Array.from(document.querySelectorAll('.language-checkbox:checked'))
    .map(checkbox => checkbox.value);
  const excludedLanguages = Array.from(document.querySelectorAll('.language-checkbox:disabled'))
    .map(checkbox => checkbox.value);

  const selectedReleaseTypes = Array.from(document.querySelectorAll('.release-type-checkbox:checked'))
    .map(checkbox => checkbox.value);

  const sortOrder = document.getElementById('sort-order').value;
  const hideListened = document.getElementById('hide-listened').checked;

  const filterData = {
    selectedGenres,
    excludedGenres,
    selectedLanguages,
    excludedLanguages,
    selectedReleaseTypes,
    sortOrder,
    hideListened
  };

  localStorage.setItem('albumFilters', JSON.stringify(filterData));
}

function init() {
  const blacklistArtists = JSON.parse(localStorage.getItem('blacklistedArtists')) || [];
  const blacklistLabels = JSON.parse(localStorage.getItem('blacklistedLabels')) || [];
  const listenedAlbums = JSON.parse(localStorage.getItem('listenedAlbums')) || {};
  const albumFilters = JSON.parse(localStorage.getItem('albumFilters')) || null;

  fetchArtistUrlsData().then(() => {
    fetchAlbumsData().then(() => {
      attachEventListeners();
      if (albumFilters) {
        console.log("Дані фільтрів знайдено, застосовуються фільтри.");
        loadFiltersAfterRender();
      } else {
        console.log("Фільтри не знайдено, дані завантажено за замовчуванням.");
        disableRusLanguage();
        applyFilters();
      }
    });
  });
}

    function disableRusLanguage() {
  const rusCheckbox = document.getElementById(`language-${encodeURIComponent('rus')}`);
  const label = rusCheckbox.nextElementSibling;
  const languageCross = rusCheckbox.parentNode.querySelector('.exclude-language');

  rusCheckbox.disabled = true;
  languageCross.textContent = '↻';
  languageCross.classList.add('language-repeat-symbol');
  label.style.textDecoration = 'line-through';
  label.style.color = 'gray';

  saveFiltersToCache();
}

function processGenreData(data) {
  const headers = data[0].map(header => header.trim());
  const languageColumns = new Set([0, 1, 2, 9]);

  const tracksInfo = [];

  for (let rowIndex = 3; rowIndex < data.length; rowIndex++) {
    const row = data[rowIndex];
    for (let colIndex = 0; colIndex < row.length; colIndex++) {
      const trackUrl = row[colIndex];
      if (trackUrl) {
        const isLanguage = languageColumns.has(colIndex);
        const category = headers[colIndex];

        if (!trackToGenres.has(trackUrl)) {
          trackToGenres.set(trackUrl, { languages: new Set(), genres: new Set() });
        }

        if (isLanguage) {
          trackToGenres.get(trackUrl).languages.add(category);
        } else {
          trackToGenres.get(trackUrl).genres.add(category);
        }
      }
    }
  }
}

function getDisplayGenres(album) {
  return Array.from(album.genres).filter(genre => !excludedGenresList.includes(genre));
}
    
const excludedPopOrIndieGenres = ['intro voice', 'a cappella'];

function processAlbumData(rawData) {
  rawData.forEach(item => {
    if (!['album', 'EP'].includes(item.type) || item.album === "") return;

    const normalizedAlbumUrl = normalizeAlbumLink(item.album);
    if (!normalizedAlbumUrl) return;

    let album = albumsMap.get(normalizedAlbumUrl);
    if (!album) {
      album = {
        img: item.img,
        nameAlbum: item.nameAlbum,
        albumUrl: item.album,
        normalizedAlbumUrl: normalizedAlbumUrl,
        artistName: item.nameAA,
        artistUrl: item.artist,
        artistId: extractArtistId(item.artist),
        date: item.date,
        label: item.label,
        duration: item.duration,
        tracks: [],
        listenedTracks: new Set(),
        listened: listenedAlbums[item.album] || false,
        languages: new Set(),
        genres: new Map(),
        totalListens: 0,
        type: item.type
      };
      albumsMap.set(normalizedAlbumUrl, album);
    }

    const track = {
      trackUrl: item.track,
      preview: item.preview
    };
    album.tracks.push(track);

    const trackGenres = trackToGenres.get(item.track);
    if (trackGenres) {
      trackGenres.languages.forEach(lang => album.languages.add(lang));

      let trackSpecificGenres = Array.from(trackGenres.genres);

      const hasGoodGenre = trackSpecificGenres.includes("good");

      if (hasGoodGenre) {
        if (album.genres.has("good")) {
          album.genres.set("good", album.genres.get("good") + 1);
        } else {
          album.genres.set("good", 1);
        }
      }

      trackSpecificGenres = trackSpecificGenres.filter(genre => genre !== "good");

      const hasExcludedPopOrIndieGenre = trackSpecificGenres.some(genre => excludedPopOrIndieGenres.includes(genre));

      const hasSpecialGenre = trackSpecificGenres.some(genre => specialGenres.includes(genre));
      if (!hasSpecialGenre && trackSpecificGenres.length === 0 && trackGenres.languages.size > 0 && !hasExcludedPopOrIndieGenre) {
        trackSpecificGenres.push("pop/indie");
      }

      trackSpecificGenres.forEach(genre => {
        if (album.genres.has(genre)) {
          album.genres.set(genre, album.genres.get(genre) + 1);
        } else {
          album.genres.set(genre, 1);
        }
      });
    }

    const spotifyUri = item.track;
    album.totalListens += listenCountsData[spotifyUri] || 0;
  });

  albumsData = Array.from(albumsMap.values());

  albumsData.forEach(album => {
    const remainingGenres = Array.from(album.genres.keys()).filter(genre => !excludedGenresList.includes(genre));

    if (remainingGenres.length === 0 && album.languages.size > 0 && !album.genres.has('pop/indie')) {
      album.genres.set('pop/indie', 1);
    }

    const sortedGenres = Array.from(album.genres.entries()).sort((a, b) => b[1] - a[1]);
    
    album.genres = new Set(sortedGenres.map(genre => genre[0]));
  });
}

    function fetchBestAlbumsData() {
  return new Promise((resolve) => {
    Papa.parse(bestAlbumsUrl, {
      download: true,
      header: true,
      complete: function(results) {
        results.data.forEach(row => {
          const albumLink = row["Best albums"];
          if (albumLink) {
            const normalizedLink = normalizeAlbumLink(albumLink);
            if (normalizedLink && albumsMap.has(normalizedLink)) {
              const album = albumsMap.get(normalizedLink);
              album.genres.add('good');
            }
          }
        });
        resolve();
      },
      error: function(error) {
        console.error('Помилка під час завантаження Best Albums CSV:', error);
        resolve();
      }
    });
  });
}

function processListenCounts(data) {
  const listenCounts = {};
  data.forEach(row => {
    const trackUri = row["Track URL"];
    const listens = parseInt(row[Object.keys(row)[0]]) || parseInt(row[Object.keys(row)[1]]);
    if (trackUri && !isNaN(listens)) {
      listenCounts[trackUri] = listens;
    }
  });
  return listenCounts;
}
    
const excludedGenresList = [
  "intro voice", "rap rus", "trap rus", "debut", "intro inst", "duet", "pop rus", "minus", "rock rus", "metal rus", "producing work for international", "post-punk rus", "trap humor", "midtempo", "opera", "duet international"
];
    
function populateFilters() {
  const genreContainer = document.getElementById('genre-checkboxes');
  const languageContainer = document.getElementById('language-checkboxes');

  const genresCountMap = new Map();
  const languagesCountMap = new Map();

  const filteredAlbums = albumsData.filter(album => artistIdsSet.has(album.artistId));

  filteredAlbums.forEach(album => {
    album.genres.forEach(genre => {
      if (!excludedGenresList.includes(genre)) {
        const displayGenre = genre === "good" ? "NUAM recommends" : genre;
        genresCountMap.set(displayGenre, (genresCountMap.get(displayGenre) || 0) + 1);
      }
    });

    album.languages.forEach(language => {
      languagesCountMap.set(language, (languagesCountMap.get(language) || 0) + 1);
    });
  });

  languagesCountMap.set('без голосу', filteredAlbums.filter(album => album.languages.size === 0).length);

  genreContainer.innerHTML = '';
  languageContainer.innerHTML = '';

  const sortedGenres = [...genresCountMap.entries()].sort((a, b) => b[1] - a[1]);

  const genreFragment = document.createDocumentFragment();
  sortedGenres.forEach(([genre, count]) => {
    const genreDiv = document.createElement('div');
    genreDiv.classList.add('genre-filter-item');

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = genre;
    checkbox.id = `genre-${encodeURIComponent(genre)}`;
    checkbox.classList.add('genre-checkbox');

    const label = document.createElement('label');
    label.htmlFor = checkbox.id;

    const genreName = document.createElement('span');
    genreName.classList.add('genre-name');
    genreName.textContent = genre;

    const genreCount = document.createElement('span');
    genreCount.classList.add('genre-count');
    genreCount.textContent = ` (${count})`;

    const genreCross = document.createElement('span');
    genreCross.textContent = '✖';
    genreCross.classList.add('exclude-genre');
    genreCross.style.cursor = 'pointer';
    genreCross.setAttribute('data-genre', genre);

    label.appendChild(genreName);
    label.appendChild(genreCount);

    genreDiv.appendChild(checkbox);
    genreDiv.appendChild(label);
    genreDiv.appendChild(genreCross);
    genreFragment.appendChild(genreDiv);
  });
  genreContainer.appendChild(genreFragment);
  
  const languageFragment = document.createDocumentFragment();
const languageOrder = ['ukr', 'eng', 'other lang', 'rus', 'без голосу'];
languageOrder.forEach(language => {
  const count = languagesCountMap.get(language) || 0;

  const languageDiv = document.createElement('div');
  languageDiv.classList.add('language-filter-item');

  const checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.value = language;
  checkbox.id = `language-${encodeURIComponent(language)}`;
  checkbox.classList.add('language-checkbox');

  const label = document.createElement('label');
  label.htmlFor = checkbox.id;

  const languageName = document.createElement('span');
  languageName.classList.add('language-name');
  languageName.textContent = languageLabels[language] || language;

  const languageCount = document.createElement('span');
  languageCount.classList.add('language-count');
  languageCount.textContent = ` (${count})`;

  const languageCross = document.createElement('span');
  languageCross.textContent = '✖';
  languageCross.classList.add('exclude-language');
  languageCross.style.cursor = 'pointer';
  languageCross.setAttribute('data-language', language);

  label.appendChild(languageName);
  label.appendChild(languageCount);

  languageDiv.appendChild(checkbox);
  languageDiv.appendChild(label);
  languageDiv.appendChild(languageCross);
  languageFragment.appendChild(languageDiv);
});
languageContainer.appendChild(languageFragment);
  
  const releaseTypeContainer = document.getElementById('release-type-checkboxes');

  const releaseTypes = ['album', 'EP'];
  const releaseTypeLabels = {
    'album': 'повноформатні альбоми',
    'EP': 'міні-альбоми'
  };

  releaseTypes.forEach(type => {
    const typeDiv = document.createElement('div');
    typeDiv.classList.add('release-type-filter-item');

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = type;
    checkbox.id = `release-type-${type}`;
    checkbox.classList.add('release-type-checkbox');
    checkbox.checked = true;

    const label = document.createElement('label');
    label.htmlFor = checkbox.id;
    label.textContent = releaseTypeLabels[type];

    typeDiv.appendChild(checkbox);
    typeDiv.appendChild(label);
    releaseTypeContainer.appendChild(typeDiv);
  });
}

function toggleExcludeGenre(genre, checkbox, label, genreCross) {
  if (checkbox.disabled) {
    checkbox.disabled = false;
    genreCross.textContent = '✖';
    genreCross.classList.remove('repeat-symbol');
    label.style.textDecoration = 'none';
    label.style.color = '#f3f3f3';
  } else {
    checkbox.disabled = true;
    genreCross.textContent = '↻';
    genreCross.classList.add('repeat-symbol');
    label.style.textDecoration = 'line-through';
    label.style.color = 'gray';
  }
  applyFilters();
}

function toggleExcludeLanguage(language, checkbox, label, languageCross) {
  if (checkbox.disabled) {
    checkbox.disabled = false;
    languageCross.textContent = '✖';
    languageCross.classList.remove('language-repeat-symbol', 'repeat-symbol');
    label.style.textDecoration = 'none';
    label.style.color = '#f3f3f3';
  } else {
    checkbox.disabled = true;
    languageCross.textContent = '↻';
    languageCross.classList.add('language-repeat-symbol');
    languageCross.classList.remove('repeat-symbol');
    label.style.textDecoration = 'line-through';
    label.style.color = 'gray';
  }
  applyFilters();
}

let filteredAlbums = [];
let blacklistedArtists = new Set(JSON.parse(localStorage.getItem('blacklistedArtists')) || []);
let blacklistedLabels = new Set(JSON.parse(localStorage.getItem('blacklistedLabels')) || []);

function applyFilters() {
  filteredAlbums = albumsData;

  const selectedGenres = Array.from(document.querySelectorAll('.genre-checkbox:checked'))
    .map(checkbox => checkbox.value === "NUAM recommends" ? "good" : checkbox.value);

  const selectedLanguages = Array.from(document.querySelectorAll('.language-checkbox:checked'))
    .map(checkbox => checkbox.value);

  if (selectedGenres.length > 0) {
    filteredAlbums = filteredAlbums.filter(album => {
      const displayGenres = getDisplayGenres(album);
      return selectedGenres.some(genre => displayGenres.includes(genre));
    });
  }

  if (selectedLanguages.length > 0) {
    filteredAlbums = filteredAlbums.filter(album => {
      return selectedLanguages.some(language => {
        if (language === 'без голосу') {
          return album.languages.size === 0;
        } else {
          return album.languages.has(language);
        }
      });
    });
  }

  const excludedGenres = Array.from(document.querySelectorAll('.genre-checkbox:disabled'))
    .map(checkbox => checkbox.value === "NUAM recommends" ? "good" : checkbox.value);

  if (excludedGenres.length > 0) {
    filteredAlbums = filteredAlbums.filter(album => {
      return !excludedGenres.some(genre => album.genres.has(genre));
    });
  }

  const excludedLanguages = Array.from(document.querySelectorAll('.language-checkbox:disabled'))
    .map(checkbox => checkbox.value);

  if (excludedLanguages.length > 0) {
    filteredAlbums = filteredAlbums.filter(album => {
      return !excludedLanguages.some(language => {
        if (language === 'без голосу') {
          return album.languages.size === 0;
        } else {
          return album.languages.has(language);
        }
      });
    });
  }

  const selectedReleaseTypes = Array.from(document.querySelectorAll('.release-type-checkbox:checked'))
    .map(checkbox => checkbox.value);

  if (selectedReleaseTypes.length > 0) {
    filteredAlbums = filteredAlbums.filter(album => selectedReleaseTypes.includes(album.type));
  }

  filteredAlbums = filteredAlbums.filter(album => artistIdsSet.has(album.artistId));

  filteredAlbums = filteredAlbums.filter(album => {
    return album.tracks.some(track => track.preview && track.preview.trim() !== '');
  });

  filteredAlbums = filteredAlbums.filter(album => !blacklistedArtists.has(album.artistName));
  filteredAlbums = filteredAlbums.filter(album => !blacklistedLabels.has(album.label));

  if (hideListened) {
    filteredAlbums = filteredAlbums.filter(album => !album.listened);
  }

  if (sortOrder === 'listens-desc') {
    filteredAlbums.sort((a, b) => b.totalListens - a.totalListens);
  } else {
    filteredAlbums.sort((a, b) => {
      const dateA = parseDate(a.date);
      const dateB = parseDate(b.date);
      return sortOrder === 'asc' ? dateA - dateB : dateB - dateA;
    });
  }

  currentIndex = 0;
  renderAlbums(filteredAlbums, true);

  document.getElementById('album-count').textContent = filteredAlbums.length;
}

document.getElementById('select-all-genres').addEventListener('click', () => {
  const genreCheckboxes = document.querySelectorAll('.genre-checkbox');
  genreCheckboxes.forEach(checkbox => {
    if (!checkbox.disabled) checkbox.checked = true;
  });
  applyFilters();
  saveFiltersToCache();
});

document.getElementById('deselect-all-genres').addEventListener('click', () => {
  const genreCheckboxes = document.querySelectorAll('.genre-checkbox');
  genreCheckboxes.forEach(checkbox => {
    if (!checkbox.disabled) checkbox.checked = false;
  });
  applyFilters();
  saveFiltersToCache();
});

    document.getElementById('release-type-checkboxes').addEventListener('change', (e) => {
  if (e.target && e.target.classList.contains('release-type-checkbox')) {
    applyFilters();
    saveFiltersToCache();
  }
});

    
function handleScroll() {
  if ((window.innerHeight + window.scrollY >= document.body.offsetHeight - 100) && currentIndex < filteredAlbums.length) {
    renderAlbums(filteredAlbums);
  }
}

function throttle(func, limit) {
  let lastFunc;
  let lastRan;
  return function() {
    const context = this;
    const args = arguments;
    if (!lastRan) {
      func.apply(context, args);
      lastRan = Date.now();
    } else {
      clearTimeout(lastFunc);
      lastFunc = setTimeout(function() {
        if ((Date.now() - lastRan) >= limit) {
          func.apply(context, args);
          lastRan = Date.now();
        }
      }, limit - (Date.now() - lastRan));
    }
  };
}

const throttledHandleScroll = throttle(handleScroll, 200);
    
const specialGenres = [
  'rap rus', 'trap rus', 'rock rus', 'metal rus', 'post-punk rus', 'rock',
  'metal', 'post-punk', 'hip-hop', 'trap', 'trap humor', 'jersey club', 'hyperpop', 'opera'
];
    
function parseDate(dateString) {
  const [day, month, year] = dateString.split('.').map(Number);
  return new Date(year + 2000, month - 1, day);
}

function renderAlbums(filteredAlbums = albumsData, reset = false) {
  const container = document.getElementById('albums-container');
  
  if (reset) {
    container.innerHTML = '';
  }

  const endIndex = Math.min(currentIndex + batchSize, filteredAlbums.length);

  for (let i = currentIndex; i < endIndex; i++) {
    const album = filteredAlbums[i];

    const albumElement = document.createElement('div');
    albumElement.classList.add('album');
    albumElement.setAttribute('data-album-url', album.albumUrl);

    if (album.listened) {
      albumElement.classList.add('album-listened');
    }

    let languages = Array.from(album.languages).join(', ');
    
    let genres = getDisplayGenres(album);

    const hasGoodGenre = genres.includes("good");
    genres = genres.filter(genre => genre !== "good");

    if (genres.length === 0 && album.languages.size > 0 && !genres.includes('pop/indie')) {
      genres.push("pop/indie");
    }

    const hasSpecialGenre = genres.some(genre => specialGenres.includes(genre));
    if (!hasSpecialGenre && album.languages.size > 0 && !genres.includes('pop/indie')) {
      genres.push("pop/indie");
    }

    genres = genres.length ? genres.join(', ') : 'Немає даних';
    
    const languageHtml = album.languages.size > 0 
  ? `<p>Мова: ${Array.from(album.languages).map(lang => languageLabels[lang] || lang).join(', ')}</p>`
  : `<p>Мова: Без голосу</p>`;
    const labelHtml = (album.artistName !== album.label) ? `<p>Лейбл: ${album.label}</p>` : '';

    let totalListens = 0;
    album.tracks.forEach(track => {
      const spotifyUri = track.trackUrl;
      if (listenCountsData[spotifyUri]) {
        totalListens += listenCountsData[spotifyUri];
      }
    });

    const listensHtml = `
  <p>
    <span id="listens-${i}">
      Прослуховувань: ${totalListens}
    </span>
  </p>
`;

    const blacklistArtistCross = `<span id="artist-cross-${i}" class="blacklist-cross" data-type="artist" data-name="${album.artistName}" style="cursor: pointer;">✖</span>`;
    const blacklistLabelCross = album.label ? `<span id="label-cross-${i}" class="blacklist-cross" data-type="label" data-name="${album.label}" style="cursor: pointer;">✖</span>` : '';

    albumElement.innerHTML = `
      <div class="album-overlay"></div>
      <img src="${album.img}" alt="${album.nameAlbum}">
      <div class="album-details">
        <h3><a href="${album.albumUrl}" target="_blank">${album.nameAlbum}</a></h3>
        <p>Артист: <a href="${album.artistUrl}" target="_blank">${album.artistName}</a> ${blacklistArtistCross}</p>
        <p>Дата релізу: ${album.date}</p>
        <p>Тип релізу: ${album.type === 'album' ? 'Повноформатний альбом' : 'Міні-альбом'}</p>
        ${labelHtml ? `<p>Лейбл: ${album.label} ${blacklistLabelCross}</p>` : ''}
        <p>Тривалість: ${album.duration}</p>
        ${languageHtml}
        <p>Жанри: ${genres}</p>
        ${listensHtml}
      </div>
      <button class="mark-listened-btn" onclick="markAlbumAsListened('${album.albumUrl}', this.closest('.album'))">
        ${album.listened ? 'Позначити як не прослуханий' : 'Позначити як прослуханий'}
      </button>
      <div class="tracks" id="tracks-${i}"></div>
    `;

    if (hasGoodGenre) {
      const starIconContainer = document.createElement('div');
      starIconContainer.style.position = 'absolute';
      starIconContainer.style.top = '10px';
      starIconContainer.style.right = '10px';
      starIconContainer.style.fontSize = '24px';
      starIconContainer.style.zIndex = '11';

      const starIcon = document.createElement('i');
      starIcon.classList.add('fas', 'fa-star', 'star-icon'); 
      starIcon.style.color = 'gold';

      starIconContainer.appendChild(starIcon);
      albumElement.appendChild(starIconContainer);

      attachTooltip(starIconContainer, 'NUAM рекомендує цей альбом для прослуховування');
    }

    container.appendChild(albumElement);
    albumElement.querySelector('img').addEventListener('click', function () {
      const imgSrc = this.src;
      const existingEnlargedImg = document.querySelector('.enlarged-img');
      const modalOverlay = document.querySelector('.modal-overlay');

      if (existingEnlargedImg) {
        existingEnlargedImg.remove();
        modalOverlay.style.display = 'none';
        document.body.classList.remove('no-scroll');
        document.body.style.top = '';
        window.scrollTo(0, parseInt(document.body.style.top || '0') * -1);
        return;
      }

      const scrollY = window.scrollY;

      const enlargedImg = document.createElement('img');
      enlargedImg.src = imgSrc;
      enlargedImg.classList.add('enlarged-img');
      document.body.appendChild(enlargedImg);

      modalOverlay.style.display = 'block';
      document.body.classList.add('no-scroll');
      document.body.style.top = `-${scrollY}px`;

      enlargedImg.addEventListener('click', function () {
        enlargedImg.remove();
        modalOverlay.style.display = 'none';
        document.body.classList.remove('no-scroll');
        document.body.style.top = '';
        window.scrollTo(0, scrollY);
      });

      modalOverlay.addEventListener('click', function () {
        enlargedImg.remove();
        modalOverlay.style.display = 'none';
        document.body.classList.remove('no-scroll');
        document.body.style.top = '';
        window.scrollTo(0, scrollY);
      });
    });

    const tracksContainer = document.getElementById(`tracks-${i}`);
    album.tracks.forEach((track, index) => {
      const trackCircle = document.createElement('a');
      trackCircle.classList.add('track-circle');
      trackCircle.href = track.trackUrl;
      trackCircle.target = "_blank";
      trackCircle.innerHTML = `<i class="fas fa-music"></i>`;

      const audio = document.createElement('audio');
      audio.src = track.preview;
      trackCircle.appendChild(audio);

      let tooltipActivated = false;

      attachTrackTooltip(trackCircle);

      function attachTrackTooltip(element) {
        const tooltipText = 'Натисніть для відтворення уривка. Далі просто наводьте курсор на треки. У списку треків відсутні ті, які раніше виходили синглами.';
        const tooltip = document.createElement('div');
        tooltip.classList.add('tooltip');
        tooltip.textContent = tooltipText;
        tooltip.style.position = 'fixed';
        tooltip.style.backgroundColor = '#333';
        tooltip.style.color = '#f3f3f3';
        tooltip.style.padding = '5px 10px';
        tooltip.style.borderRadius = '7px';
        tooltip.style.fontSize = '12px';
        tooltip.style.visibility = 'hidden';
        tooltip.style.whiteSpace = 'normal';
        tooltip.style.maxWidth = '200px';
        tooltip.style.wordWrap = 'break-word';
        tooltip.style.zIndex = '9999';

        document.body.appendChild(tooltip);

        element.addEventListener('mouseenter', (event) => {
          if (!audioActivated) {
            tooltip.style.visibility = 'visible';
            positionTooltip(event.clientX, event.clientY, tooltip);
          } else {
            audio.play();
          }
        });

        element.addEventListener('mousemove', (event) => {
          if (!audioActivated) {
            positionTooltip(event.clientX, event.clientY, tooltip);
          }
        });

        element.addEventListener('mouseleave', () => {
          tooltip.style.visibility = 'hidden';
          if (audioActivated) {
            audio.pause();
            audio.currentTime = 0;
          }
        });

        element.addEventListener('click', (event) => {
          if (!audioActivated) {
            event.preventDefault();
            audioActivated = true;
            tooltip.style.visibility = 'hidden';
            tooltip.remove();
            audio.play();
          }
        });
      }

      audio.addEventListener('pause', () => {
        album.listenedTracks.add(track.trackUrl);
        markTrackAsListenedAfterPause(album, albumElement);
      });

      tracksContainer.appendChild(trackCircle);
    });

    const listensElement = document.getElementById(`listens-${i}`);
    attachTooltip(listensElement, `Враховуються прослуховування тільки нових треків, які раніше не виходили синглами`);

    const artistCrossElement = document.getElementById(`artist-cross-${i}`);
    if (artistCrossElement) {
      attachTooltip(artistCrossElement, 'Не показувати альбоми цього артиста');

      artistCrossElement.addEventListener('click', function() {
        removeTooltip(artistCrossElement); 
        albumElement.remove();
      });
    }

    const labelCrossElement = document.getElementById(`label-cross-${i}`);
    if (labelCrossElement) {
      attachTooltip(labelCrossElement, 'Не показувати альбоми цього лейбла');

      labelCrossElement.addEventListener('click', function() {
        removeTooltip(labelCrossElement); 
        albumElement.remove();
      });
    }
  }

  currentIndex = endIndex;

  if (currentIndex >= filteredAlbums.length) {
    document.getElementById('lazy-loading').textContent = "Більше немає альбомів для завантаження";
  } else {
    document.getElementById('lazy-loading').textContent = "Завантаження альбомів...";
  }
}

function removeTooltip(element) {
  element.dispatchEvent(new Event('mouseleave'));
}

window.addEventListener('scroll', throttledHandleScroll);

function saveListenedAlbums() {
  for (const albumUrl in listenedAlbums) {
    if (listenedAlbums[albumUrl] === false) {
      delete listenedAlbums[albumUrl];
    }
  }

  localStorage.setItem('listenedAlbums', JSON.stringify(listenedAlbums));
}

function markAlbumAsListened(albumUrl, albumElement, fromModal = false) {
  const album = albumsMap.get(albumUrl);

  if (fromModal) {
    delete listenedAlbums[albumUrl];
    album.listened = false;
    album.listenedTracks.clear();
  } else {
    album.listened = !album.listened;

    if (!album.listened) {
      delete listenedAlbums[albumUrl];
      album.listenedTracks.clear();
    } else {
      listenedAlbums[albumUrl] = true;
    }
  }

  saveListenedAlbums();

  if (albumElement) {
    const markButton = albumElement.querySelector('.mark-listened-btn');
    markButton.textContent = album.listened ? 'Позначити як не прослуханий' : 'Позначити як прослуханий';

    if (album.listened) {
      albumElement.classList.add('album-listened');
    } else {
      albumElement.classList.remove('album-listened');
    }

    if (hideListened && album.listened) {
      albumElement.style.display = 'none';
    }
  }

  updateListenedAlbumsModal();
  applyFilters();
}

function markTrackAsListenedAfterPause(album, albumElement) {
  if (album.listenedTracks.size === album.tracks.length) {
    listenedAlbums[album.albumUrl] = true;
    album.listened = true;

    saveListenedAlbums();

    albumElement.classList.add('album-listened');
    const markButton = albumElement.querySelector('.mark-listened-btn');
    markButton.textContent = 'Позначити як не прослуханий';

    if (hideListened) {
      albumElement.style.display = 'none';
    }
  }
}

document.getElementById('albums-container').addEventListener('click', function(e) {
  if (e.target && e.target.classList.contains('blacklist-cross')) {
    const type = e.target.getAttribute('data-type');
    const name = e.target.getAttribute('data-name');
    if (type === 'artist') {
      blacklistedArtists.add(name);
      localStorage.setItem('blacklistedArtists', JSON.stringify(Array.from(blacklistedArtists)));
    } else if (type === 'label') {
      blacklistedLabels.add(name);
      localStorage.setItem('blacklistedLabels', JSON.stringify(Array.from(blacklistedLabels)));
    }
    applyFilters();
  }
});

function showBlacklist(isBlacklist = true) {
  const modal = document.getElementById('blacklist-modal');
  const closeBtn = modal.querySelector('.close');

  modal.style.display = 'block';

  closeBtn.onclick = function() {
    modal.style.display = 'none';
  };
  window.onclick = function(event) {
    if (event.target == modal) {
      modal.style.display = 'none';
    }
  };

  if (isBlacklist) {
    document.getElementById('blacklist-tab').click();
  } else {
    document.getElementById('listened-albums-tab').click();
  }
}

function generateExportData() {
  const blacklistArtists = JSON.parse(localStorage.getItem('blacklistedArtists')) || [];
  const blacklistLabels = JSON.parse(localStorage.getItem('blacklistedLabels')) || [];
  const listenedAlbums = JSON.parse(localStorage.getItem('listenedAlbums')) || {};
  const albumFilters = JSON.parse(localStorage.getItem('albumFilters')) || {};

  const exportData = {
    blacklistArtists,
    blacklistLabels,
    listenedAlbums,
    albumFilters
  };
  return JSON.stringify(exportData, null, 2);
}

function openTab(evt, tabName) {
  const tablinks = document.querySelectorAll('.tablink');
  const tabcontents = document.querySelectorAll('.tabcontent');

  tabcontents.forEach(tab => tab.classList.remove('active'));
  tablinks.forEach(link => link.classList.remove('active'));

  document.getElementById(tabName).classList.add('active');
  evt.currentTarget.classList.add('active');

  if (tabName === 'blacklist-content') {
    updateBlacklist();
  } else if (tabName === 'listened-albums-content') {
    updateListenedAlbumsModal();
  } else if (tabName === 'export-content') {
    const dataTextarea = document.getElementById('data-textarea');
    const exportDataString = generateExportData();
    dataTextarea.value = exportDataString;
  }
}

function updateBlacklist() {
  const artistsList = document.getElementById('blacklisted-artists');
  const labelsList = document.getElementById('blacklisted-labels');

  artistsList.innerHTML = '';
  labelsList.innerHTML = '';

  if (blacklistedArtists.size === 0) {
    const emptyMessage = document.createElement('p');
    emptyMessage.textContent = 'Тут будуть знаходитися вилучені вами артисти, релізи яких ви не хочете бачити в загальному списку альбомів.';
    emptyMessage.style.textAlign = 'center';
    emptyMessage.style.color = '#f3f3f3';
    artistsList.appendChild(emptyMessage);
  } else {
    blacklistedArtists.forEach(artist => {
      const li = document.createElement('li');

      let artistUrl = '';
      albumsData.forEach(album => {
        if (album.artistName === artist) {
          artistUrl = album.artistUrl;
        }
      });

      const artistLink = document.createElement('a');
      artistLink.textContent = artist;
      artistLink.href = artistUrl || '#';
      artistLink.target = "_blank";
      artistLink.style.color = '#f3f3f3';
      artistLink.style.textDecoration = 'none';

      const removeIcon = document.createElement('span');
      removeIcon.textContent = '✖';
      removeIcon.classList.add('blacklist-cross');
      removeIcon.addEventListener('click', function() {
        blacklistedArtists.delete(artist);
        localStorage.setItem('blacklistedArtists', JSON.stringify(Array.from(blacklistedArtists)));
        li.remove();
        applyFilters();
      });

      li.appendChild(artistLink);
      li.appendChild(removeIcon);
      artistsList.appendChild(li);
    });
  }

  if (blacklistedLabels.size === 0) {
    const emptyMessage = document.createElement('p');
    emptyMessage.textContent = 'Тут будуть знаходитися вилучені вами лейбли, релізи яких ви не хочете бачити в загальному списку альбомів.';
    emptyMessage.style.textAlign = 'center';
    emptyMessage.style.color = '#f3f3f3';
    labelsList.appendChild(emptyMessage);
  } else {
    blacklistedLabels.forEach(label => {
      const li = document.createElement('li');
      const labelText = document.createElement('span');
      labelText.textContent = label;
      labelText.style.color = '#f3f3f3';

      const removeIcon = document.createElement('span');
      removeIcon.textContent = '✖';
      removeIcon.classList.add('blacklist-cross');
      removeIcon.addEventListener('click', function() {
        blacklistedLabels.delete(label);
        localStorage.setItem('blacklistedLabels', JSON.stringify(Array.from(blacklistedLabels)));
        li.remove();
        applyFilters();
      });

      li.appendChild(labelText);
      li.appendChild(removeIcon);
      labelsList.appendChild(li);
    });
  }
}

function updateListenedAlbumsModal() {
  const albumsList = document.getElementById('listened-albums-list');
  albumsList.innerHTML = '';

  const listenedAlbums = JSON.parse(localStorage.getItem('listenedAlbums')) || {};

  if (albumsData.filter(album => album.listened).length === 0) {
    const emptyMessage = document.createElement('p');
    emptyMessage.textContent = 'Тут буде знаходитися список відслуханих вами альбомів.';
    emptyMessage.style.textAlign = 'center';
    emptyMessage.style.color = '#f3f3f3';
    albumsList.appendChild(emptyMessage);
  } else {
    albumsData.forEach(album => {
      if (album.listened) {
        const listItem = document.createElement('li');

        const albumLink = document.createElement('a');
        albumLink.href = album.albumUrl;
        albumLink.target = '_blank';
        albumLink.textContent = `${album.artistName} - ${album.nameAlbum}`;
        albumLink.style.cursor = 'pointer';

        const removeIcon = document.createElement('span');
        removeIcon.textContent = '✖';
        removeIcon.classList.add('blacklist-cross');
        removeIcon.style.cursor = 'pointer';
        removeIcon.style.marginLeft = '10px';
        removeIcon.addEventListener('click', function() {
          markAlbumAsListened(album.albumUrl, null, true);
          listItem.remove();
        });

        listItem.appendChild(albumLink);
        listItem.appendChild(removeIcon);
        albumsList.appendChild(listItem);
      }
    });
  }
}

document.getElementById('blacklist-button').addEventListener('click', function() {
  showBlacklist(true);
});

document.getElementById('show-listened-albums').addEventListener('click', function(event) {
  event.preventDefault();
  showBlacklist(false);
});
    
function showListenedAlbumsModal() {
  const modal = document.getElementById('listened-albums-modal');
  const closeBtn = modal.querySelector('.close');

  updateListenedAlbumsModal();

  modal.style.display = 'block';

  closeBtn.onclick = function() {
    modal.style.display = 'none';
  };

  window.onclick = function(event) {
    if (event.target == modal) {
      modal.style.display = 'none';
    }
  };
}

document.getElementById('export-data').addEventListener('click', () => {
  const dataTextarea = document.getElementById('data-textarea');
  dataTextarea.select();
  navigator.clipboard.writeText(dataTextarea.value).then(function() {
    alert('Дані скопійовані в буфер обміну.');
  }).catch(function(err) {
    console.error('Помилка копіювання даних: ', err);
    alert('Помилка при копіюванні даних.');
  });
});

document.getElementById('import-data').addEventListener('click', () => {
  const importTextarea = document.getElementById('import-textarea');
  const importDataString = importTextarea.value;

  if (!importDataString) {
    alert('Введіть дані для завантаження.');
    return;
  }

  try {
    const importData = JSON.parse(importDataString);

    if (importData.blacklistArtists) {
      localStorage.setItem('blacklistedArtists', JSON.stringify(importData.blacklistArtists));
    }

    if (importData.blacklistLabels) {
      localStorage.setItem('blacklistedLabels', JSON.stringify(importData.blacklistLabels));
    }

    if (importData.listenedAlbums) {
      localStorage.setItem('listenedAlbums', JSON.stringify(importData.listenedAlbums));
    }

    if (importData.albumFilters) {
      localStorage.setItem('albumFilters', JSON.stringify(importData.albumFilters));
    }

    alert('Дані успішно завантажені. Оновіть сторінку для застосування змін.');

  } catch (error) {
    alert('Помилка при завантаженні даних. Перевірте формат введених даних.');
  }
});

function attachTooltip(element, tooltipText) {
  const tooltip = document.createElement('div');
  tooltip.classList.add('tooltip');
  tooltip.textContent = tooltipText;
  tooltip.style.position = 'fixed';
  tooltip.style.backgroundColor = '#333';
  tooltip.style.color = '#f3f3f3';
  tooltip.style.padding = '5px 10px';
  tooltip.style.borderRadius = '7px';
  tooltip.style.fontSize = '12px';
  tooltip.style.visibility = 'hidden';
  tooltip.style.whiteSpace = 'normal';
  tooltip.style.maxWidth = '120px';
  tooltip.style.wordWrap = 'break-word';
  tooltip.style.zIndex = '9999';

  document.body.appendChild(tooltip);

  element.addEventListener('mouseenter', (event) => {
    tooltip.style.visibility = 'visible';
    positionTooltip(event.clientX, event.clientY, tooltip);
  });

  element.addEventListener('mousemove', (event) => {
    positionTooltip(event.clientX, event.clientY, tooltip);
  });

  element.addEventListener('mouseleave', () => {
    tooltip.style.visibility = 'hidden';
  });
}

function positionTooltip(mouseX, mouseY, tooltip) {
  const tooltipRect = tooltip.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  let tooltipX = mouseX + 10;
  let tooltipY = mouseY + 10;

  if (tooltipX + tooltipRect.width > viewportWidth) {
    tooltipX = mouseX - tooltipRect.width - 10;
  }

  if (tooltipY + tooltipRect.height > viewportHeight) {
    tooltipY = mouseY - tooltipRect.height - 10;
  }

  tooltip.style.top = `${tooltipY}px`;
  tooltip.style.left = `${tooltipX}px`;
}

init();

</script>
</body>
</html>
